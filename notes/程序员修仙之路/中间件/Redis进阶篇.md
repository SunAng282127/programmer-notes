# 一、Redis 单线程 VS 多线程

## 一、Redis底层单线程 VS 多线程

1. Redis的版本很多3.x、4.x、6.x，版本不同架构也是不同的，不限定版本问是否单线程也不太严谨

   - 版本3.x ，最早版本，也就是大家口口相传的redis是单线程
   - 版本4.x，严格意义来说也不是单线程，而是负责处理客户端请求的线程是单线程，但是开始加了点多线程的东西（异步删除）
   - 2020年5月版本的6.0.x后及2022年出的7.0版本后，告别了单线程，用一种全新的多线程来解决问题

2. Redis重要里程碑

   ![](../../../TyporaImage/1.%E9%87%8C%E7%A8%8B%E7%A2%91%E5%BC%8F%E7%89%88%E6%9C%AC.png)

## 二、Redis最初是单线程的理解

1. 其实Redis最初整体也不是单线程。Redis是单线程主要是指Redis的网络IO和键值对读写是由一个线程来完成的，Redis在处理客户端的请求时包括获取（socket读）、解析、执行、内容返回（socket写）等都由一个顺序串行的主线程处理，这就是所谓的“单线程”。这也是Redis对外提供键值存储服务的主要流程

   ![](../../../TyporaImage/2.Redis%E9%87%87%E7%94%A8reactor%E6%A8%A1%E5%BC%8F.png)

2. 但Redis的其他功能，比如持久化RDB、AOF、异步删除、集群数据同步等等，其实是由额外的线程执行的

3. 总的来说Redis命令工作线程是单线程的，但是，整个Redis来说，是多线程的

## 三、Redis最初是单线程但性能依旧很快的主因

1. 基于内存操作：Redis的所有数据都存在内存中，因此所有的运算都是内存级别的，所以性能比较高
2. 数据结构简单：Redis的数据结构是专门设计的，而这些简单的数据结构的查找和操作的时间大部分复杂度都是O(1)，因此性能比较高
3. 多路复用和非阻塞I/O：Redis使用I/O多路复用功能来监听多个socket连接客户端，这样就可以使用一个线程连接来处理多个请求，减少线程切换带来的开销，同时也避免了I/O阻塞操作
4. 避免上下文切换：因为是单线程模型，因此就避免了不必要的上下文切换和多线程竞争，这就省去了多线程切换带来的时间和性能上的消耗，而且单线程不会导致死锁问题的发生

## 四、Redis是单线程但能利用多个CPU的原因

1. CPU并不是使用Redis的瓶颈，因为通常Redis要么受内存限制，要么受网络限制。例如，使用在平均Linux系统上运行的流水线Redis每秒可以发送一百万个请求，因此，如果您的应用程序主要使用O(N)或O(log(N))命令，则几乎不会使用过多的CPU
2. 但是，为了最大程度地利用CPU，您可以在同一框中启动多个Redis实例，并将它们视为不同的服务器。在某个时候，单个盒子可能还不够，因此，如果您要使用多个CPU，则可以开始考虑更早地进行分片的某种方法
3. 但是，在Redis4.0中，我们开始使Redis具有更多线程，目前，这仅限于在后台删除对象，以及阻止通过Redis模块实现的命令
4. 以上均为Redis作者的原话翻译。大致意思就是Redis是基于内存操作的，Redis的瓶颈可能是机器的内存或者网络带宽而并非CPU，既然CPU不是瓶颈，那么自然就采用单线程的解决方案了，况且使用多线程比较麻烦。是在Redis 4.0中开始支持多线程了，例如后台删除、备份等功能

## 五、Redis最初采用单线程的原因

1. 使用单线程模型使Redis的开发和维护更简单，因为单线程模型方便开发和调试
2. 即使使用单线程模型同时并发的处理多客户端的请求，主要使用的是IO多路复用和非阻塞IO
3. 对于Redis系统来说，主要的性能瓶颈是内存或者网络带宽而并非CPU

## 六、Redis逐渐加入多线程特性的原因

1. bigKey的影响：比如正常情况下使用del指令可以很快的删除数据，而当被删除的key是一个非常大的对象时，例如key包含了成千上万个元素的hash集合时，那么del指令就会造成Redis 主线程卡顿。Redis3单线程时代，大key删除需要等待很久线程才能释放，类似于加了synchronized锁，在高并发的情况下，这种问题不容小觑

2. 解决方法：

   - 使用惰性删除可以有效的解决性能问题：比如当Redis需要删除一个很大的数据时，因为是单线程原子命令操作，这就会导致Redis服务卡顿，于是在Redis 4.0中就新增了多线程的模块，当然此版本中的多线程主要是为了解决删除数据效率比较低的问题的。例如`unlink key`、`flushdb async`、`flushall async`。这样就把删除工作交给了后台的子线程异步删除数据了

   - 因为Redis是单个主线程处理，Redis之父antirez一直强调"Lazy Redis is better Redis"。

     而lazy free的本质就是把某些cost（主要时间复杂度，占用主线程cpu时间片）较高删除操作，从Redis主线程剥离让bio子线程来处理，极大地减少主线阻塞时间。从而减少删除导致性能和稳定性问题

   - 在Redis4.0就引入了多个线程来实现数据的异步惰性删除等功能但是其处理读写请求的仍然只有一个线程，所以仍然算是狭义上的单线程

## 七、Redis6/7的多线程特性

1. 对于Redis来说CPU并不是瓶颈，而内存和网络带宽才是限制Redis的主要因素

   ![](../../../TyporaImage/5.Redis%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D%E5%9B%A0%E7%B4%A0.png)

   ![](../../../TyporaImage/6.Redis%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D%E5%9B%A0%E7%B4%A0.png)

2. Redis的瓶颈可以初步定为：网络IO

   - Redis一直被大家熟知的就是它的单线程架构，虽然有些命令操作可以用后台线程或子进程执行（比如数据删除、快照生成、AOF重写）。但是，从网络IO处理到实际的读写命令处理，都是由单个线程完成的
   - 随着网络硬件的性能提升，Redis的性能瓶颈有时会出现在网络IO的处理上，也就是说，单个主线程处理网络请求的速度跟不上底层网络硬件的速度
   - 为了应对这个问题，Redis采用多个IO线程来处理网络请求，提高网络请求处理的并行度，Redis6/7就是采用的这种方法
   - **Redis的多IO线程只是用来处理网络请求的，对于读写操作命今Redis仍然使用单线程来处理。**这是因为，Redis处理请求时，网络处理经常是瓶颈，通过多个IO线程并行处理网络操作，可以提升实例的整体处理性能。而继续使用单线程执行命今操作，就不用为了保证Lua脚本、事务的原子性，额外开发多线程互斥加锁机制了（不管加锁操作处理），这样一来，Redis线程模型实现就简单了

3. 主线程和IO线程协作完成请求处理的步骤

   ![](../../../TyporaImage/7.Redis%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%92%8Csocket%E7%9A%84%E8%BF%9E%E6%8E%A5.png)

   ![](../../../TyporaImage/8.IO%E5%9B%9E%E5%86%99socket.png)

## 八、初识IO多路复用

### 一、Unix网络编程中的五种IO模型

1. Blocking IO：阻塞IO。一个应用程序执行I/O操作时，会被阻塞，直到数据准备好或操作完成。这种模型通常简单易用，但会造成资源浪费。因为CPU在等待I/O操作完成时无法做其他有用的工作 

2. NoneBlocking IO：非阻塞IO。 应用程序执行I/O操作时不会被阻塞，可以立即返回，然后定期检查操作是否完成。这种模型需要应用程序不断轮询状态，可能会降低性能并增加复杂性

   - NIO是为了弥补传统IO的不足而诞生的，NIO也有缺点，因为NIO是面向缓冲区的操作，每一次的数据处理都是对缓冲区进行的，在数据处理之前必须要判断缓冲区的数据是否完整或者已经读取完毕，如果没有，假设只读取了一部分，那么对不完整的数据处理没有任何意义。所以每次数据处理之前都要检测缓冲区数据
   - 如果需要管理同时打开成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，这时候用NIO处理数据
   - 如果是少量连接，而这些连接每次要发送大量的数据，这时候采用IO更合适
   - 使用哪种处理数据，需要在数据的响应等待时间和检查缓冲区数据的时间上作对比

3. IO multiplexing：多路复用IO

   - Linux世界一切皆是文件。文件描述符，简称FD，句柄FileDescriptor：文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统

   - IO多路复用概述：

     - IO多路复用是一种同步的IO模型，实现一个线程监视多个文件句柄，一旦某个文件句柄就绪就能够通知到对应应用程序进行相应的读写操作，没有文件句柄就绪时就会阻塞应用程序从而释放CPU资源

     - 使用到的概念：

       - l/O：网络I/O，尤其在操作系统层面指数据在内核态和用户态之间的读写操作
       - 多路：多个客户端连接（连接就是套接字描述符，即socket或者channel）
       - 复用：复用一个或几个线程
       - lO多路复用：也就是说一个或一组线程处理多个TCP连接，使用单进程就能够实现同时处理多个客户端的连接，无需创建或者维护过多的进程/线程。简而言之，一个服务端进程可以同时处理多个套接字描述符
       - 实现IO多路复用的模型有3种：可以分select --> poll --> epoll三个阶段来描述

     -  通过select、poll或epoll等机制，应用程序可以同时监视多个I/O事件，当其中任何一个事件就绪时才进行处理。这种模型避免了阻塞和循环轮询的缺点，提高了效率 

       ![](../../../TyporaImage/6d0118dae1784dfdbba03d6d22667781.png)

4. signal driven IO：信号驱动IO。应用程序告知内核去等待某个事件发生，并且可以同时进行其他操作。当事件发生时，内核发送信号通知应用程序进行处理。这种模型适用于处理少量的连接和事件 

5. asynchronous IO：异步IO。应用程序发起一个I/O操作后，可以继续执行其他操作，当I/O操作完成时会通知应用程序。这种模型减少了应用程序与内核的交互次数，提高了性能 

### 二、引出epoll

1. 场景分析：模拟一个tcp服务器处理30个客户socket。假设你是一个监考老师，让30个学生解答一道竞赛考题，然后负责验收学生答卷，你有下面几个选择：

   - 第一种选择：轮询。按顺序逐个验收，先验收A，然后是B，之后是C、D。。。这中间如果有一个学生卡住，全班都会被耽误，你用循环挨个处理socket，根本不具有并发能力
   - 第二种选择：来一个new一个，一对一服务。你创律30个分身线程，每个分身线程检查一个学生的答案是否正确。这种类似于为每一个用户创建一个进程或者线程处理连接
   - 第三种选择：响应式处理，一对多服务。你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。。。这种就是IO复用模型。 Linux下的select、poll和epoll就是干这个的

2. IO多路复用模型，简单明了版理解

   - 将用户socket对应的文件描述符（FileDescriptor）注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。此时的socket应该采用非阻塞模式。这样，整个过程只在调用select、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的reactor反应模式

     ![](../../../TyporaImage/9.IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png)

   - 在单个线程通过记录跟踪每一个Sockek（I/0流）的状态来同时管理多个I/0流。一个服务端进程可以同时处理多个套接字描述符，目的是尽量多的提高服务器的吞吐能力

   - IO多路复用原理，有请求就响应，没请求不打扰

3. IO多路复用小总结

   ![](../../../TyporaImage/10.%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5.png)

## 九、针对面试题：Redis快的原因

- Redis快的原因：IO多路复用+epoll函数使用，才是Redis这么快的直接原因，而不是仅仅单线程命令+Redis安装存储在内存中

## 十、Redis单线程 VS 多线程总结

1. Redis工作线程是单线程的，但是，整个Redis来说，是多线程的

2. 主线程和IO线程协作完成请求处理的步骤

   - I/O的读和写本身是堵塞的，比如当socket中有数据时，Redis会通过调用先将数据从内核态空间拷贝到用户态空间，再交给Redis调用，而这个拷贝的过程就是阻塞的，当数据量越大时拷贝所需要的时间就越多，而这些操作都是基于单线程完成的

     ![](../../../TyporaImage/11.%E8%80%97%E6%97%B6%E7%9A%84IO%E6%93%8D%E4%BD%9C.jpg)

   - 从Redis6开始，就新增了多线程的功能来提高I/O的读写性能，他的主要实现思路是将主线程的I/O读写任务拆分给一组独立的线程去执行，这样就可以使多个socket的读写可以并行化了。采用多路I/0复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），将最耗时的Socket的读取、请求解析、写入单独外包出去，剩下的命令执行仍然由主线程串行执行并和内存的数据交互

     ![](../../../TyporaImage/12.%E5%A4%9A%E4%B8%AAIO%E7%BA%BF%E7%A8%8B.jpg)

   - 结合上图可知，网络IO操作就变成多线程化了，其他核心部分仍然是线程安全的，是个不错的折中办法

3. 总的来说，Redis6/7将网络数据读写、Socket读取、请求协议解析通过多个IO线程的来处理，对于真正的Redis命令执行，仍然使用主线程单线程操作

   ![](../../../TyporaImage/13.%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.jpg)

## 十一、Redis7开启多线程

1. 如果在实际应用中，发现Redis实例的CPU开销不大但吞吐量却没有提升，可以考虑使用Redis7的多线程机制，加速网络处理，进而提升实例的吞吐量

   - Redis7将所有数据放在内存中，内存的响应时长大约为100纳秒，对于小数据包，Redis服务器可以处理8W到10W的QPS
   - 这也是Redis处理的极限了，对于80%的公司来说，单线程的Redis已经足够使用了

2. Redis7开启多线程配置

   ![](../../../TyporaImage/14.Redis7%E5%BC%80%E5%90%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B.jpg)

   ![](../../../TyporaImage/15.Redis7%E5%BC%80%E5%90%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B.jpg)

   - 设置io-thread-do-reads配置项为yes，表示启动多线程
   - 设置线程个数。关于线程数的设置，官方的建议是如果为4核的CPU，建议线程数设置为2或3，如果为8核CPU建议线程数设置为6，线程数一定要小于机器核数，线程数并不是越大越好

# 二、BigKey