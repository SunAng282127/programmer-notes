# 一、XML

## 一、XML概述

- XML是EXtensible Markup Language的缩写，翻译过来就是可扩展标记语言。所以很明显，XML和HTML一样都是标记语言，也就是说它们的基本语法都是标签
- **可扩展**三个字表面上的意思是XML允许自定义格式。但这不代表可以随便写
- 在XML基本语法规范的基础上，你使用的那些第三方应用程序、框架会通过XML约束的方式强制规定配置文件中可以写什么和怎么写
- XML基本语法这个知识点的定位是：我们不需要从零开始，从头到尾的一行一行编写XML文档，而是在第三方应用程序、框架已提供的配置文件的基础上修改。要改成什么样取决于你的需求，而怎么改取决XML基本语法和具体的XML约束

## 二、常见配置文件类型

1.  properties文件，例如druid连接池就是使用properties文件作为配置文件
2.  XML文件，例如Tomcat就是使用XML文件作为配置文件
3.  YAML文件，例如SpringBoot就是使用YAML作为配置文件
4.  json文件,，通常用来做文件传输，也可以用来做前端或者移动端的配置文件
5.  等等...

### 一、properties配置文件

- 由键值对组成

- 键和值之间的符号是等号

- 每一行都必须顶格写，前面不能有空格之类的其他符号

  ```properties
  sunny.jdbc.url=jdbc:mysql://localhost:3306/jdbc
  sunny.jdbc.driver=com.mysql.cj.jdbc.Driver
  sunny.jdbc.username=root
  sunny.jdbc.password=root
  ```

### 二、xml配置文件

1. 示例代码

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <students>
       <student>
           <name>张三</name>
           <age>18</age>
       </student>
       <student>
           <name>李四</name>
           <age>20</age>
       </student>
   </students>
   ```

2. XML的基本语法

   - XML的基本语法和HTML的基本语法简直如出一辙。其实这不是偶然的，XML基本语法+HTML约束=HTML语法。在逻辑上HTML确实是XML的子集

   - **XML文档声明**这部分基本上就是固定格式，要注意的是文档声明一定要从第一行第一列开始写

     ```xml
     <?xml version="1.0" encoding="UTF-8"?>
     ```

   - 根标签：根标签有且只能有一个。根标签的意思就是最外层的标签，可以随意定义，但是只能写一个

   - 标签关闭

     -   双标签：开始标签和结束标签必须成对出现。
     -   单标签：单标签在标签内关闭。

   - 标签嵌套：可以嵌套，但是不能交叉嵌套。

   - 注释不能嵌套

   - 标签名、属性名建议使用小写字母

   - 属性

     -   属性必须有值
     -   属性值必须加引号，单双都行

3. XML的约束

   - 将来我们主要就是根据XML约束中的规定来编写XML配置文件，而且会在我们编写XML的时候根据约束来提示我们编写, 而XML约束主要包括DTD和Schema两种

   - Schema约束要求我们一个XML文档中，所有标签，所有属性都必须在约束中有明确的定义，不能随便去定义

   - 以web.xml的约束声明为例来做个说明

     ```xml
     <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
              xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
              version="4.0">
     ```

## 三、DOM4J进行XML解析

### 一、DOM4J的使用步骤

1.  导入jar包dom4j.jar
2.  创建解析器对象(SAXReader)
3.  解析xml获得Document对象
4.  获取根节点RootElement
5.  获取根节点下的子节点

### 二、DOM4J的API介绍

- Node节点
  - Element：元素节点
  - Attribute：属性节点
  - Text：文本节点

1. 创建SAXReader对象

```java
SAXReader saxReader = new SAXReader();
```

&#x20;2. 解析XML获取Document对象: 需要传入要解析的XML文件的字节输入流

```java
// 通过类加载器获取指定字节码根路径下的指定文件的输入流
InputStream inputStream = 当前类.class.getClassLoader().getResourceAsStream("要读取Resource的xml文件路径");
Document document = reader.read(inputStream);
```

&#x20;3\. 获取文档的根标签

```java
Element rootElement = documen.getRootElement()
```

&#x20;4\. 获取标签的子标签

```java
//获取所有子标签
List<Element> sonElementList = rootElement.elements();
//获取指定标签名的子标签
List<Element> sonElementList = rootElement.elements("标签名");
```

&#x20;5\. 获取标签体内的文本

```java
String text = element.getText();
```

&#x20;6\. 获取标签的某个属性的值

```java
String value = element.attribute.getValue("属性名");
```

7. 示例代码

```xml
<?xml version="1.0" encoding="UTF-8"?>
<jdbc>
    <dev id="001">
        <username>root</username>
        <password>root</password>
        <driver>com.mysql.cj.jdbc.Driver</driver>
        <url>jdbc:mysql://127.0.0.1:3306/jdbc</url>
    </dev>
    <test id="002">
        <username>root</username>
        <password>root</password>
        <driver>com.mysql.cj.jdbc.Driver</driver>
        <url>jdbc:mysql://127.0.0.1:3306/jdbc</url>
    </test>
    <prod id="003">
        <username>root</username>
        <password>root</password>
        <driver>com.mysql.cj.jdbc.Driver</driver>
        <url>jdbc:mysql://127.0.0.1:3306/jdbc</url>
    </prod>
</jdbc>
```

```java
// 通过类加载器获取指定字节码根路径下的指定文件的输入流
InputStream inputStream = 当前类.class.getClassLoader().getResourceAsStream("要读取Resource的xml文件路径");
// 获取根元素
Document rootDocument = reader.read(inputStream);
// 获取元素下的子元素
List<Element> elements = rootDocument.elements();
for(Element element:elements){
    // element.getName()获取元素的名称
    sout("\t"+element.getName);
    // 从元素上获取属性（也可获取指定属性）
    // attribute.getName则为获取属性的名称，attribute.getValue则为获取属性的值
    Attribute attribute = element.attribute("id");
    // 继续获取子元素，这是最后一层
    List<Element> eles = element.elements();
    for(Element ele:eles){
        sout("\t\t"+ele.getName()+":"+ele.getText())
    }
}
```

# 二、Tomcat

## 一、Web服务器

1. Web服务器通常由硬件和软件共同构成

2. 硬件：电脑，提供服务供其它客户电脑访问

3. 软件：电脑上安装的服务器软件，安装后能提供服务给网络中的其他计算机，将本地文件映射成一个虚拟的url地址供网络中的其他人访问

   ![1681441674967](../../../TyporaImage/javaweb/1681441674967.png)

4. 常见的JavaWeb服务器

   - **Tomcat（Apache）**：当前应用最广的JavaWeb服务器
   - Jetty：更轻量级、更灵活的servlet容器
   - JBoss（Redhat红帽）：支持JavaEE，应用比较广EJB容器 –> SSH轻量级的框架代替
   - GlassFish（Orcale）：Oracle开发JavaWeb服务器，应用不是很广
   - Resin（Caucho）：支持JavaEE，应用越来越广
   - Weblogic（Orcale）：要钱的！支持JavaEE，适合大型项目
   - Websphere（IBM）：要钱的！支持JavaEE，适合大型项目

## 二、Tomcat服务器

### 一、Tomcat简介

- Tomcat是Apache软件基金会（Apache Software Foundation）的Jakarta项目中的一个核心项目，由Apache、Sun和其他一些公司及个人共同开发而成。最新的Servlet和JSP规范总是能在Tomcat中得到体现，因为Tomcat技术先进、性能稳定，而且免费，因而深受Java爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web应用服务器
- Tomcat是一款服务器软件，专门运行WEB的应用软件
- Tomcat是使用Java进行开发的，所以运行时需要使用JRE

### 二、Tomcat安装

1. [Tomcat官方网站](http://tomcat.apache.org/)下载。注意Java版本和Tomcat的版本，一般Java8下载Tomcat9就好了
   - 安装版：需要安装，一般不考虑使用
   - 解压版: 直接解压缩使用
2. 正确安装JDK并配置JAVA_HOME
3. 解压tomcat到非中文无空格目录
4. 点击bin/startup.bat启动
5. 打开浏览器输入 http://localhost:8080访问测试
6. 直接关闭窗口或者运行bin/shutdown.bat关闭tomcat
7. 处理dos窗口日志中文乱码问题: 修改conf/logging.properties，将控制台打印的UTF-8修改为GBK（大概在51行左右）。Linux系统不需要修改

### 三、Tomcat目录及测试

1. bin：该目录下存放的是二进制可执行文件，如果是安装版，那么这个目录下会有两个exe文件：tomcat10.exe、tomcat10w\.exe，前者是在控制台下启动Tomcat，后者是弹出GUI窗口启动Tomcat；如果是解压版，那么会有startup.bat和shutdown.bat文件，startup.bat用来启动Tomcat，但需要先配置JAVA\_HOME环境变量才能启动，shutdawn.bat用来停止Tomcat

2. conf：这是一个非常非常重要的目录，这个目录下有四个最为重要的文件：

   - **server.xml：配置整个服务器信息。例如修改端口号。默认HTTP请求的端口号是：8080**

   - tomcat-users.xml：存储tomcat用户的文件，这里保存的是tomcat的用户名及密码，以及用户的角色信息。可以按着该文件中的注释信息添加tomcat用户，然后就可以在Tomcat主页中进入Tomcat Manager页面了

     ``` html
     <tomcat-users xmlns="http://tomcat.apache.org/xml"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xsi:schemaLocation="http://tomcat.apache.org/xml tomcat-users.xsd"
                   version="1.0">	
     	<role rolename="admin-gui"/>
     	<role rolename="admin-script"/>
     	<role rolename="manager-gui"/>
     	<role rolename="manager-script"/>
     	<role rolename="manager-jmx"/>
     	<role rolename="manager-status"/>
     	<user 	username="admin" 
     			password="admin" 
     			roles="admin-gui,admin-script,manager-gui,manager-script,manager-jmx,manager-status"
     	/>
     </tomcat-users>
     ```

   - web.xml：部署描述符文件，这个文件中注册了很多MIME类型，即文档类型。这些MIME类型是客户端与服务器之间说明文档类型的，如用户请求一个html网页，那么服务器还会告诉客户端浏览器响应的文档是text/html类型的，这就是一个MIME类型。客户端浏览器通过这个MIME类型就知道如何处理它了。当然是在浏览器中显示这个html文件了。但如果服务器响应的是一个exe文件，那么浏览器就不可能显示它，而是应该弹出下载窗口才对。MIME就是用来说明文档的内容是什么类型的

   - context.xml：对所有应用的统一配置，通常我们不会去配置它

3. lib：Tomcat的类库，里面是一大堆jar文件。如果需要添加Tomcat依赖的jar文件，可以把它放到这个目录中，当然也可以把应用依赖的jar文件放到这个目录中，这个目录中的jar所有项目都可以共享之，但这样你的应用放到其他Tomcat下时就不能再共享这个目录下的jar包了，所以建议只把Tomcat需要的jar包放到这个目录下；

4. logs：这个目录中都是日志文件，记录了Tomcat启动和关闭的信息，如果启动Tomcat时有错误，那么异常也会记录在日志文件中。

5. temp：存放Tomcat的临时文件，这个目录下的东西可以在停止Tomcat后删除

6. **webapps：存放web项目的目录，其中每个文件夹都是一个项目**；如果这个目录下已经存在了目录，那么都是tomcat自带的项目。其中ROOT是一个特殊的项目，在地址栏中访问：http://127.0.0.1:8080，没有给出项目目录时，对应的就是ROOT项目.http://localhost:8080/examples，进入示例项目。其中examples"就是项目名，即文件夹的名字。

7. work：运行时生成的文件，最终运行的文件都在这里。通过webapps中的项目生成的！可以把这个目录下的内容删除，再次运行时会生再次生成work目录。当客户端用户访问一个JSP文件时，Tomcat会通过JSP生成Java文件，然后再编译Java文件生成class文件，生成的java和class文件都会存放到这个目录下

8. LICENSE：许可证

9. NOTICE：说明文件

### 四、WEB项目的标准结构

1. 一个标准的可以用于发布的WEB项目标准结构如下

   ![1681453620343](../../../TyporaImage/1681453620343.png)

2. 项目结构说明

   - app  本应用根目录
     + static：非必要目录，约定俗成的名字，一般在此处放静态资源 (css、js、img)
     + WEB-INF：必要目录，必须叫WEB-INF，受保护的资源目录，浏览器通过url不可以直接访问的目录
       + classes：必要目录，src下源代码，配置文件，编译后会在该目录下，web项目中如果没有源码，则该目录不会出现
       + lib：必要目录，项目依赖的jar编译后会出现在该目录下，web项目要是没有依赖任何jar，则该目录不会出现
       + web.xml：必要文件，web项目的基本配置文件，较新的版本中可以没有该文件，但是学习过程中还是需要该文件 
     + index.html：非必要文件，index.html/index.htm/index.jsp为默认的欢迎页

3. url的组成部分和项目中资源的对应关系

   ![1681456161723](../../../TyporaImage/javaweb/1681456161723.png)

### 五、WEB项目部署的方式

1.  直接将编译好的项目放在webapps目录下  (如上)

2. 将编译好的项目打成war包放在webapps目录下，tomcat启动后会自动解压war包(其实和第一种一样)

3. 可以将项目放在非webapps的其他目录下,在tomcat中通过配置文件指向app的实际磁盘路径

   - 在磁盘的自定义目录上准备一个app

   - ![1681456447284](../../../TyporaImage/1681456447284.png)

   - 在tomcat的conf下创建Catalina/localhost目录，并在该目录下准备一个app.xml文件

     ```xml
     <!-- 
     	path: 项目的访问路径,也是项目的上下文路径,就是在浏览器中,输入的项目名称
         docBase: 项目在磁盘中的实际路径
      -->
     <Context path="/app" docBase="D:\mywebapps\app" />
     ```

   - 启动tomcat访问测试即可

### 六、IDEA运行WEB项目

1. IDEA关联本地Tomcat

   - 可以在创建项目前设置本地tomcat，也可以在打开某个项目的状态下找到settings

     <img src="../../../TyporaImage/javaweb/1681457611053.png" alt="1681457611053" style="zoom: 80%;" />

   - 找到 Build,Execution,Eeployment下的Application Servers，找到+号

     <img src="../../../TyporaImage/javaweb/1681457711914.png" alt="1681457711914"  />

   - 选择Tomcat Server

     <img src="../../../TyporaImage/javaweb/1681457800708.png" alt="1681457800708"  />

   - 选择tomcat的安装目录

     <img src="../../../TyporaImage/javaweb/1681457879937.png" alt="1681457879937" style="zoom:50%;" />

   - 点击OK

     <img src="../../../TyporaImage/javaweb/1681457921094.png" alt="1681457921094"  />

   - 关联完毕

     <img src="../../../TyporaImage/javaweb/1681458031957.png" alt="1681458031957" style="zoom:65%;" />

2. IDEA创建web工程

   - 推荐先创建一个空项目,这样可以在一个空项目下同时存在多个modules，不用后续来回切换之前的项目，当然也可以忽略此步直接创建web项目

     <img src="../../../../../../Program%2520Files/TyporaData/JAVA_WEB/images/1681458194939.png" alt="1681458194939" style="zoom: 60%;" />

     <img src="../../../../../../Program%2520Files/TyporaData/JAVA_WEB/images/1681458273381.png" alt="1681458273381" style="zoom: 60%;" />

   - 检查项目的SDK,语法版本,以及项目编译后的输出目录

     <img src="../../../../../../Program%2520Files/TyporaData/JAVA_WEB/images/1681458343921.png" alt="1681458343921" style="zoom:50%;" />

     <img src="../../../../../../Program%2520Files/TyporaData/JAVA_WEB/images/1681458393871.png" alt="1681458393871" style="zoom: 55%;" />

   - 先创建一个普通的JAVA项目

     <img src="../../../TyporaImage/javaweb/1681458485837.png" alt="1681458485837" style="zoom:63%;" />

   - 检查各项信息是否填写有误

     <img src="../../../TyporaImage/javaweb/1681458599545.png" alt="1681458599545" style="zoom:60%;" />

   - 创建完毕后，为项目添加Tomcat依赖

     <img src="../../../../../../Program%2520Files/TyporaData/JAVA_WEB/images/1681458857830.png" alt="1681458857830" style="zoom: 67%;" />

     

     <img src="../../../../../../Program%2520Files/TyporaData/JAVA_WEB/images/1681458897017.png" alt="1681458897017" style="zoom: 95%;" />

     <img src="../../../../../../Program%2520Files/TyporaData/JAVA_WEB/images/1681458939400.png" alt="1681458939400" style="zoom:70%;" />

   - 选择modules，添加framework support

     <img src="../../../TyporaImage/javaweb/1681458672258.png" alt="1681458672258" style="zoom: 80%;" />

   - 选择Web Application注意Version，勾选Create web.xml

     <img src="../../../TyporaImage/javaweb/1681459007273.png" alt="1681459007273" style="zoom:80%;" />

   - 删除index.jsp，替换为index.html

     ![1681459080873](../../../TyporaImage/1681459080873.png)

     <img src="../../../TyporaImage/javaweb/1681459147133.png" alt="1681459147133" style="zoom: 67%;" />

   - 处理配置文件

     - 在工程下创建resources目录,专门用于存放配置文件(都放在src下也行,单独存放可以尽量避免文件集中存放造成的混乱)

     - 标记目录为资源目录，不标记的话则该目录不参与编译

       <img src="../../../TyporaImage/javaweb/1681461443278.png" alt="1681461443278" style="zoom:67%;" />

     - 标记完成后,显示效果如下

       <img src="../../../TyporaImage/javaweb/1681461513406.png" alt="1681461513406"  />

   - 处理依赖jar包问题

     - 在WEB-INF下创建lib目录

     - 必须在WEB-INF下，且目录名必须叫lib！！！

     - 复制jar文件进入lib目录

       ![1681461788411](../../../TyporaImage/1681461788411.png)

     - 将lib目录添加为当前项目的依赖，后续可以用maven统一解决

       <img src="../../../TyporaImage/javaweb/1681461846178.png" alt="1681461846178" style="zoom:67%;" />

       ![1681461881121](../../../TyporaImage/1681461881121.png)

     - 环境级别推荐选择module级别，降低对其他项目的影响，name可以空着不写

       ![1681461923761](../../../TyporaImage/1681461923761.png)

     - 查看当前项目有那些环境依赖

       ![1681463867295](../../../TyporaImage/1681463867295.png)

       <img src="../../../TyporaImage/javaweb/1681462179671.png" alt="1681462179671" style="zoom:50%;" />

     - 在此位置，可以通过-号解除依赖

       <img src="../../../TyporaImage/javaweb/1681462247973.png" alt="1681462247973" style="zoom:85%;" />

3. IDEA部署-运行web项目

   - 检查idea是否识别modules为web项目并存在将项目构建成发布结构的配置

     - 就是检查工程目录下，web目录有没有特殊的识别标记

       ![1681462523901](../../../TyporaImage/1681462523901.png)

     - 以及artifacts下，有没有对应 _war_exploded，如果没有，就点击+号添加

       <img src="../../../TyporaImage/javaweb/1681462584524.png" alt="1681462584524" style="zoom: 50%;" />

   - 点击向下箭头，出现 Edit Configurations选项

     <img src="../../../TyporaImage/javaweb/1681462645070.png" alt="1681462645070" style="zoom:100%;" />

   - 出现运行配置界面

     <img src="../../../TyporaImage/javaweb/1681462710108.png" alt="1681462710108" style="zoom: 67%;" />

   - 点击+号，添加本地tomcat服务器

     <img src="../../../TyporaImage/javaweb/1681462754191.png" alt="1681462754191" style="zoom:67%;" />

   - 因为IDEA关联了一个Tomcat，红色部分就只有一个Tomcat可选

     <img src="../../../TyporaImage/javaweb/1681462798933.png" alt="1681462798933" style="zoom: 65%;" />

   - 选择Deployment，通过+添加要部署到Tomcat中的artifact

     <img src="../../../TyporaImage/javaweb/1681463011546.png" alt="1681463011546" style="zoom:65%;" />

   - applicationContext中是默认的项目上下文路径，也就是url中需要输入的路径，这里可以自己定义，可以和工程名称不一样，也可以不写，但是要保留/，这里暂时可以就用默认的

     <img src="../../../TyporaImage/javaweb/1681463049807.png" alt="1681463049807" style="zoom:80%;" />

   - 点击apply应用后，回到Server部分。After Launch是配置启动成功后，是否默认自动打开浏览器并输入URL中的地址，HTTP port是Http连接器目前占用的端口号

     <img src="../../../TyporaImage/javaweb/1681463212587.png" alt="1681463212587" style="zoom:80%;" />

   - 点击OK后，启动项目，访问测试。浏览器自动打开并自动访问了index.html欢迎页

   - 工程结构和可以发布的项目结构之间的目录对应关系

     ![1681464081226](../../../TyporaImage/1681464081226.png)

   - IDEA部署并运行项目的原理

     - idea并没有直接进将编译好的项目放入tomcat的webapps中
     - idea根据关联的tomcat，创建了一个tomcat副本，将项目部署到了这个副本中
     - idea的tomcat副本在C:\用户\当前用户\AppData\Local\JetBrains\IntelliJIdea2022.2\tomcat\中
     - idea的tomcat副本并不是一个完整的tomcat，副本里只是准备了和当前项目相关的配置文件而已
     - idea启动tomcat时，是让本地tomcat程序按照tomcat副本里的配置文件运行
     - idea的tomcat副本部署项目的模式是通过conf/Catalina/localhost/*.xml配置文件的形式实现项目部署的

     ![1681521240438](../../../TyporaImage/1681521240438.png)

# 三、HTTP

## 一、HTTP简介

<img src="../../../TyporaImage/javaweb/1681522600239.png" alt="1681522600239" style="zoom:67%;" />

- **HTTP 超文本传输协议** (HTTP-Hyper Text transfer protocol)，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过十几年的使用与发展，得到不断地完善和扩展。**它是一种详细规定了浏览器和万维网服务器之间互相通信的规则**，通过因特网传送万维网文档的数据传送协议。客户端与服务端通信时传输的内容我们称之为**报文**。**HTTP协议就是规定报文的格式。**HTTP就是一个通信规则，这个规则规定了客户端发送给服务器的报文格式，也规定了服务器发送给客户端的报文格式。实际我们要学习的就是这两种报文**。客户端发送给服务器的称为"请求报文**"，**服务器发送给客户端的称为"响应报文"**

### 一、HTTP协议的会话方式

- 浏览器与服务器之间的通信过程要经历四个步骤

  ![](../../../TyporaImage/1557672342250_1H8nt17MNz.png)

- 浏览器与WEB服务器的连接过程是短暂的，每次连接只处理一个请求和响应。对每一个页面的访问，浏览器与WEB服务器都要建立一次单独的连接

- 浏览器到WEB服务器之间的所有通讯都是完全独立分开的请求和响应对

### 二、HTTP1.0和HTTP1.1的区别

- 在HTTP1.0版本中，浏览器请求一个带有图片的网页，会由于下载图片而与服务器之间开启一个新的连接

- 在HTTP1.1版本中，允许浏览器在拿到当前请求对应的全部资源后再断开连接，提高了效率

  ![](../../../TyporaImage/1557672415271_EgyN-GdbWY.png)

### 三、在浏览器中通过F12工具抓取请求响应报文包

<img src="../../../TyporaImage/javaweb/1681522138051.png" alt="1681522138051" style="zoom:80%;" />

## 二、请求和响应报文

### 一、报文的格式

1. 主体上分为报文首部和报文主体，中间空行隔开

   <img src="../../../TyporaImage/javaweb/1681522962846.png" alt="1681522962846" style="zoom: 62%;" />

2. 报文部首可以继续细分为"行"和"头"

   ![1681522998417](../../../TyporaImage/1681522998417.png)

### 二、请求报文

1. 客户端发给服务端的报文

   - 请求报文格式
     -   请求首行（**请求行**）；GET/POST   资源路径?参数   HTTP/1.1
     -   请求头信息（**请求头**）
     -   空行
     -   请求体；POST请求才有请求体

2. 浏览器f12网络下查看请求数据包

   ![1681524200024](../../../TyporaImage/1681524200024.png)

3. form表单发送GET请求特点

   - 由于请求参数在请求首行中已经携带了，所以没有请求体，也没有请求空行
   - 请求参数拼接在url地址中，地址栏可见\[url?name1=value1\&name2=value2]，不安全
   - 由于参数在地址栏中携带，所以有大小限制\[地址栏数据大小一般限制为4k]，只能携带纯文本
   - get请求参数只能上传文本数据
   - 没有请求体。所以封装和解析都快，效率高， 浏览器默认提交的请求都是get请求比如：地址栏输入回车、超链接、表单默认的提交方式

4. 查看GET请求行、请求头、请求体

   - 请求行组成部分

     + 请求方式GET
     + 访问服务器的资源路径?参数1=值1&参数2=值2 ... ...
     + 协议及版本HTTP/1.1

     ```http
     GET /05_web_tomcat/login_success.html?username=admin&password=123213 HTTP/1.1
     ```

   - 请求头

     ```http
     -主机虚拟地址
     Host: localhost:8080   
     -长连接
     Connection: keep-alive 
     -请求协议的自动升级[http的请求，服务器却是https的，浏览器自动会将请求协议升级为https的]
     Upgrade-Insecure-Requests: 1  
     - 用户系统信息
     User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.75 Safari/537.36
     - 浏览器支持的文件类型
     Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
     - 当前页面的上一个页面的路径[当前页面通过哪个页面跳转过来的]：   可以通过此路径跳转回上一个页面， 广告计费，防止盗链
     Referer: http://localhost:8080/05_web_tomcat/login.html
     - 浏览器支持的压缩格式
     Accept-Encoding: gzip, deflate, br
     - 浏览器支持的语言
     Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7
     ```

   - 请求空行

   - 请求体。GET请求数据不放在请求体

5. form表单发送post请求特点

   - post请求有请求体，而GET请求没有请求体
   - post请求数据在请求体中携带，请求体数据大小没有限制，可以用来上传所有内容\[文件、文本]
   - 只能使用post请求上传文件
   - post请求报文多了和请求体相关的配置\[请求头]
   - 地址栏参数不可见，相对安全
   - post效率比get低

6. post请求要求将form标签的method的属性设置为post

   ![1681525012046](../../../TyporaImage/1681525012046.png)

7. 查看post的请求行、请求头、请求体

   - 请求行组成部分

     + 请求方式POST
     + 访问服务器的资源路径?参数1=值1&参数2=值2 ... ...
     + 协议及版本HTTP/1.1

   - 请求头

     ```http
     Host: localhost:8080
     Connection: keep-alive
     Content-Length: 31     -请求体内容的长度
     Cache-Control: max-age=0  -无缓存
     Origin: http://localhost:8080
     Upgrade-Insecure-Requests: 1  -协议的自动升级
     Content-Type: application/x-www-form-urlencoded   -请求体内容类型[服务器根据类型解析请求体参数]
     User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.75 Safari/537.36
     Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
     Referer: http://localhost:8080/05_web_tomcat/login.html
     Accept-Encoding: gzip, deflate, br
     Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7
     Cookie:JSESSIONID-
     ```

   - 请求空行

   - 请求体:浏览器提交给服务器的数据

     ```http
     username=admin&password=1232131
     ```

### 三、响应报文

1. 响应报文格式

   - 响应首行（**响应行**）； 协议/版本 状态码 状态码描述

     + 协议及版本 HTTP/1.1
     + 响应状态码 200
     + 状态描述   OK  (缺省)

     ```http
     HTTP/1.1 200 OK
     说明：响应协议为HTTP1.1，响应状态码为200，表示请求成功
     ```

   - 响应头信息（**响应头**）

     ```http
     Server: Apache-Coyote/1.1   服务器的版本信息
     Accept-Ranges: bytes
     ETag: W/"157-1534126125811"
     Last-Modified: Mon, 13 Aug 2018 02:08:45 GMT
     Content-Type: text/html    响应体数据的类型[浏览器根据类型解析响应体数据]
     Content-Length: 157   响应体内容的字节数
     Date: Mon, 13 Aug 2018 02:47:57 GMT  响应的时间，这可能会有8小时的时区差
     ```

   - 空行

   - 响应体

     ```http
     <!--需要浏览器解析使用的内容[如果响应的是html页面，最终响应体内容会被浏览器显示到页面中]-->
     
     <!DOCTYPE html>
     <html>
       <head>
         <meta charset="UTF-8">
         <title>Insert title here</title>
       </head>
       <body>
         恭喜你，登录成功了...
       </body>
     </html>
     ```

     ![1681525347456](../../../TyporaImage/1681525347456.png)

     ![1681525384347](../../../TyporaImage/1681525384347.png)

2. 响应状态码：响应码对浏览器来说很重要，它告诉浏览器响应的结果。比较有代表性的响应码如下

   - **200：** 请求成功，浏览器会把响应体内容（通常是html）显示在浏览器中
   - **302：** 重定向，当响应码为302时，表示服务器要求浏览器重新再发一个请求，服务器会发送一个响应头Location指定新请求的URL地址
   - **304：** 使用了本地缓存
   - **404：** 请求的资源没有找到，说明客户端错误的请求了不存在的资源
   - **405：** 请求的方式不允许
   - **500：** 请求资源找到了，但服务器内部出现了错误

3. 更多的响应状态码

   - 100：继续。客户端应继续其请求
   - 101：切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议
   - 200：请求成功。一般用于GET与POST请求
   - 201：已创建。成功请求并创建了新的资源
   - 202：已接受。已经接受请求，但未处理完成
   - 203：非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本
   - 204：无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档
   - 205：重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域
   - 206：部分内容。服务器成功处理了部分GET请求
   - 300：多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择
   - 301：永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
   - 302：临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI
   - 303：查看其它地址。与301类似。使用GET和POST请求查看
   - 304：未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源
   - 305：使用代理。所请求的资源必须通过代理访问
   - 306：已经被废弃的HTTP状态码
   - 307：临时重定向。与302类似。使用GET请求重定向
   - 400：客户端请求的语法错误，服务器无法理解
   - 401：请求要求用户的身份认证
   - 402：保留，将来使用  
   - 403：服务器理解请求客户端的请求，但是拒绝执行此请求
   - 404：服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面  
   - 405：客户端请求中的方法被禁止
   - 406：服务器无法根据客户端请求的内容特性完成请求
   - 407：请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权
   - 408：服务器等待客户端发送的请求时间过长，超时  
   - 409：服务器完成客户端的PUT请求时可能返回此代码，服务器处理请求时发生了冲突  
   - 410：客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置
   - 411：服务器无法处理客户端发送的不带Content-Length的请求信息
   - 412：客户端请求信息的先决条件错误
   - 413：由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息  
   - 414：请求的URI过长（URI通常为网址），服务器无法处理
   - 415：服务器无法处理请求附带的媒体格式  
   - 416：客户端请求的范围无效  
   - 417：服务器无法满足Expect的请求头信息
   - 500：服务器内部错误，无法完成请求  
   - 501：服务器不支持请求的功能，无法完成请求  
   - 502：作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应
   - 503：由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中
   - 504：充当网关或代理的服务器，未及时从远端服务器获取请求  
   - 505：服务器不支持请求的HTTP协议的版本，无法完成处理

# 四、Servlet

## 一、Servlet简介

### 一、动态资源和静态资源

1. 静态资源
   - 无需在程序运行时通过代码运行生成的资源,在程序运行之前就写好的资源. 例如：html css js img ,音频文件和视频文件
2. 动态资源
   - 需要在程序运行时通过代码运行生成的资源,在程序运行之前无法确定的数据,运行时动态生成,例如Servlet、Thymeleaf ... ...
   - 动态资源指的不是视图上的动画效果或者是简单的人机交互效果

### 二、Servlet简介

1. Servlet  (server applet) 是运行在服务端(tomcat)的Java小程序，是sun公司提供一套定义动态资源规范；从代码层面上来讲Servlet就是一个接口

2. 用来接收、处理客户端请求、响应给浏览器的动态资源。在整个Web应用中，Servlet主要负责接收处理请求、协同调度功能以及响应数据。我们可以把Servlet称为Web应用中的**控制器**

3. 不是所有的JAVA类都能用于处理客户端请求，能处理客户端请求并做出响应的一套技术标准就是Servlet

4. Servlet是运行在服务端的,所以 Servlet必须在WEB项目中开发且在Tomcat这样的服务容器中运行

5. 请求响应与HttpServletRequest和HttpServletResponse之间的对应关系

   ![1681699577344](../../../TyporaImage/1681699577344.png)

## 二、Servlet开发流程

### 一、目标

- 校验注册时，用户名是否被占用。通过客户端向一个Servlet发送请求，携带username，如果用户名是'sunny'，则向客户端响应NO，如果是其他，响应YES

### 二、开发过程

1. 开发一个web类型的module，参照之前的

2. 开发一个UserServlet

   ```java
   public class UserServlet  extends HttpServlet {
       @Override
       protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
           // 获取请求中的参数
           String username = req.getParameter("username");
           if("SUNNY".equals(username)){
               //通过响应对象响应信息
               resp.getWriter().write("NO");
           }else{
               resp.getWriter().write("YES");
           }
       }
   }
   ```

   - 自定义一个类，要继承HttpServlet类
   - 重写service方法，该方法主要就是用于处理用户请求的服务方法
   - HttpServletRequest代表请求对象，是有请求报文经过tomcat转换而来的，通过该对象可以获取请求中的信息
   - HttpServletResponse代表响应对象，该对象会被tomcat转换为响应的报文，通过该对象可以设置响应中的信息
   - Servlet对象的生命周期(创建、初始化、处理服务、销毁)是由tomcat管理的，无需我们自己new
   - HttpServletRequest、HttpServletResponse两个对象也是有tomcat负责转换，在调用service方法时传入给我们用的

3. 在web.xml为UseServlet配置请求的映射路径

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <web-app xmlns="https://jakarta.ee/xml/ns/jakartaee"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd"
            version="5.0">
   
       <servlet>
           <!--给UserServlet起一个别名-->
           <servlet-name>userServlet</servlet-name>
           <servlet-class>com.sunny.servlet.UserServlet</servlet-class>
       </servlet>
   
   
       <servlet-mapping>
           <!--关联别名和映射路径-->
           <servlet-name>userServlet</servlet-name>
           <!--可以为一个Servlet匹配多个不同的映射路径,但是不同的Servlet不能使用相同的url-pattern-->
           <url-pattern>/userServlet</url-pattern>
          <!-- <url-pattern>/userServlet2</url-pattern>-->
           <!--
               /        表示通配所有资源,不包括jsp文件
               /*       表示通配所有资源,包括jsp文件
               /a/*     匹配所有以a前缀的映射路径
               *.action 匹配所有以action为后缀的映射路径
           -->
          <!-- <url-pattern>/*</url-pattern>-->
       </servlet-mapping>
   
   </web-app>
   ```

   - Servlet并不是文件系统中实际存在的文件或者目录，所以为了能够请求到该资源,我们需要为其配置映射路径
   - servlet的请求映射路径配置在web.xml中
   - servlet-name作为servlet的别名，可以自己随意定义，见名知意就好
   - url-pattern标签用于定义Servlet的请求映射路径
   - 一个servlet可以对应多个不同的url-pattern
   - 多个servlet不能使用相同的url-pattern
   - url-pattern中可以使用一些通配写法
     + /        表示通配所有资源,不包括jsp文件
     + /*      表示通配所有资源,包括jsp文件
     + /a/*     匹配所有以a前缀的映射路径
     + *.action 匹配所有以action为后缀的映射路径

4. 开发一个form表单，向servlet发送一个get请求并携带username参数

   ```html
   <!DOCTYPE html>
   <html lang="en">
   <head>
       <meta charset="UTF-8">
       <title>Title</title>
   </head>
   <body>
       <form action="userServlet">
           请输入用户名:<input type="text" name="username" /> <br>
           <input type="submit" value="校验">
       </form>
   </body>
   </html>
   ```

5. 启动项目，访问index.html，提交表单测试

6. 映射关系图

   ![1681550398774](../../../TyporaImage/javaweb/1681550398774.png)

## 三、Servlet注解方式配置

1. #### @WebServlet注解源码

   ```java
   
   
   package jakarta.servlet.annotation;
   
   import java.lang.annotation.Documented;
   import java.lang.annotation.ElementType;
   import java.lang.annotation.Retention;
   import java.lang.annotation.RetentionPolicy;
   import java.lang.annotation.Target;
   
   /**
    * @since Servlet 3.0
    */
   @Target({ ElementType.TYPE })
   @Retention(RetentionPolicy.RUNTIME)
   @Documented
   public @interface WebServlet {
   
       /**
        * The name of the servlet
        * 相当于 servlet-name
        * @return the name of the servlet
        */
       String name() default "";
   
       /**
        * The URL patterns of the servlet
        * 如果只配置一个url-pattern ,则通过该属性即可,和urlPatterns属性互斥
        * @return the URL patterns of the servlet
        */
       String[] value() default {};
   
       /**
        * The URL patterns of the servlet
        * 如果要配置多个url-pattern ,需要通过该属性,和value属性互斥
        * @return the URL patterns of the servlet
        */
       String[] urlPatterns() default {};
   
       /**
        * The load-on-startup order of the servlet
        * 配置Servlet是否在项目加载时实例化
        * @return the load-on-startup order of the servlet
        */
       int loadOnStartup() default -1;
   
       /**
        * The init parameters of the servlet
        * 配置初始化参数
        * @return the init parameters of the servlet
        */
       WebInitParam[] initParams() default {};
   
       /**
        * Declares whether the servlet supports asynchronous operation mode.
        *
        * @return {@code true} if the servlet supports asynchronous operation mode
        * @see jakarta.servlet.ServletRequest#startAsync
        * @see jakarta.servlet.ServletRequest#startAsync( jakarta.servlet.ServletRequest,jakarta.servlet.ServletResponse)
        */
       boolean asyncSupported() default false;
   
       /**
        * The small-icon of the servlet
        *
        * @return the small-icon of the servlet
        */
       String smallIcon() default "";
   
       /**
        * The large-icon of the servlet
        *
        * @return the large-icon of the servlet
        */
       String largeIcon() default "";
   
       /**
        * The description of the servlet
        *
        * @return the description of the servlet
        */
       String description() default "";
   
       /**
        * The display name of the servlet
        *
        * @return the display name of the servlet
        */
       String displayName() default "";
   
   }
   
   ```

2. @WebServlet注解使用

   - 使用@WebServlet注解替换Servlet配置

     ```java
     @WebServlet(
             name = "userServlet",
             //value = "/user",
             urlPatterns = {"/userServlet1","/userServlet2","/userServlet"},
             initParams = {@WebInitParam(name = "encoding",value = "UTF-8")},
             loadOnStartup = 6
     )
     public class UserServlet  extends HttpServlet {
         @Override
         protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
             String encoding = getServletConfig().getInitParameter("encoding");
             System.out.println(encoding);
             // 获取请求中的参数
             String username = req.getParameter("username");
             if("sunny".equals(username)){
                 //通过响应对象响应信息
                 resp.getWriter().write("NO");
             }else{
                 resp.getWriter().write("YES");
             }
         }
     }
     ```

## 四、Servlet生命周期

### 一、生命周期简介

1. Servlet的生命周期介绍

   - 应用程序中的对象不仅在空间上有层次结构的关系，在时间上也会因为处于程序运行过程中的不同阶段而表现出不同状态和不同行为——这就是对象的生命周期。
   - 简单的叙述生命周期，就是对象在容器中从开始创建到销毁的过程

2. Servlet容器

   - Servlet对象是Servlet容器创建的，生命周期方法都是由容器(目前我们使用的是Tomcat)调用的。这一点和我们之前所编写的代码有很大不同。在今后的学习中我们会看到，越来越多的对象交给容器或框架来创建，越来越多的方法由容器或框架来调用，开发人员要尽可能多的将精力放在业务逻辑的实现上

3. Servlet主要的生命周期执行特点

   | 生命周期 |                         对应方法                         |        执行时机        | 执行次数 |
   | :------: | :------------------------------------------------------: | :--------------------: | :------: |
   | 构造对象 |                          构造器                          | 第一次请求或者容器启动 |    1     |
   |  初始化  |                          init()                          |       构造完毕后       |    1     |
   | 处理服务 | service(HttpServletRequest req,HttpServletResponse resp) |        每次请求        |   多次   |
   |   销毁   |                        destory()                         |        容器关闭        |    1     |

### 二、生命周期测试

1. 开发servlet代码

   ```java
   package com.atguigu.servlet;
   import jakarta.servlet.ServletException;
   import jakarta.servlet.http.HttpServlet;
   import jakarta.servlet.http.HttpServletRequest;
   import jakarta.servlet.http.HttpServletResponse;
   
   import java.io.IOException;
   
   public class ServletLifeCycle  extends HttpServlet {
       public ServletLifeCycle(){
           System.out.println("构造器");
       }
   
       @Override
       public void init() throws ServletException {
           System.out.println("初始化方法");
       }
   
       @Override
       protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
           System.out.println("service方法");
       }
   
       @Override
       public void destroy() {
           System.out.println("销毁方法");
       }
   }
   
   ```

2. 配置Servlet

   ```xml
     
       <servlet>
           <servlet-name>servletLifeCycle</servlet-name>
           <servlet-class>com.atguigu.servlet.ServletLifeCycle</servlet-class>
           <!--load-on-startup
               如果配置的是正整数则表示容器在启动时就要实例化Servlet,
               数字表示的是实例化的顺序
           -->
           <load-on-startup>1</load-on-startup>
       </servlet>
       <servlet-mapping>
           <servlet-name>servletLifeCycle</servlet-name>
           <url-pattern>/servletLiftCycle</url-pattern>
       </servlet-mapping>
   ```

3. 请求Servlet测试

### 三、生命周期总结

1. Servlet对象在容器中是单例的
2. 容器是可以处理并发的用户请求的，每个请求在容器中都会开启一个线程
3. 多个线程可能会使用相同的Servlet对象，所以在Servlet中，我们不要轻易定义一些容易经常发生修改的成员变量
4. load-on-startup中定义的正整数表示实例化顺序，如果数字重复了，容器会自行解决实例化顺序问题，但是应该避免重复
5. Tomcat容器中，已经定义了一些随系统启动实例化的servlet，我们自定义的servlet的load-on-startup尽量不要占用数字1-5

## 五、Servlet继承结构

# 五、会话

# 六、过滤器

# 七、监听器