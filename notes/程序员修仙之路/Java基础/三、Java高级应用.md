# 一、面向对象的概述

### 一、学习面向对象内容的三条主线

- Java类及类的成员：属性、方法、构造器、代码块、内部类
- 面向对象的特征：封装、继承、多态、（抽象）
- 其他关键字的使用：this、super、package、import、static、final、interface、abstract等

### 二、面向过程VS面向对象

- 面向过程是以函数为组织单位，是一种执行者思维，适合解决简单问题。扩展能力差、后期维护难度较大
- 面向对象以类为组织单位，每种事物都具备自己的属性和行为/功能，是一种设计者思维。适合解决复杂问题。代码扩展性强、可维护性高
- 二者关系：二者相辅相成，面向对象离不开面向过程

### 三、类和对象概述

- 类和对象使面向对象的核心概念
- 类：具有相同特征的事物的抽象描述，是抽象的，概念上的定义
- 对象：实际存在的该类事物的每个个体，是具体的，因而也成为实例

# 二、类的实例化与内存解析

### 一、类的内部成员

- 属性：也就是成员变量、field（字段、域）
- 方法：（成员）方法、函数、Method

### 二、面向对象完成具体功能操作的三步

- 创建类，并设计类的内部成员（属性、方法）
- 创建类的对象。
- 通过对象，调用其内部声明的属性或方法，完成相关的功能

### 三、类的实例化

- 等价描述：类的实例化 <=> 创建类的对象<=>创建类的实例

- 格式：类类型 对象名 = 通过new创建的对象实体

	```java
	// 创建Phone的对象
	Phone p1 = new Phone();
	// 通过Phone的对象，调用其内部声明的属性或方法
	// 格式为 对象.属性 或 对象.方法
	p1.name = "huwei";
	pi.call();
	```

### 四、对象的内存解析

##### 一、对象在内存中的分配涉及到的内存结构

- 栈（stack）：方法内定义的变量（局部变量），存储在栈中。还存放方法的栈针
- 堆（heap）：new出来的结构（数组的实体、对象的实体），包括对象中的属性（成员变量）
- 方法区（method area）：存放类的模板

##### 二、类中对象的内存解析

- 在通过new创建的多个对象，对象实例存放在栈中，每个对象在堆空间中有一个对象实体，堆中对象实体的地址值赋值给栈中的对象实例
- 在堆中的每一个对象实体保存着一份类的属性，属性是引用类型的，则在堆中保存的是引用类型的地址或者null
- 如果修改某一个对象的某属性值时，不会影响其他对象此属性的值
- 如果栈中两个对象实例指向堆空间中同一个对象实体（地址值相同）。如果通过其中某一个对象变量修改对象的属性时，会导致另一个对象此属性的值

#  三、成员变量和局部变量

### 一、变量的分类

- 按照数据类型来分：基本数据类型（8种）、引用数据类型（数组、类、接口、枚举、注解、记录）
- 按照变量在类中声明的位置不同：成员变量（或属性）、局部变量（方法内、方法形参、构造器内、构造器形参、代码块内等）
- 成员变量：在方法体外，类体内声明的变量称为成员变量
- 局部变量：在方法体内部等位置声明的变量称为局部变量

### 二、成员变量VS局部变量

1. 相同点：
	- 变量声明的格式相同：数据类型 变量名 = 变量值
	- 变量都有其有效的作用域，出了作用域就会失效
	- 变量先声明再赋值
2. 不同点：
	- 类中声明的位置不同：成员变量是声明在类内，方法外的变量；局部变量是声明在方法、构造器内部的变量
	- 在内存中分配的位置不同：成员变量是随着对象的创建，存储在堆空间中；局部变量存储在栈空间中
	- 生命周期不同：成员变量随对象的创建而创建，随着对象的消亡而消亡；局部变量随着方法对应的栈帧入栈，局部变量会在栈中分配，随着方法对应的栈帧出栈，局部变量消亡
	- 作用域不同：成员变量在整个类的内部都是有效的；局部变量仅限于声明此局部变量所在的方法（或构造器、代码块）中
	- 是否可以有权限修饰符进行修饰：成员变量可以使用权限修饰符；局部变量不可以使用任何权限修饰符
	- 是否有默认值：成员变量都有默认初始化值，意味着如果没有给成员变量进行初始化赋值，则会有默认初始化值；局部变量都没有默认初始化值，意味着在使用局部变量之前，必须要显示的赋值，否则报错。对于方法的形参而言，在调用方法时给此形参赋值即可

