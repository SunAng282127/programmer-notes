# 一、异常处理

### 一、异常的抛出机制

- Java中把不同的异常用不同的类表示，一旦发生某种异常，就创建该异常类型的对象，并且抛出（throw）。然后程序员可以捕获（catch）到这个异常并处理；如果没有捕获（catch）这个异常对象，那么这个异常对象将会导致程序终止

### 二、Java异常体系

##### 一、Throwable

1. java,lang.Throwable类是Java程序执行过程中发生的异常事件对应的类的根父类
2. Throwable中的常用方法
	- public void printStackTrace()：打印异常的详细信息。包含了异常的类型、异常的原因、异常出现的位置、在开发和调试阶段都得使用printStackTrace
	- public String getMessage()：获取异常的原因

##### 二、Error和Exception

1. Error（java.lang.Error）：java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。一般不编写针对性的代码进行处理。也是非受检异常
	- 栈内存溢出（StackOverflowError）
	- 堆内存溢出（OutOfMemoryError），简称OOM
2. Exception（java.lang.Exception）：其他因编程错误或偶然的外在因素导致的一般性问题，需要使用针对性的代码进行处理，使程序继续运行。否则一旦发生异常，程序也会挂掉
	- 空指针访问
	- 试图读取不存在的文件
	- 网络连接中断
	- 数组角标越界

### 三、Exception的分类

##### 一、编译时期异常

1. 编译时期异常：即checked异常、受检异常，在代码编译阶段，编译器就能明确警示当前代码可能发生的异常，并明确督促程序员提前编写处理它的代码。如果程序员没有编写对应的异常处理代码，则编译器就会直接判定编译失败，从而不能生成字节码文件。通常，这类异常的发生不是由程序员的代码引起的，或者不是靠简单判断就可以避免的。开发中，编译时期的异常都需要处理
2. 常见的编译时期异常
	- ClassNotFoundException：未找到类异常
	- FileNotFoundException：文件未找到异常
	- IOException：输入输出异常

##### 二、运行时期异常

1. 运行时期异常，即runtime异常、unchecked异常、非手检异常，在代码编译阶段，编译器完全不做任何检查，无论该异常是否会发生，编译器都不给出任何提示。只有等代码运行起来并确定发生了某种异常，它才能被发现。通常，这类异常是程序员的代码编写不当引起的，只要稍加判断，或者细心检查既可以避免的。开发中，通常就不进行运行时期异常的处理，一旦在程序执行，出现了运行时异常那就根据异常的提示的信息进行修改代码
2. 常见的运行时期异常
	- ArrayIndexOutOfBoundsException：角标越界异常
	- NullPointerException：空指针异常
	- ClassCastException：类型转换异常
	- NumberFormatException：数字格式化异常
	- InputMismatchExcepton：填入异常不匹配异常
	- ArithmeticException：算数异常

### 四、异常处理方式

##### 一、try-catch-finally

1. 抛异常：程序在执行的过程中，一旦出现异常，就会在出现异常的代码处，生成对应异常类的对象，并将此对象抛出。一旦抛出，此程序就不执行其后的代码了

2. 抓异常：针对于抛出的异常的异常对象，进行捕获处理、一旦将异常进行了处理，代码就可以继续执行

3. 基本结构

	```java
	try{
	    // 可能产生异常的代码
	}
	catch(异常类型1 e){
	    // 当产生异常类型1型异常时的处置操作
	}
	catch(异常类型2 e){
	    // 当产生异常类型2型异常时的处置操作
	}
	finally{
	    // 无论是否发生异常，都无条件执行的语句
	}
	// 如果没有finally则此处可以继续执行
	```

4. try-catch使用细节

	- 将可能出现异常的代码声明在try语句中。一旦代码出现异常，就会自动生成一个对应异常类的对象，并将此对象抛出
	- 针对于try中抛出的异常类的对象，使用之后的catch语句进行匹配。一旦匹配上，就进入catch语句块进行处理。一旦处理结束，代码就可能继续向下执行
	- 如果声明了多个catch结构，不同的异常类型在不存在子父类关系的情况下，谁声明在上面，谁声明在下面都可以；如果多个异常类型满足子父类的关系，则必须将子类声明在父类结构上的上面，否则报错。无论是否有子父类的异常对象类型，从上至下匹配，捕获到的异常只会执行一次，
	- catch中异常处理的方式：自己编写输出的语句；printStackTrace()，打印异常的详细信息；getMessage()，获取发生异常的原因
	- try中声明的变量的只能在try中使用，出了try结构之后，就不能进行调用了
	- try-cath结构可以嵌套使用

5. finally使用细节

	- 将一定要执行的代码声明在finally结构中，如果没有声明finally，则后面的也会执行，就怕catch中有代码会抛异常或者报错
	- 无论try中或catch中是否存在仍未被处理的异常，无论try中或catch中是否存在return语句等，finally中声明的语句都会执行
	- 如果执行finally代码块之前有return的返回值，则先将返回值存放在操作数栈中，等待执行finally之后再去返回此值，即使finally代码块中操作过此值，返回也是return时候的值。当然finally中return新值会把try或catch中return返回的值覆盖
	- catch和finally都要搭配try使用，不能单独使用
	- 在开发过程中，有一些资源（输入流、输出流、数据库连接、Socket连接等资源），在使用完毕后，必须显示的进行关闭操作，否则，GC不会自动的回收这些资源，进而导致内存泄漏。为了保证这些资源在使用完毕之后，不管是否出现了未被处理的异常的情况下，这些资源能被关闭。我们必须将这些操作声明在finally中

##### 二、throws+异常类型

1. throws格式：在方法的声明处，使用 throws 异常类型1,异常类型2……{}
2. throws处理异常的结果
   - 从编译是否通过的角度看，看成是给出了异常万一要是出现的时候的解决方案，此方案就是继续向上抛出
   - 仅是将可能出现的异常抛给了此方法的调用者。此调用者仍然需要考虑如何处理相关异常，从这个角度来看，throws的方式不算是真正意义上处理了异常

三、开发中try-catch与throws的使用

1. 如果程序代码中，涉及到资源的调用（流、数据库连接、网络连接等），则必须考虑使用try-catch-finally来处理，保证不出现内存泄漏
2. 如果父类被重写的方法没有throws异常类型，则子类重写的方法中如果出现异常，只能考虑使用try-catcj-finally进行处理，不能throws
3. 开发中，方法a中依次调用了方法b,c,d等方法，方法b,c,d之间是递进关系。此时，如果方法b,c,d中有异常，我们通常选择使用throws，而方法a中通常选择使用try-catch-finally

### 五、手动抛出异常

##### 一、手动抛出异常的原因

- 在实际开发过程中，如果出现不满足具体场景的代码问题，我们就有必要手动抛出一个指定类型的异常对象

##### 二、手动抛出异常的格式

- throw + 异常类的对象
- throw抛出异常的方法声明上必须要有throws来抛出。throws后面的异常必须是与throw抛出的异常类型相同或是throw抛出的异常类型的的父类
- throw下一行不能写代码了
- 如果抛出的是运行时异常，则不需要捕获；如果抛出的是编译时异常，则需要捕获

##### 三、throw和throws的区别

- throws使用在方法声明上，作用是将异常向上抛出，属于异常处理。throws后面跟的是异常类型
- throw使用在方法内部，作用是将异常抛出，属于产生异常对象。throw后面跟得知异常类型对象

### 六、自定义异常

##### 一、自定义异常类的格式

- 继承于现有的异常体系。通常继承于RuntimeException/Exception
- 通常提供几个重载的构造器
- 提供一个全局常量，声明为：static final long serialVersionUID

##### 二、自定义异常类的使用

- 在具体的代码中，满足指定条件的情况下，需要手动的使用 throw + 自定义异常类的对象 这种方式，将异常对象抛出
- 如果自定义异常类是非运行时异常，则必须考虑如何处理此异常类的对象

##### 三、自定义异常类的意义

- 通过异常的名称就能直接判断此异常出现的原因。尽然如此，我们就有必要在实际开发场景中，不满足我们指定的条件时，指明我们自己特有的异常类。通过此异常类的名称就能判断出具体出现的问题

# 二、多线程

### 一、程序、进程与线程

1. 程序：为完成特定任务，用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象

2. 进程：程序的一次执行过程，或是正在内存中运行的应用程序。每个进程都有一个独立的内存空间，系统运行一个程序即是一个进程创建、运行到消亡的过程（生命周期）。程序是静态的，进程是多态的。进程是操作系统调度和分配资源的最小单位（亦是系统运行程序运行的基本单位），系统在运行时会为每个进程分配不同的内存区域

3. 线程：进程可进一步细化为线程，是程序内部的一条执行路径。线程是CPU调度和执行的最小单位。一个进程中的多个线程会共享相同的内存单元，他们从同一个堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能会带来安全隐患

4. 线程调度

   - 分时调度，所有线程轮流使用CPU的使用权，并且平均分配每个线程占用的CPU的时间
   - 抢占式调度，让优先级高的线程以较大的概率优先使用CPU，如果线程的优先级相同，那么会随机选择一个（线程随机性）
   -  Java使用的为抢占式调度

5. 多线程程序的优点

   - 提高应用程序的响应。对图形化界面更有意义，可增强用户体验
   - 提高计算机系统CPU的利用率
   - 改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改

6. JVM虚拟机图解

   - 一个进程占用一个内存空间，不同的进程之间是不共享内存的
   - 线程共享进程的内存有：方法区、堆
   - 线程独有的内存有：虚拟机栈、本地方法栈、程序计数器

   ![JVM虚拟机图解](../../../TyporaImage/jvm虚拟机.png)

### 二、并行与并发

1. 并行（parallel）：指两个或多个事件在同一时刻发生（同时发生）。指在同一时刻，有多条指令在多个CPU上同时执行
2. 并发（concurrency）：指两个或多个事件在同一时间段内发生。即在一段时间内，有多条指令在单个CPU上快速轮换、交替执行，使得在宏观上具有多个进程同时执行的效果

### 三、创建和启动线程

##### 一、概述

1. Java语言的JVM允许程序运行多个线程，使用java.lang.Thread类代表线程，所有的线程对象都必须是Thread类或其子类的实例
2. Thread类的特性
   - 每个线程都是通过某个特定的Thread对象的run()方法来完成操作的，因此把run()方法称为线程执行体
   - 通过该Thread对象的start()方法来启动这个线程，而非直接调用run()
   - 要想实现多线程，必须在主线程中创建新的线程对象

##### 二、继承Thread类

1. 定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务。执行不同逻辑的线程定义不同的子类，分别调用即可

2. 创建Thread子类的实例，即创建了线程对象

3. 调用线程对象的start()方法来启动该线程

4. 通过对象调用start()的作用：启动线程；调用当前线程的run()

5. 不能让已经start()的线程，再次执行start()，否则报异常

   ```java
   // 定义Thread类的子类
   class Father extends Thread{
   
       // 重写run()方法，实现业务逻辑
       @Override
       public void run() {
           for(int i=0;i<100;i++){
               if(i%2==0){
                   System.out.println(i+"");
               }
           }
       }
       
       public static void main(String[] args) {
           // 直接创建Thread子类的实例
           Father father = new Father();
           // 调用线程对象的start()方法来唤醒线程
           father.start();
           
           // 创建Thread类的匿名子类的匿名对象
           new Thread(){
               @Override
       		public void run() {
           		for(int i=0;i<100;i++){
               		if(i%2==0){
                   		System.out.println(i+"");
               		}
           		}
       		}
           }
       }
   }
   
   ```

   

