# 一、JDK与JRE

1. JDK（Java Development Kit）：是Java程序开发工具包，包含JRE和开发人员使用的工具
2. JRE（Java Runtime Environment）：是Java程序的运行时环境，包含JVM和运行时所需要的核心类库
3. JDK > JRE > JVM

# 二、JDK系统环境配置

- 右键点击电脑属性->高级系统设置->环境变量->系统变量->Path->直接把JDK bin的环境路径粘贴过来即可（或者同Path同级别设置JAVA_HOME变量，JAVA_HOME填入JDK的路径。Path中填入%JAVA_HOME%\bin即可）
- JDK的路径一定要放在Path的最上层，以防有其他环境影响Java的执行
- JDK9及其以后的版本不用配置环境变量，安装后系统环境中会有，只需挪动Path中JDK8和JDK21的环境变量位置就可切换不同的版本

#  三、开发步骤

1. Java开发三步骤：编写、编译、运行

   - 编写：将Java代码编写到扩展名为.java的源文件中

   - 编译：通过javac.exe命令对该java文件进行编译，生成一个或多个字节码文件（字节码文件名称为类名）。

     格式：javac 源文件名.java。则会生成字节码文件，注意这里带文件后缀名

   - 运行：通过java.exe命令对生成的class文件进行运行，找main()所在的class文件

     格式：java 字节码文件名。则会运行，注意这里不带文件后缀名

2. 针对编写进行说明

   - class：关键字，表示“类”，后面跟着类名

   - main()：main()方法格式是固定的，表示程序的入口

     ```java
     public static void main(String[] args) // String[] args可以改变成String args[]或改变参数名等
     ```

   - Java程序，是严格区分大小写的

   - 每一行执行语句都必须以“;”结尾

   - 一个源文件中可以声明多个类，但是最多只能有一个类使用public进行声明，且要求声明为public的类名与文件名称相同

3. 针对编译进行说明

   - 如果编译不通过，根据报错信息进行修改
   - 编译以后会生成一个或多个字节码文件。每一个字节码文件对应一个Java类，并且字节码文件与类名相同

4. 针对运行进行说明

#  四、注释

- 注释：源代码中用于解释、说明程序的文字就是注释
- 单行注释、多行注释的作用：对程序中代码进行解释说明；对程序进行调试
- 单行注释、多行注释注意点：单行注释、多行注释中声明的信息，不参与编译；多行注释不能嵌套使用
- 文档注释：文档注释内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档

1. 单行注释

   ```java
   // 单行注释
   ```

2. 多行注释

   ```java
   /*
   多行注释
   多行注释
   */
   ```

3. 文档注释

   ```java
   /** 
   * @Author sunsh
   * @Date 21:50 2023/11/23
   * @Param 
   * @return 
   * 
   **/
   ```

4. Java API文档：Java在线说明书

# 五、Java核心机制：JVM

1. Java语言的优缺点：

   1. 优点

      - 跨平台性：核心优势。通过Java语言编写的应用程序在不同的系统平台上都可以运行

        原理：只需要在运行java应用程序的操作系统中，先安装一个Java虚拟机（JVM，Java Virtual Machine）即可。由JVM来负责java程序在该系统中的运行

      - 面向对象性：面向对象编程支持封装、继承、多态等特性，让程序更好达到高内聚，低耦合的标准

      - 健壮性：吸收了C/C++语言的优点，但是去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制

      - 安全性高：java适合于网络/分布式环境，需要提供一个安全机制以防恶意代码的攻击，如安全防范机制（ClassLoader类加载器），可以分配不同的命名空间以防替代本地的同名类、字节代码检查

      - 简单性：相比于C/C++简单

      - 高性能：通过JVM的优化，提升了性能。比如，通过JIT（JUST IN TIME）即时编译技术提高运行效率

      - 生态繁荣

   2. 缺点

      - 语法过于复杂、严谨
      - 整个架构会比较重
      - 并非适用于所有领域

2. JVM功能说明

   - JVM（Java Virtual Machine，Java虚拟机）：是一个虚拟的计算机，是Java程序的运行环境，JVM具有指令集并使用不同的存储区域，负责执行指令，管理数据、内存、寄存器
   - 实现Java程序的跨平台性
   - 自动内存管理（内存分配、内存回收）
     - Java程序在运行过程中，涉及到运算的数据分配、存储等都由JVM来完成
     - Java消除了程序员回收无用内存空间的职责。提供了一种系统级线程跟踪存储空间的分配情况，在内存空间达到相应阈值时，检查并释放可被释放的存储器空间
     - GC的自动回收，提升了内存空间的利用效率，也提高了编程人员的效率，很大程度上减少了因为没释放空间而导致的内存泄漏

3. 略谈内存溢出和内存泄漏

   - 内存溢出：指的是内存放不了多出来的东西了，就会导致内存溢出
   - 内存泄漏：JVM可能对可回收数据或者不可回收数据判断错误，导致数据存储过大或数据丢失，从而造成内存泄漏
   - 内存泄漏可能导致内存溢出
   - Java中即使有JVM也可能会导致内存泄漏或内存溢出

# 六、变量与运算符

### 一、关键字

- 定义：被Java语言赋予了特殊含义，用作专门用途的字符串
- 特点：全部关键字都是小写字母
- 注意点：const和goto是关键字，但是是保留字；true、false以及null并不是关键字，但是定义变量的时候也不用

### 二、标识符

1. Java中变量、方法、类等要素命名时使用的字符序列，称为标识符

2. 技巧：凡是自己可以起名字的地方都是标识符

3. 标识符的命名规则，必须遵守

   ```
   由26个英文字母大小写，0-9，_或$组成
   数字不可以开头
   不可以使用关键字和保留字，但能包含关键字和保留字
   Java中严格区分大小写，长度无限制
   标识符不能包含空格
   ```

4. 标识符的命名规范

   ```
   包名：多单词组成时所有字母都小写
   类型、接口名：多单词组成时，所有单词的首字母大写
   变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写
   常量名：所有字母都大写，多单词时每个单词用下划线连接
   命名时最好见名知意，如果不遵守规范，编译时也会通过
   ```

### 三、变量

1. 变量是程序中不可或缺的组成单位，最基本的存储单元

2. 初识变量

	```
	内存中的一个存储区域，该区域的数据可以在同一类型范围内不断变化
	
	变量的构成包含三个要素：数据类型、变量名、存储的值
	
	Java中变量声明的格式：数据类型 变量名 = 变量值
	
	Java中变量按照数据类型来分类：
		基本数据类型（8种）：
			整型：byte/short/int/long
			浮点型：float/double
			字符型：char
			布尔型：boolean
		引用数据类型：类、数组、接口、枚举、注解、记录
		
	定义变量时，变量名要遵循标识符命名的规则和规范
	
	说明：
		变量都有其作用域，变量只在作用域内是有效的，出了作用域就会失效了
		在同一个作用域内，不能声明两个同名的变量
		定义好变量以后，就可以通过变量名的方式对变量进行调用和运算
		变量值在赋值时，必须满足变量的数据类型，并且在数据类型有效的范围内变化
		
		
	```

	```java
	// 定义变量的方式1
	char gender; // 变量的声明
	gender = '男'; // 变量的赋值（或初始化）
	gender = '女';
	
	// 定义变量的方法2，声明与初始化合并
	int age = 10;
	```

3. 基本数据类型介绍

	1、整型类型：byte、short、int、long

	```
	Java各整数类型有固定的表数范围和字段长度，不受具体操作系统的影响，以保证Java程序的可移植性
	定义long 类型的变量，赋值时需要以“l”或“L”作为后缀
	Java程序中变量通常声明为int型，除非不足以表示较大的数，才使用long
	Java的整型常量默认为int型
	```

	| 类型  |  占用存储空间  |         表述范围         |
	| :---: | :------------: | :----------------------: |
	| byte  | 1字节 = 8bit位 |         -128~127         |
	| short |     2字节      |      -2^15^~2^15^-1      |
	|  int  |     4字节      | -2^31^~2^31^-1（约21亿） |
	| long  |     8字节      |      -2^63^~2^63^-1      |

	2、浮点类型：float、double

	```
	与整数类型类似，Java浮点类型也有固定的表数范围和字段长度，不受具体操作系统的影响
	浮点型常量有两种表示形式：
		十进制形式。如：5.12 512.0f .512（必须有小数点）
		科学计数法形式。如：5.12e2 512E2 100E-2
	float：单精度，尾数可以精确到7位有效数字。很多情况下，精度很难满足需求
	double：双精度，精度是float的两倍。通常采用此类型
	定义float类型的变量，赋值时需要以“f”或“F”作为后缀
	Java的浮点型常量默认位double型
	float类型表数范围要大于long类型的表数范围，但是精度不高。如果在开发过程中，需要精度极高的，需要使用过BigDecimal类替换浮点型变量
	```

	|     类型     | 占用存储空间 |       表数范围       |
	| :----------: | :----------: | :------------------: |
	| 单精度float  |    4字节     |  -3.403E38~3.403E38  |
	| 双精度double |    8字节     | -1.798E308~1.798E308 |

	3、字符类型：char

	```
	char型数据用来表示通常意义上“字符”（占2字节）
	Java中的所有字符都使用Unicode编码，故一个字符可以存储一个字母，一个汉字，或其他书面语的一个字符
	字符型变量的表现形式
		·使用单引号''括起来的单个字符。eg：char c1 = 'a'。必须时单引号，内部有且仅有一个字符，没有会报错
		·直接使用Unicode值来表示字符型常量；'\uXXXX'。其中，XXXX代表一个十六进制整数。eg：\u0023表示'#'
		·Java中还允许使用转义字符'\'来将其后的字符转变为特殊字符型常量。
		·使用ASCII码。eg：char a = 97 
	```

	4、布尔类型：boolean

	```
	boolean类型用来判断逻辑条件，一般用于流程控制语句中：
		·if条件控制语句
		·while循环控制语句
		·for循环控制语句
		·do-while循环控制语句
	boolean类型数据只有两个值：true、false，无其他
		·不可以使用0或非0的整数替代false和true，这点和C语言不同
		·Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达所操作的boolean值，在编译之后都使		用Java虚拟机中的int数据类型来代替：true用1表示；false用0表示
	```

	5、基本数据类型变量间的自动类型提升规则

	```
	这里提到可以做运算的基本数据类型有7种，不包含boolean类型
	运算规则包括：
		·自动类型提升
		·强制类型转换
	自动类型提升：当容量小的变量与容量大的变量做运算时，结果自动转换为容量大的数据。此时的容量小或大，并非指占用的内存空间的大小，而是指表示数据的范围的大小：
		·byte、short、char --> int --> long --> float --> double
		·byte、short以及char类型的变量之间做运算，结果为int类型
		·整型常量，规定为是int类型，即使定义时使用的其他类型的基本数据类型
	强制类型转换：
		·如果需要将容量大的变量的类型转换为容量小的变量的类型，需要使用强制类型转换
		·强制类型转换需要使用强转符：()。在()内指明要转换为的数据类型
		·强制类型转换肯能会出现精度损失，直接截断，不是四舍五入规则
	```

### 四、String类

###### 一、关于String的理解

1. String类，属于引用数据类型，俗称字符串
2. String类型的变量，可以使用一对“” 的方式进行赋值
3. String声明的字符串内部，可以包含0个、1个或多个字符

###### 二、String与基本数据类型变量间的运算

1. 这里的基本数据类型包括boolean在内的8种
2. String与基本数据类型变量间只能做连接运算，用“+”进行连接
3. 运算的结果是Sting类型
4. String类型不能强制转为基本数据类型，但是使用基本数据类型的包装类可以将String类型的数据转为基本数据类型的数据

### 五、计算机存储单位

- 字节（Byte）：是计算机用于计算存储容量的基本单位，一个字节等于8 bit

- 位（bit）：是数据存储的最小单位。二进制数系统中，每个0或1就是一个位，叫做bit（比特），其中8 bit就称为一个字节（Byte）

- 转换关系

  ```
  8 bit = 1Byte
  1024 Byte = 1KB
  1024KB = 1MB
  1024MB = 1GB
  1024GB = 1TB
  ```

### 六、计算机底层存储数据原理

- 计算机世界中只有二进制，所以计算机中存储和运算的所有数据都要转为二进制。包括数字、字符、图片、声音、视频等

1. 进制的分类
   - 十进制：数字组成为0~9；进位规则为满十进一
   - 二进制：数字组成为0~1；进位规则为满二进一，以0b或0B开头
   - 八进制：数字组成为0~7；进位规则为满八进一，以数字0开头表示
   - 十六进制：数字组成为0~9,a-f；进位规则为满十六进一，以0x或0X开头表示。此处的a-f不区分大小写
2. 进制之间的转换（二进制与十进制）
   - 最高位表示符号位：0表示正数；1表示负数
   - 计算机数据的存储使用二进制补码形式存储
   - 正数的补码与反码、原码一样，称为三码合一
   - 负数的补码与反码、原码不一样
     - 负数的原码：把十进制转为二进制，然后最高位设置为1
     - 负数的反码：在原码的基础上，最高位不变，其余位取反（0变1，1变0）
     - 负数的补码：反码+1
   - 十进制转二进制：除2取余的逆。除的时候商作为下一个的被除数，除到商和余数都为0为止

### 七、运算符

1. 运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等

2. 运算符的分类：

- 按照功能分为：算术运算符、赋值运算符、比较（或关系）运算符、逻辑运算符、位运算符、条件运算符、Lambda运算符

  |            分类             |                        运算符                        |
  | :-------------------------: | :--------------------------------------------------: |
  |      算术运算符（7个）      |                +、-、*、/、%、++、--                 |
  |     赋值运算符（12个）      | =、+=、-=、*=、/=、%=、>>=、<<=、>>>=、&=、\|=、^=等 |
  | 比较（或关系）运算符（6个） |                >、>=、<、<=、==、\|=                 |
  |      逻辑运算符（6个）      |                &、\|、^、！、&&、\|\|                |
  |       位运算符（7个）       |                &、\|、~、<<、>>、>>>                 |
  |      条件运算符（1个）      |              (条件表达式)？结果1：结果2              |
  |        Lambda运算符         |                          ->                          |

- 按照操作数个数分为：一元运算符（单目运算符）、二元运算符（双目运算符）、三元运算符（三目运算符）

  |           分类           |                     运算符                     |
  | :----------------------: | :--------------------------------------------: |
  | 一元运算符（单目运算符） |                +、-、++、！、~                 |
  | 二元运算符（双目运算符） | 除了一元运算符和三元运算符剩下的都是二元运算符 |
  | 三元运算符（三目运算符） |           (条件表达式)？结果1：结果2           |

3. 算术运算符

| 运算符 |                  运算                  |    范例    |  结果   |
| :----: | :------------------------------------: | :--------: | :-----: |
|   +    |                  正号                  |     +3     |    3    |
|   -    |                  负号                  |   b=4;-b   |   -4    |
|   +    |                   加                   |    5+5     |   10    |
|   -    |                   减                   |    6-4     |    2    |
|   *    |                   乘                   |    3*4     |   12    |
|   /    |                   除                   |    5/5     |    1    |
|   %    |              取模（取余）              |    7%5     |    2    |
|   ++   | 自增（前）：先运算后取值，运算包括赋值 | a=2;b=++a  | a=3;b=3 |
|   ++   | 自增（后）：先取值后运算，运算包括赋值 | a=2;b=a++  | a=3;b=2 |
|   --   | 自减（前）：先运算后取值，运算包括赋值 | a=2;b=--a  | a=1;b=1 |
|   --   | 自减（后）：先运算后取值，运算包括赋值 | a=2;b=a--  | a=1;b=2 |
|   +    |               字符串连接               | "He"+"llo" | "Hello" |

4. 赋值运算符

| 赋值运算符 |                           符号解释                           |
| :--------: | :----------------------------------------------------------: |
|     =      | 当=两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则进行处理，可以连续赋值，赋值时也可共用同一个数据类型 |
|     +=     | 将符号左边的值和右边的值进行相加操作，最后将结果赋值给左边的变量 |
|     -=     | 将符号左边的值和右边的值进行相减操作，最后将结果赋值给左边的变量 |
|     *=     | 将符号左边的值和右边的值进行相乘操作，最后将结果赋值给左边的变量 |
|     /=     | 将符号左边的值和右边的值进行相除操作，最后将结果赋值给左边的变量 |
|     %=     | 将符号左边的值和右边的值进行取模操作，最后将结果赋值给左边的变量 |
|            |                                                              |

5. 比较运算符：结果都是boolean型，也就是要么是true，要么是false

|   运算符   |        运算        |           范例            | 结果 |              适用范围               |
| :--------: | :----------------: | :-----------------------: | :--: | :---------------------------------: |
|     ==     |       相等于       |                           |      |  适用于基本数据类型和引用数据类型   |
|     !=     |       不等于       |                           |      |  适用于基本数据类型和引用数据类型   |
|     <      |        小于        |                           |      | 只适用于基本数据类型（boolean除外） |
|     >      |        大于        |                           |      | 只适用于基本数据类型（boolean除外） |
|     <=     |      小于等于      |                           |      | 只适用于基本数据类型（boolean除外） |
|     >=     |      大于等于      |                           |      | 只适用于基本数据类型（boolean除外） |
| instanceof | 检查是否是类的对象 | "Hello" instanceof String | true |                                     |

6. 逻辑运算符

   - 逻辑运算符，操作的都是boolean类型的变量或常量，而且运算结果也是boolean类型的值
   - 运算符说明：
     - &(逻辑与)和&&(短路与)：表示“且”关系，当符号左右两边布尔值都是true时，结果才能为true，否则为false
     - |(逻辑或)和||(短路或)：表示“或”关系，当符号两边布尔值有一边为true时，结果为true。当两边都为false时，结果为false
     - !：表示“非”关系，当变量布尔值为true时，结果为false。当变量布尔值为false时，结果为true
     - ^：表示“异或”关系，当符号左右两边布尔值不同时，结果为true。当两边布尔值相同时，结果为false

7. 位运算符

   - 针对数值类型的变量或常量进行运算，运算的结果也是数值
   - 在一定范围内，每向左移动一位，结果就在原有的基础上*2（对于正数、负数都适用）
   - 在一定范围内，每向左移动一位，结果就在原有的基础上/2（对于正数、负数都适用）；如果不能整除则向下取整

   | 运算符 |    运算    |                           细节概述                           |
   | :----: | :--------: | :----------------------------------------------------------: |
   |   <<   |    左移    |             空位补0，被移除的高位丢弃，空缺位补0             |
   |   >>   |    右移    | 被移位的二进制最高位时0，右移后，空缺位补0；最高位是1，空缺位补1 |
   |  >>>   | 无符号右移 |      被移位二进制最高位无论是0或者是1，空缺位都是用0补       |
   |   &    |   与运算   |     二进制位进行&运算，所有位数只有1&1时结果是1，否则是0     |
   |   \|   |   或运算   |    二进制位进行\|运算，所有位数只有0\|0时结果是0，否则是1    |
   |   ^    |  异或运算  |  所有位数相同二进制位进行`^`运算，结果是0；1`^`1=0；0`^`0=0  |
   |   ~    |  取反运算  |                         所有位数取反                         |

8. 条件运算符

   - (条件表达式) ? 表达式1 : 表达式2

9. 运算符优先级

   - 基本的顺序为：算术运算符、位运算符、比较运算符、逻辑运算符、条件运算符、赋值运算符

   | 优先级 |    运算符说明    |        Java运算符        |
   | :----: | :--------------: | :----------------------: |
   |   1    |       括号       |        ()、[]、{}        |
   |   2    |      正负号      |           +、-           |
   |   3    |    单元运算符    |       ++、--、~、!       |
   |   4    | 乘法、除法、求余 |         *、/、%          |
   |   5    |    加法、减法    |           +、-           |
   |   6    |    移位运算符    |       <<、>>、>>>        |
   |   7    |    关系运算符    | <、<=、>=、>、instanceof |
   |   8    |    等价运算符    |          ==、!=          |
   |   9    |      按位与      |            &             |
   |   10   |     按位异或     |            ^             |
   |   11   |      按位或      |            \|            |
   |   12   |      条件与      |            &&            |
   |   13   |      条件或      |           \|\|           |
   |   14   |    三目运算符    |           ? :            |
   |   15   |    赋值运算符    |  =、+=、-=、*=、/=、%=   |
   |   16   |   位赋值运算符   |  &=、!=、<<=、>>=、>>>=  |

# 七、流程控制

- 流程控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组合成能完成一定功能的小逻辑模块

- 程序设计中规定的三种流程结构

  ​	1、顺序结构：程序从上到下逐步地执行，中间没有任何判断和跳转

  ​	2、分支结构：根据条件，选择性地执行某段代码。有if……else和switch……case两种分支结构

  ​	3、循环结构：根据循环条件，重复性地执行某段代码。有for、while、do-while三种循环语句。

  ​							JDK5.0提供了foreach循环，方便遍历集合、数组元素。

  ​							循环结构四要素分别为：初始化部分、循环条件部分、循环体部分、迭代部分

- if……else：

	​	1、如果多个条件表达式之间没有交集（理解为互斥关系），则哪个条件表达式声明在上面，哪个声明在下面在下面都可以

	​	2、如果多个条件表达式之间是包含关系，则需要将范围小的条件表达式声明在范围大的条件表达式地上面。否则，范围小的表达式不可能被执行

	```java
	// 格式：如果执行语句只有一行，则{}可以省略，但是不建议省略
	// 格式1
	if(条件表达式){语句块;}
	
	//格式2：二选一
	if(条件表达式){
		语句块1;
	}else{
		语句块2;
	}
	
	// 格式3：多选一
	if(条件表达式1){
		语句块1;
	}else if(条件表示2){
		语句块2;
	}
	……
	}else if(条件表达式n){
	    语句块n;
	}else{
	    语句块n+1;
	}
	```

- switch……case 选择结构

  ​	1、根据表达式中的值，依次匹配case语句，一旦与某个case中的常量相等，俺么就执行此case中的执行语句，执行完此执行语句之后。遇到break则跳出当前的switch……case结构；没有遇到break，则继续执行其后的case中的执行语句，直到遇到break或者执行完所有的case及default中的语句后退出

  ​	2、switch中的表达式只能是特定的数据类型：byte、short、char、int、枚举、String

  ​	3、case 后都是跟的常量，使用表达式与这些常量做相等的判断，不能进行范围的判断

  ​	4、case的穿透性：case后不加break，或匹配后的多条语句，叫做case的穿透性	

  ​	4、开发中，使用switch……case时，通常匹配的情况都有限

  ​	6、default：类似于if-else中的else结构。default是可选的，而且是灵活的

  ```java
  switch(表达式){
      case 常量1:
          语句块1;
          // break;
  	case 常量2：
          语句块2;
          // break;
  	// ……
  	default:
          语句块n+1;
       	break;
  }
  ```

  ​	7、if……else语句与switch……case语句比较

  ```java
  Ⅰ 开发工程中，凡是可以使用switch……case结构的场景，都可以改写为if……else。反之，不成立
  Ⅱ 开发过程中，如果一个具体问题既可以使用switch……case，又可以使用if……else，则优先考虑switch……case，因为 switch……case效率更高
  Ⅲ if……else语句优势：
  	① if语句的条件是一个布尔类型值，if条件表达式为true则进入分支，可以用于范围的判断，也可以用于等值的		判断，使用范围更广
  	② switch语句的条件是一个常量值（byte、short、int、char、枚举、String）,只能判断某个变量或表达式		 的结果是否等于某个常量值，使用场景较狭窄
  Ⅳ switch语句优势：
  	① 当条件是判断某个变量或表达式是否等于某个固定的常量值时，使用if和switch都可以，习惯上使用switch	  更多。因为效率稍高。当条件是区间范围的判断时，只能使用if语句
  	② 使用switch可以利用穿透性，同时执行多个分支，而if……else没有穿透性
  ```

- for循环

	```java
// for循环的格式
	for(初始化条件;循环条件;迭代部分){
    循环体;
	}
	```
- while循环

	```java
// while循环的格式
	初始化条件
  while(循环条件){
		循环体;
    迭代部分;
	}
	```
- do……while循环

    ```java
    // do……while循环的格式
    初始化条件
    do{
      循环体部分;
        迭代部分;
    }while(循环条件部分)
    ```

- 三种循环的选择

  ```
  遍历有明显的循环次数（范围）的需求，选择for循环
  遍历没有明显的循环次数（范围）的需求，选择while循环
  如果循环体语句块至少执行一次，可以考虑使用do……while循环
  本质上，三种循环之间完全可以互相转换，都能实现循环的功能
  ```

- 嵌套循环的使用

  ```
  内层循环充当了外层循环的循环体
  对于两层嵌套循环来说，外层循环控制行数，内层循环控制列数
  外层循环执行m次，内层循环执行n次，则内层循环的循环体共执行m*n次
  ```

- break和continue的说明

  很多语言中都有goto语句，goto语句可以随意将控制转移到程序中的任意一条语句中，然后执行它，但使程序容易出错。Java中的break和continue是不同于goto的

  |          |        适用范围        |         在循环结构中使用的作用         |            相同点            |
  | :------: | :--------------------: | :------------------------------------: | :--------------------------: |
  |  break   | switch……case；循环结构 | 一旦执行，就结束（或跳出）当前循环结构 | 此关键字的后面，不能声明语句 |
  | continue |        循环结构        | 一旦执行，就结束（或跳出）当次循环结构 | 此关键字的后面，不能声明语句 |

- Scanner：键盘输入功能的实现

	​	1、导包：import java.util.Scanner

	​	2、提供一个Scanner类的实例

	​	3、调用Scanner类中的方法，获取指定类型的变量

	​	4、关闭资源，调用Scanner类的close()方法

	```java
	// 步骤1
	Scanner scanner = new Scanner(System.in);
	// 步骤2
	String name = scanner.next(); // .next()默认为String类型输入
	// 步骤3
	scanner.close();
	```

- 随机数的生成

	​	1、Math类的random()的调用，会返回一个[0,1)范围的一个double型值

	​	2、转换类型时，要把Math.random()包住，否则只要显示0

	```java
	// [0,1)的随机数
	double num = Math.random();
	
	// [0,100]的随机数
	int num1 = (int)(Math.random()*101)
	```

# 八、工程与模块管理

- 层级关系：project（工程）> module（模块）> package（包）> class（类）。都是一对多关系

# 九、数组

1. 数组的概念:

	- 数组，是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理
	- 数组的概念：数组名、下标（或索引）、元素、数组的长度

2. 数组的特点：

	- 数组本身是引用数据类型，而数组中的元素可以是任何数据类型，包括基本数据类型和引用数据类型
	- 创建数组对象会在内存中开辟一整块连续的空间，占据的空间大小，取决于数组的长度和数组中元素的类型
	- 数组中的元素在内存中是依次紧密排列的、有序的
	- 数组，一旦初始化完成，其长度就是确定的。数组的长度一旦确定，就不能修改
	- 可以直接通过下标（或索引）的方式调用指定位置的元素，速度很快
	- 数组名中引用的是这块连续空间的首地址

3. 数组的分类：

	- 按照元素的类型，基本数据类型元素的数组和引用数据类型元素的数组
	- 按照数组的维数，分为一维数组，二维数组……

4. 一维数组的使用

	- 数组的声明和初始化

		```java
		// 格式1：动态格式化->数组变量的赋值与数组元素的赋值操作分开进行
		double[] prices = new double[4]
		prices[0] = 1;
		prices[1] = 2;
		   
		// 格式2：静态初始化->数组变量的赋值与数组元素的赋值操作同时进行
		double[] prices = new double[]{20,32,34,21}   
		
		// 格式3
		String names[] = new String[4];
		String[] names = {"1","2","3"} // 类型推断，可省略后面的new
		```

	- 调用数组的指定元素

	- 数组的属性，length，表示数组的长度

	- 数组的遍历

	- 数组元素的默认初始化值

		```java
		// 以数组的动态初始化方式为例说明
		整型数组元素的默认初始化值：0
		浮点型数组元素的默认初始化值：0.0
		字符型数组元素的默认初始化值：0（或'\u0000'，就是数字0）
		boolean型数组元素的默认初始化值：false
		引用类型数组元素的默认初始化值：null
		```

5. 一维数组的内存解析

  - Java虚拟机的内存划分

    | 区域名称   |                             作用                             |
    | ---------- | :----------------------------------------------------------: |
    | 虚拟机栈   | 用于存储正在执行的每个Java方法的局部变量表等。局部变量表存放了编译期可知长度的各种基本数据类型、对象引用，方法执行完自动释放 |
    | 堆内存     |    存储对象（包括数组对象），new来创建的，都存储在堆内存     |
    | 方法区     | 存储已被虚拟机加载的类信息、常量、（静态变量）、即时编译器编译后的代码等数据 |
    | 本地方法栈 | 当程序中调用了native的本地方法时，本地方法执行期间的内存区域 |
    | 程序计数器 | 程序计数器是CPU的寄存器，它包含每一个线程下一条要执行的指令的地址 |

  - 数组名中引用的是堆中连续空间的首地址，每次new的时候都会开辟一个新的空间并把空间的首地址给引用对象，不用new赋值时（用其他已经创建好的数组赋值时）只会把首地址赋值给新的引用变量。不同变量改变同一个首地址的数据时，数组元素会改变

6. 多维数组的使用

   - 数组的声明和初始化

     ```java
     // 格式1：动态格式化->数组变量的赋值与数组元素的赋值操作分开进行
     double[][] prices = new double[4][5] // 后面的5可以不指定，为空也可以
     prices[0][0] = 1;
     prices[1][1] = 2;
     // 如果不指定后面的长度时，则可以用以下的方式赋值
     prices[0] = new double[3];
     prices[0][1] = 1.2;
        
     // 格式2：静态初始化->数组变量的赋值与数组元素的赋值操作同时进行
     double[][] prices = new double[][]{{2,3,4},{32,43,54},{34,54,232,54},{251}}   
     
     // 格式3
     String names[][] = new String[4][5];
     String[][] names = {{"1","2","3"},{"3","4"}} // 类型推断，可省略后面的new
     String[] names[] = new String[4][5];
     ```

   - 调用数组的指定元素

   - 数组的属性，length，表示数组的长度

   - 数组的遍历

   - 数组元素的默认初始值

     ```java
     // 以数组的动态初始化方式为例说明，如果外层和内层都指定长度，那么new之后的数组外层元素都是地址值，内层元素是以下的初始值
     整型数组元素的默认初始化值：0
     浮点型数组元素的默认初始化值：0.0
     字符型数组元素的默认初始化值：0（或'\u0000'，就是数字0）
     boolean型数组元素的默认初始化值：false
     引用类型数组元素的默认初始化值：null
         
     // 以数组的动态初始化方式为例说明，如果不指定内层元素的长度，说明就不会开辟内层的对象kong'jian，那么外层元素的默认值为null，调用内层元素会报空指针异常
     ```

