# 一、JUC简介

## 一、JUC概述

1. JUC 是 java.util.concurrent 的简写，在并发编程中使用的工具类 
2. 实现多线程有三种方式：Thread、Runnable、Callable，其中 Callable 就位于 concurrent 包下 

## 二、进程、线程和管程

1. 进程：进程是一个具有一定独立功能的程序，关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元
2. 线程：通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义，线程可以利用进程所有拥有的资源。在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程小，基本上不拥有系统资源， 故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度
3. 管程：Monitor（锁），也就是我们平时所说的锁。Monitor 其实是一种**同步机制**，它的义务是保证（同一时间）只有一个线程可以访问被保护的数据和代码，JVM中同步是基于进入和退出监视器（Monitor管程对象）来实现的。Monitor 对象并不会随着 Java 对象的销毁而销毁，Java对象是在Java堆中创建的，而Monitor是与Java对象关联的、由JVM内部管理的机制。Monitor的创建和销毁并不直接对应于Java对象的创建和销毁。更确切地说，当Java对象被用作同步锁时，JVM会为该对象关联一个Monitor；而当该对象不再被用作同步锁，或者对象被垃圾回收时，与其关联的Monitor可能会被JVM内部释放或重新利用

## 三、并发和并行

1. 并发：并发是指两个或多个事件在同一时间间隔发生；并发侧重于在同一实体上；并发在一台处理器上同时处理多个任务 

2. 并行：并行是指两个或者多个事件在同一时刻发生；并行侧重于在不同实体上；并行在多台处理器上同时处理多个任务。并发指的是在宏观上多个程序或任务在同时运行，而在微观上这些程序交替执行，可以提高系统的资源利用率和吞吐量。通常一个CPU内核在一个时间片只能执行一个线程（某些CPU采用超线程技术，物理核心数和逻辑核心数形成一个 1：2 的关系，比如4核CPU，逻辑处理器会有8个，可以同时跑8个线程），如果N个内核同时执行N个线程，就叫做并行

   ![](../../../TyporaImage/31085-20240413130419941-376423906.png)

   ![](../../../TyporaImage/31085-20240413130428785-1260587822.png)

## 四、线程分类

1. 用户线程：是系统的工作线程，它会完成这个程序需要完成的业务操作。默认都是用户线程

2. 守护线程：是一种特殊的线程为其他线程服务的，在后台默默地完成一些系统性的任务，比如垃圾回收线程就是最典型的例子。守护线程作为一个服务线程，没有服务对象就没有必要继续运行了，如果用户线程全部结束了，意味着程序需要完成的业务操作已经结束了，系统可以退出了。所以假如当系统只剩下守护线程的时候，守护线程伴随着JVM一同结束工作

   ```java
   /**
    * @author Guanghao Wei
    * @create 2023-04-10 10:59
    */
   public class DaemonDemo {
       public static void main(String[] args) {
           Thread t1 = new Thread(() -> {
               System.out.println(Thread.currentThread().getName() + " 开始运行," + (Thread.currentThread().isDaemon() ? "守护线程" : "用户线程"));
               while (true) {
   
               }
           }, "t1");
           t1.setDaemon(true);//通过设置属性Daemon来设置当前线程是否为守护线程
           t1.start();
           try {
               TimeUnit.SECONDS.sleep(3);
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
   
           System.out.println(Thread.currentThread().getName() + " 主线程结束");
       }
   }
   
   
   输出：t1 开始运行,守护线程
   main 主线程结束--->在main主线程结束后，守护线程会伴随着JVM一同结束工作，即使还有循环没有结束
   ```

# 二、CompletableFuture

## 一、Future接口理论

1. Future接口（FutureTask实现类）定义了操作异步任务执行一些方法，如获取异步任务的执行结果、取消异步任务的执行、判断任务是否被取消、判断任务执行是否完毕等
2. 举例：比如主线程让一个子线程去执行任务，子线程可能比较耗时，启动子线程开始执行任务后，主线程就去做其他事情了，忙完其他事情或者先执行完，过了一会再才去获取子任务的执行结果或变更的任务状态（老师上课时间想喝水，他继续讲课不结束上课这个主线程，让学生去小卖部帮老师买水完成这个耗时和费力的任务）

## 二、Future接口常用实现类FutureTask

### 一、Future接口的作用

- Future是Java5新加的一个接口，它提供一种异步并行计算的功能，如果主线程需要执行一个很耗时的计算任务，我们会就可以通过Future把这个任务放进异步线程中执行，主线程继续处理其他任务或者先行结束，再通过Future获取计算结果

### 二、Future接口相关架构

1. 目的：异步多线程任务执行且返回有结果。三个特点：多线程、有返回、异步任务（班长为老师去买水作为新启动的异步多线程任务且买到水有结果返回）

2. 代码实现：Runnable接口 + Callable接口 + Future接口和FutureTask实现类

   ![](../../../TyporaImage/image-1720576754908.png)

   ```java
   /**
    * @author Guanghao Wei
    * @create 2023-04-10 11:21
    */
   public class CompletableFutureDemo {
       public static void main(String[] args) throws ExecutionException, InterruptedException {
           FutureTask<String> futureTask = new FutureTask(new MyThread());
           Thread t1 = new Thread(futureTask); //开启一个异步线程
           t1.start();
   
           System.out.println(futureTask.get()); //有返回hello Callable
       }
   }
   
   
   class MyThread implements Callable<String> {
   
       @Override
       public String call() throws Exception {
           System.out.println("--------come in");
           return "hello Callable";
       }
   }
   ```

3. 优点：Future + 线程池异步多线程任务配合，能显著提高程序的运行效率

4. 缺点：

- - `get()`阻塞，一旦调用`get()`方法求结果，一旦调用不见不散，非要等到结果才会离开，不管你是否计算完成，如果没有计算完成容易程序堵塞

  - `isDone()`轮询，轮询的方式会耗费无谓的cpu资源，而且也不见得能及时得到计算结果，如果想要异步获取结果，通常会以轮询的方式去获取结果，尽量不要阻塞

  - 结论：Future对于结果的获取不是很友好，只能通过**阻塞或轮询**的方式得到任务的结果

    ```java
    /**
     * @author Guanghao Wei
     * @create 2023-04-10 11:41
     */
    public class FutureApiDemo {
        public static void main(String[] args) throws ExecutionException, InterruptedException, TimeoutException {
            FutureTask<String> futureTask = new FutureTask<>(() -> {
                System.out.println(Thread.currentThread().getName() + "--------come in");
                try {
                    TimeUnit.SECONDS.sleep(5);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                return "task over";
            });
    
            Thread t1 = new Thread(futureTask, "t1");
            t1.start();
    
    //        System.out.println(futureTask.get());//这样会有阻塞的可能，在程序没有计算完毕的情况下。
            System.out.println(Thread.currentThread().getName() + " ------忙其他任务");
    //        System.out.println(futureTask.get(3,TimeUnit.SECONDS));//只愿意等待三秒，计算未完成直接抛出异常
            while (true) {//轮询
                if(futureTask.isDone()){
                    System.out.println(futureTask.get());
                    break;
                }else{
                    TimeUnit.MILLISECONDS.sleep(500);
                    System.out.println("正在处理中，不要催了，越催越慢");
                }
            }
            /* 轮询结果
            * main ------忙其他任务
            t1--------come in
            正在处理中，不要催了，越催越慢
            正在处理中，不要催了，越催越慢
            正在处理中，不要催了，越催越慢
            正在处理中，不要催了，越催越慢
            正在处理中，不要催了，越催越慢
            正在处理中，不要催了，越催越慢
            正在处理中，不要催了，越催越慢
            正在处理中，不要催了，越催越慢
            正在处理中，不要催了，越催越慢
            正在处理中，不要催了，越催越慢
            task over
            Process finished with exit code 0
            * */
        }
    }
    
    ```

5. 使用场景

   - 回调通知

   - - 应对Future的完成时间，完成了可以告诉我，也就是我们的回调通知
     - 通过轮询的方式去判断任务是否完成这样非常占cpu并且代码也不优雅

   - 创建异步任务：Future+线程池组合
   - 多个任务前后依赖可以组合处理（水煮鱼--->买鱼--->调料--->下锅）

   - - 想将多个异步任务的结果组合起来，后一个异步任务的计算结果需要前一个异步任务的值
     - 想将两个或多个异步计算合并成为一个异步计算，这几个异步计算互相独立，同时后面这个又依赖前一个处理的结果

   - 对计算速度选最快的

   - - 当Future集合中某个任务最快结束时，返回结果，返回第一名处理结果

   - 结论

   - - 使用Future之前提供的那点API就囊中羞涩，处理起来不够优雅，这时候还是让CompletableFuture以声明式的方式优雅的处理这些需求
     - 从i到i++
     - Future能干的，CompletableFuture都能干



