# 一、面向对象的概述

### 一、学习面向对象内容的三条主线

- Java类及类的成员：属性、方法、构造器、代码块、内部类
- 面向对象的特征：封装、继承、多态、（抽象）
- 其他关键字的使用：this、super、package、import、static、final、interface、abstract等

### 二、面向过程VS面向对象

- 面向过程是以函数为组织单位，是一种执行者思维，适合解决简单问题。扩展能力差、后期维护难度较大
- 面向对象以类为组织单位，每种事物都具备自己的属性和行为/功能，是一种设计者思维。适合解决复杂问题。代码扩展性强、可维护性高
- 二者关系：二者相辅相成，面向对象离不开面向过程

### 三、类和对象概述

- 类和对象使面向对象的核心概念
- 类：具有相同特征的事物的抽象描述，是抽象的，概念上的定义
- 对象：实际存在的该类事物的每个个体，是具体的，因而也成为实例

# 二、类的实例化与内存解析

### 一、类的内部成员

- 属性：也就是成员变量、field（字段、域）
- 方法：（成员）方法、函数、Method
- 构造器
- 代码块
- 内部类

### 二、面向对象完成具体功能操作的三步

- 创建类，并设计类的内部成员（属性、方法）
- 创建类的对象。
- 通过对象，调用其内部声明的属性或方法，完成相关的功能

### 三、类的实例化

- 等价描述：类的实例化 <=> 创建类的对象<=>创建类的实例

- 格式：类类型 对象名 = 通过new创建的对象实体

  ```java
  // 创建Phone的对象
  Phone p1 = new Phone();
  // 通过Phone的对象，调用其内部声明的属性或方法
  // 格式为 对象.属性 或 对象.方法
  p1.name = "huwei";
  pi.call();
  ```

### 四、对象的内存解析

##### 一、对象在内存中的分配涉及到的内存结构

- 栈（stack）：方法内定义的变量（局部变量），存储在栈中。还存放方法的栈针
- 堆（heap）：new出来的结构（数组的实体、对象的实体），包括对象中的属性（成员变量）
- 方法区（method area）：存放类的模板

##### 二、类中对象的内存解析

- 在通过new创建的多个对象，对象实例存放在栈中，每个对象在堆空间中有一个对象实体，堆中对象实体的地址值赋值给栈中的对象实例
- 在堆中的每一个对象实体保存着一份类的属性，属性是引用类型的，则在堆中保存的是引用类型的地址或者null
- 如果修改某一个对象的某属性值时，不会影响其他对象此属性的值
- 如果栈中两个对象实例指向堆空间中同一个对象实体（地址值相同）。如果通过其中某一个对象变量修改对象的属性时，会导致另一个对象此属性的值

#  三、成员变量和局部变量

### 一、变量的分类

- 按照数据类型来分：基本数据类型（8种）、引用数据类型（数组、类、接口、枚举、注解、记录）
- 按照变量在类中声明的位置不同：成员变量（或属性）、局部变量（方法内、方法形参、构造器内、构造器形参、代码块内等）
- 成员变量：在方法体外，类体内声明的变量称为成员变量
- 局部变量：在方法体内部等位置声明的变量称为局部变量

### 二、成员变量VS局部变量

1. 相同点：
   - 变量声明的格式相同：数据类型 变量名 = 变量值
   - 变量都有其有效的作用域，出了作用域就会失效
   - 变量先声明再赋值
2. 不同点：
   - 类中声明的位置不同：成员变量是声明在类内，方法外的变量；局部变量是声明在方法、构造器内部的变量
   - 在内存中分配的位置不同：成员变量是随着对象的创建，存储在堆空间中；局部变量存储在栈空间中
   - 生命周期不同：成员变量随对象的创建而创建，随着对象的消亡而消亡；局部变量随着方法对应的栈帧入栈，局部变量会在栈中分配，随着方法对应的栈帧出栈，局部变量消亡
   - 作用域不同：成员变量在整个类的内部都是有效的；局部变量仅限于声明此局部变量所在的方法（或构造器、代码块）中
   - 是否可以有权限修饰符进行修饰：成员变量可以使用权限修饰符；局部变量不可以使用任何权限修饰符
   - 是否有默认值：成员变量都有默认初始化值，意味着如果没有给成员变量进行初始化赋值，则会有默认初始化值；局部变量都没有默认初始化值，意味着在使用局部变量之前，必须要显示的赋值，否则报错。对于方法的形参而言，在调用方法时给此形参赋值即可

# 四、方法

### 一、方法的理解

- 方法是类或对象行为特征的抽象，用来完成某个功能操作。在某些语言中也称为函数或过程
- 将功能封装成方法的目的是，可以实现代码重用，减少冗余，简化代码
- Java中的方法不能独立存在，所有的方法必须定义在类中
- Java中的方法不调用，不执行。每调用一次，就执行一次
- 方法内可以调用本类中的方法或属性
- 方法内不能定义方法

### 二、方法声明的格式

```java
权限修饰符 [其他修饰符] 返回值类型 方法名(形参列表) [throws 异常类型]{ // 方法名
    // 方法体
}
```

##### 一、权限修饰符：private、缺省、protected、public

##### 二、返回值类型：描述当调用完此方法时，是否需要返回一个结果

- 无返回值类型：使用void表示即可
- 有具体的返回值类型：需要指明返回的数据类型。可以是基本数据类型，也可以是引用数据类型。需要在方法内部配合使用“return + 返回值类型的变量或常量”

##### 三、方法名：属于标识符。需要满足标识符的规定和规范。见名知意

##### 四、形参列表：形参，属于局部变量，且可以声明多个

- 无形参列表：不能省略一对括号
- 有形参列表：根据方法调用时，需要的不确定的变量的类型和个数，确定形参的类型和个数

```java
//格式：
(形参类型1 形参1,形参类型2 形参2,……){

}
```

##### 五、方法体：当我们调用一个方法时，真正执行的代码。体现了此方法的功能

##### 六、return返回的作用

- 结束一个方法
- 结束一个方法的同时，可以返回数据给方法的调用者（方法声明中如果有返回值类型，则方法内需要搭配return使用，当然抛异常的时候return就不是必需品了）
- 在return关键字的直接后面不能声明执行语句

##### 七、方法调用的内存解析

- 形参：方法在声明时，一对()内声明的一个或多个形式参数，简称为形参。形参为基本数据类型时复制的是实参的值；形参为引用数据类型时复制的时实参的引用地址。所以Java中的传递还是值传递
- 实参：方法在被调用时，实际传递给形参的变量或常量，就称为实际参数，简称为实参
- 调用方法时，方法栈帧先入栈，当此方法执行完毕时则出栈，下一个方法栈帧入栈。以此类推

##### 八、方法应用

1. 方法重载（overload）
	- 方法重载：在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可。满足这样特征的多个方法，彼此之间构成方法的重载。参数列表不同，意味着参数个数或参数类型的不同
	- 重载的特点：与修饰符、返回类型无关，只看参数列表，且参数列表必须不同。（参数个数或参数类型不同，与参数名称无关）。调用时，根据方法参数列表的不同来区别
	- 重载方法调用：JVM通过找方法名称和方法参数列表，调用匹配的方法。先找个数、类型最匹配的；再找个数和类型可以兼容的，如果同时多个方法可以兼容将会报错
2. 可变个数形参的方法
	- 使用场景：在调用方法时，可能会出现方法形参的类型是确定的，但是参数的个数不确定。此时，就可以使用可变个数形参的方法
	- 格式：(参数类型… 参数名)
	- 说明：可变个数形参的方法在调用时，针对于可变的形参赋的实参的个数可以为0、1或多个；可变个数形参的方法与同一个类中，同名的多个方法之间可以构成重载；可变个数形参的方法与同一个类中方法名相同，且与可变个数形参类型相同的数组参数不构成重载，可以认为可变个数参数相当于数组，遍历也是像数组一样遍历；可变个数形参必须声明在形参列表的最后且只能出现一次可变个数参数
3. 方法值传递机制
	- 对于方法内声明的局部变量，如果是基本数据类型的变量，则将此变量保存的数据值传递出去；如果是引用数据类型的变量，则将此变量保存的地址值传递出去
	- 方法的参数的传递机制：值传递机制
	- 如果形参是基本数据类型的变量，则将实参保存的数据值赋给形参；如果形参是引用数据类型的变量，则将实参保存的地址值赋给形参
4. 递归方法
   - 方法自己调用自己的现象就称为递归
   - 递归方法分类：直接递归、间接递归
   - 使用说明：递归方法包含了一种隐式的循环；递归方法会重复执行某段代码，但是这种重复执行无须循环控制；递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环，最终发生栈内存溢出
   - 递归调用会占用大量的系统堆栈，内存耗用多，在递归调用层次多时速度要比循环慢的多，所以在使用递归时要慎重；在要求高性能的情况下尽量避免使用递归，递归调用既花时间又耗内存，考虑使用循环迭代

# 五、关键字的使用

### 一、package关键字的使用

1. 说明：
   - package：包
   - package用于指明该文件中定义的类、接口等结构所在的包
   - 一个源文件只能有一个声明包的package语句
   - package语句作为Java源文件的第一条语句出现，若缺省该语句，则指明为无名包
   - 包名，属于标识符，满足标识符命名的规则和规范（全部小写）、见名知意。
   - 包通常使用所在公司域名的倒置，如com.sun.xxx
   - 包对应于文件系统的目录，package语句中使用“.”来指明包（目录）的层次，每“.”一次就表示一层文件目录
   - 同一个包下可以声明多个结构（类、接口），但是不能定义同名的结构（类、接口）。不同的包下可以定义同名的结构（类、接口）
2. 包的作用
   - 包可以包含类和子包，划分项目层次，便于管理
   - 帮助管理大型软件系统：将功能相近的类划分到同一个包中
   - 帮助解决类命名冲突的问题
   - 控制访问权限

### 二、import关键字的使用

1. 为了使用定义在其他包中的Java类，需要使用import语句来显示引入指定包下所需的类。相当于import语句告诉编译器到哪里去寻找这个类
2. 注意事项：
   - import语句，声明在包的声明和类的声明之间
   - 如果需要导入多个类或接口，那么就并列显示多个import语句即可
   - 如果使用a.*导入结构，表示可以导入a包下的所有的结构，但是不包括子包下结构（类或接口）
   - 如果导入的类或接口是java.lang包下的，或者是当前包下的，则可以省略此import语句
   - 如果已经导入java.a包中的类，那么如果需要使用a包的子包下的类的话仍需要导入（包中包）
   - 如果在代码中使用不同包下的同名的类，那么就需要使用类的全类名的方式指明调用的是哪个类
   - import static组合的使用：调用指定类或接口下的静态属性或方法

### 三、this关键字的使用

1. this的定义

   - this在方法（实例方法或者说是非static的方法）内部使用，表示调用该方法的对象。用于创建好的对象
   - this在构造器内部使用，表示该构造器正在初始化的对象。用于正在创建的对象

2. this的使用

   - this可以调用的结构有成员变量、方法和构造器

3. this调用属性和方法

   - 针对方法内的使用情况（准确的说是非static修饰的方法），一般情况我们通过对象a调用方法，可以在方法内调用当前对象a的属性或其他方法。此时，我们可以在属性和其他方法前使用“this.”，表示当前属性或方法所属的对象a，但是，一般情况下，我们都选择省略此“this.”结构
   - 针对方法内的使用情况（准确的说是非static修饰的方法），特殊情况下如果方法的形参与对象的属性同名了，则必须使用“this.”进行区分，修饰的变量即为属性（或者说是成员变量）。没有使用this.修饰的变量即为局部变量

4. 构造器中使用this

   - 一般情况，我们通过构造器创建对象时，可以在构造器内调用当前正在创建的对象的属性或方法。此时，我们可以在属性或方法前使用“this.”，表示当前属性或方法所属的对象。但是，一般情况下，我们都选择省略此“this."结构

   - 特殊情况，如果构造器的形参与正在创建的对象的属性同名了，我们必须使用“this.”进行区分。使用this,修饰的变量即为属性（或者说是成员变量）。没有使用this.修饰的变量，即为局部变量

   - 如果一个类中声明了n个构造器，则最多有（n-1）个构造器可以声明在this(形参列表)的结构

   - 构造器调用构造器的使用

     ```java
     // this调用构造器
     // 格式：this(形参列表)
     // 可以在类的构造器中，调用当前类中指定的其他构造器
     // 要求：this(形参列表)必须声明在当前构造器的首行，且在同一个构造器中最多声明一次
     
     public class User{
         
         private String name;
         
         private String sex;
         
         // 无参构造器
         public User(){}
         
         // 有参构造器
         public User(String name){
             // 调用无参构造器
             this();
         }
         
          // 有参构造器
         public User(String name,String sex){
             // 调用无参构造器
             this(name);
             this.sex = sex
         }
     }
     ```

### 四、super关键字的使用

1. super的理解：可以调用父类的属性、方法和构造器
2. super调用属性、方法
   - 子类继承父类以后，就可以在子类的方法或构造器中，调用父类声明的属性或方法。（满足封装性的前提下）调用时，需要使用“super.”的结构，表示调用父类的属性或方法
   - 一般情况下，我们可以考虑省略“super.”的结构。但是，如果出现子类重写了父类的方法或子父类中出现了同名的属性时，则必须使用“super.”的声明，显示地调用父类被重写的方法或父类中声明的同名的属性
3. super调用构造器
   - 子类继承父类时，不会继承父类的构造器。只能通过“super(形参列表)”的方式调用父类指定的构造器
   - super(形参列表)必须声明在构造器的首行
   - 在构造器的首行，this(形参列表)和super(形参列表)只能二选一
   - 如果在子类构造器中既没有显示地调用this(形参列表)和super(形参列表)，则子类此构造器默认调用super()，即调用父类中空参的构造器
   - 子类的任何一个构造器中，要么会调用本类中重载的构造器，要么会调用父类的构造器，只能是这两种情况之一
   - 如果一个类中声明了n个构造器，则最多有（n-1）个构造器可以声明在this(形参列表)的结构，则剩下的那个一定使用super(形参列表)
   - 在通过子类的构造器创建对象时，一定在调用子类构造器的过程中，直接或间接的调用父类的构造器。也正因为调用父类的构造器，才会将父类中声明的属性或方法加载到内存中，供子类对象使用
4. 无论是this还是super都是逐层的往上找属性或方法，也就是就近原则。this是从本层级找，本层级找不到则找父类，以此类推；super是从父类开始找，父类找不到则找父类的父类，以此类推。this和super都是构建的对象，而不是类

### 五、static关键字的使用

##### 一、static修饰范围

- 属性、方法、代码块、内部类

##### 二、static修饰属性和方法

1. 成员变量，按照是否使用static修饰进行分类
	- 使用static修饰的成员：静态变量（类变量）
	- 不使用static修饰的成员变量：非静态变量（实例变量）
2. 局部变量：方法内、方法形参、构造器内、构造器形参、代码块内等
3. 静态变量与实例变量的对比
	- 个数上：静态变量在内存空间中只有一份，被类的多个对象所共享；类的每一个实例（或对象）都保存着一份实例变量
	- 内存位置上：静态变量jdk6及之前存放在方法区中，jdk7及之后存放在堆空间（单独开辟一块区域，也就是静态域中存放类变量）；实例变量存放在堆空间的对象实体中
	- 加载时机上：静态变量随着类的加载而加载，由于类只会加载一次，所以静态变量也只有一份；实例变量随着对象的创建而加载，每个对象拥有一份实例变量
	- 调用者上：静态变量可以直接调用，也可以使用对象调用；实例变量只能使用对象进行调用
	- 判断是否可以调用（从生命周期的角度解释）：类可以调用类变量，但是不能调用实例变量；对象可以调用类变量，也可以调用实例变量
	- 消亡时机上：静态变量随着类的卸载而消亡；实例变量随着对象的消亡而消亡
4. static修饰方法（类方法，也就是静态方法）
	- 随着类的加载而加载
	- 可以通过“类.静态方法”的方式，直接调用静态方法（属性和方法的前缀是当前类，可以省略）
	- 静态方法内可以调用静态的结构，但不能调用非静态的结构（属性、方法等）
	- 非静态方法内可以调用静态的结构，也能调用非静态的结构（属性、方法等）
	- static修饰的方法内，不能使用this和super
	- static修饰的属性和方法可以被继承，但是不能被重写，也就是说可以被覆盖
5. 开发中，将属性声明为静态的时机
	- 判断当前类的多个实例是否能共享此成员变量，且此成员变量的值是相同的
	- 开发中，常将一些常量声明是静态的
6. 开发中，将方法声明为静态的时机
	- 方法内操作的变量都是静态变量（而非实例变量）的话，则此方法建议声明为静态方法
	- 开发中，常常将工具类中的方法声明为静态

### 六、final关键字的使用

1.  final可以修饰的结构：类、方法、变量
2. final修饰类：表示此类不能被继承。如String、StringBuffer、StringBuilder类
3. final修饰方法：表示此方法不能被重写
4. final修饰变量：既可以修饰成员变量，也可以修饰局部变量。此时的“变量”其实就成了“常量”，意味着一旦赋值，就不可更改
   - final修饰成员变量： 可以显示赋值、代码块中赋值、构造器中赋值
   - final修饰局部变量：一旦赋值就不能更改。方法内声明的局部变量在调用该局部变量前，一定需要赋值，而且一旦赋值，就不可更改；在调用方法时，就应该给形参进行赋值，而且一旦赋值，就不可更改
5. final和static搭配：修饰成员变量时，此成员变量称为全局常量

# 六、封装性

### 一、封装的意义和实现

- 高内聚，低耦合：内聚指一个模块内各个元素彼此结合的紧密程度；耦合指一个软件结构内不同模块之间互连程度的度量。内聚意味着重用和独立，耦合意味着牵一发动全身。高内聚指的是类的内部数据操作细节自己完成，不允许外部干涉；低耦合仅暴露少量的方法给外部使用，尽量方便外部调用
- 实现封装就是控制类或成员的可见性范围，需要依赖访问控制修饰符，也称为权限修饰符来控制

### 二、权限修饰符

- 四种权限修饰符：private、缺省、protected、public

- 权限修饰符作用：使用四种修饰符来修饰类及类的内部信息。当这些成员被调用时，体现可见性的大小

- 权限修饰符具体修饰的结构：外部类使用public和缺省修饰；成员变量、成员方法、构造器、成员内部类使用public、protected、缺省、private修饰

- 权限修饰符范围

  |  修饰符   | 本类内部 | 本包内 | 其他包的子类 | 其他包非子类 |
  | :-------: | :------: | :----: | :----------: | :----------: |
  |  private  |   可以   | 不可以 |    不可以    |    不可以    |
  |   缺省    |   可以   |  可以  |    不可以    |    不可以    |
  | protected |   可以   |  可以  |     可以     |    不可以    |
  |  public   |   可以   |  可以  |     可以     |     可以     |

### 三、封装性的体现

- 私有化（private）类的属性，提供公共（public）的get和set方法，对此属性进行获取或修改
- 将类中不需要对外暴露的方法，设置为private
- 单例模式中构造器private的，避免在类的外部创建实例

# 七、继承性

### 一、继承的理解

1. 自上而下：定义了一个类A，在定义另一个类B时，发现类B的功能与A相似，考虑类B继承于A
2. 自下而上：定义了类B、C、D等，发现B、C、D有类似的属性和方法，则可以考虑将相同的属性和方法进行抽取，封装到类A中，让类B、C、D继承于类A，同时，B、C、D中的相似功能可以删除掉了

### 二、继承的好处

1. 继承的出现减少了代码冗余，提高了代码的复用性
2. 继承的出现，更有利于功能的扩展
3. 继承的出现让类与类之间产生了is-a的关系，为多态的使用提供了前提。继承描述事物之间的所属关系，这种关系是is-a的关系。可见，父类更通用、更一般，子类更具体

### 三、继承的格式

1. 类A：父类、superClass类、超类、基类
2. 类B：子类、subClass类、派生类

```java
class A(
	//属性、方法
)
    
class B extends A{
    // 属性、方法
}
```

### 四、继承的特点

- 继承过程中子类获取到父类中声明的所有属性和方法
- 由于封装性的影响，子类可能不能直接调用父类中声明的属性或方法
- 子类继承父类以后，还可以扩展自己特有的功能（体现，增加特有的属性、方法）
- 不要为了继承而继承，在继承之前，判断一下是否有is-a的关系
- Java中声明的类，如果没有显示的声明其父类时，则默认继承于java.lang.Object
- Java支持多层继承（继承体系）。子类和父类的概念是相对的，有直接父类和间接父类
- Java类只支持单继承，不支持多重继承
- 一个父类可以同时拥有多个父类

### 五、方法重写 （override）

- 重写的含义：子类对父类继承过来的方法进行的覆盖、覆写操作就称为方法的重写。类的属性和方法不能重写，只是重新定义一个新的属性，名称相同而已

- 重写的规则：理解为子类中方法的权限修饰符、返回值类型（引用数据类型）、抛出异常范围都变大或相等

  ```
  Ⅰ 父类被重写的方法与子类重写的方法的方法名和形参列表必须相同；
  
  Ⅱ 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符。子类不能重写父类中声明为private权限修饰符的方法；
  
  Ⅲ 关于返回值类型：
  	1、父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型必须是void
  	2、父类被重写的方法的返回值类型是基本数据类型，则子类重写的方法的返回值类型必须与被重写的方法的返回值		  类型相同
  	3、父类被重写的方法的返回值类型是引用数据类型（比如类），则子类重写的方法的返回值类型可以与被重写的方		  法的返回值类型相同 或 是被重写的方法的返回值类型的子类
  
  Ⅳ 异常问题：子类重写的方法抛出的异常类型可以父类被重写的方法抛出的异常类型相同，或是父类被重写的方法抛出	的异常类型的子类
  
  Ⅴ 重写的方法体无要求
  ```

### 六、子类对象实例化过程

- 当我们通过子类的构造器创建对象时，子类的构造器一定会直接或间接的调用到其父类的构造器，而其父类的构造器同样也会直接或间接的调用其父类或父类的父类的构造器，以此类推直到调用到了Object的构造器为止。正因为我们调用过子类所有的父类的构造器，所以我们就会将父类中声明的属性、方法加载到内存中，供子类使用
- 在创建子类对象的过程中，一定会调用父类中的构造器
- 创建子类的对象时，内存中就只会创建一个new出来的对象，但是会用构造器初始化父类中属性。new构建对象和初始化是不同的概念

# 八、多态性

### 一、多态性的体现

- 子类对象的多态性为：父类的引用指向子类的对象。（或子类的对象赋给父类的引用）

  ```java
  Person p1 = new Men();
  ```

- Java中的多态是运行时多态

### 二、多态的应用：虚方法调用

- 在多态场景下，调用方法时：
  1. 编译时，认为方法是左边声明的父类类型的方法（即被重写的方法）
  2. 执行时，实际执行的是子类重写父类的方法
  3. 简称为：编译看左边，运行看右边
- 多态多用于方法的传参之间

### 三、多态性的使用前提

- 要有类的继承关系
- 要有方法的重写

### 四、多态的适用性

- 适用于方法，不适用于属性

### 五、多态的优劣性

- 优势：极大的减少了代码的冗余，不需要定义多个重载的方法
- 劣势：在多态的场景下，我们创建了子类的对象，也加载了子类特有的属性和方法。但是由于声明为父类的引用，导致我们没有办法直接调用子类特有的属性和方法

### 六、向上、向下转型

- 强制类型转换：较高级的基本数据类型转化为较低级的基本数据类型

- 自动类型提升：较低级的基本数据类型转化为较高级的基本数据类型

- 向上转型：也就是多态，子类转化为父类

- 向下转型：父类转化为子类，建议在向下转型之前使用instanceof进行判断，避免出现类型转换异常。

  ​				   向下转型格式为：子类 实例名称 = (子类) 父类实例

  ​				   判断格式为： 子类 instanceof 父类 -> 判断对象a是否是类A的实例

# 九、构造器

### 一、构造器的作用

- 搭配new关键字，创建类的对象
- 在创建对象的同时，可以给对象的相关属性赋值

### 二、构造器的使用说明

- 构造器声明的格式：权限修饰符 类名(形参列表){构造体}
- 创建类以后，在没有显示提供任何构造器的情况下，系统会默认提供一个空参的构造器，且默认造器的权限与类声明的权限相同
- 一旦类中显示声明了构造器，则系统不再提供默认的空参构造器，除非自己再声明一个空参的构造器
- 一个类中可以声明多个构造器，彼此之间构成重载

# 十、类中属性、JavaBean、UML

### 一、类中属性（实例变量为例子）赋值过程

1. 在类中的属性中，给属性赋值的位置：

   - 默认赋值
   - 显示赋值
   - 构造器赋值
   - 通过“对象.方法”的方式赋值
   - 通过“对象.属性”的方式赋值

2. 赋值的先后执行顺序

   默认赋值 -> 显示赋值 -> 构造器赋值 -> 通过“对象.方法”的方式赋值/通过“对象.属性”的方式赋值

3. 赋值过程在对象创建过程中可以执行的次数

   - 只执行一次：默认赋值、显示赋值、构造器赋值
   - 可以执行多次：通过“对象.方法”的方式赋值、通过“对象.属性”的方式赋值

### 二、JavaBean

- JavaBean是一种Java语言写成的可重用组件
- JavaBean标准：类是公共的；有一个无参的公共的构造器；有属性且有对应的get、set方法

### 三、UML类图

- UML（统一建模语言），用来描述软件模型和架构的图形化语言

- 常用的UML工具软件有PowerDesinger、Rose和Enterprice Architect

- UML工具软件不仅可以绘制开发中所需的各种图表，还可以生成对应的源代码

- 在软件开发过程中，使用UML类图可以更加直观地描述类内部结构（类的属性和操作）以及类之间的关系（如关系、依赖、聚合等）

  ```
  +表示public类型，-表示private类型，#表示protected类型，不写就是缺省类型
  属性的写法为：属性的权限(+、-)：属性名称：属性的类型
  方法的写法为：方法的权限(+、-) 方法名(参数名：参数类型)：返回值类型。若方法有下划线则代表是构造器
  斜体表示抽象方法或类
  继承：实现箭头指向的是父类
  ```

# 十一、Object类

### 一、Object类

1. 位于java.lang.Object
2. 任何一个Java类（除Object类）都直接或间接的继承于Object类
3. Object类称为Java类的根父类
4. Object类声明的结构（属性、方法等）就具有通用性
   - Object类中没有声明属性
   - Object类提供了一个空参的构造器

### 二、clone()

### 三、finalize()

### 四、equals()

1. 任何引用数据类型都可以使用
2. 自定义的类在没有重写Object中的equals()方法的情况下，调用的就是Object类中声明的equals()，比较两个对象的引用地址是否相同。（或比较两个对象是否指向了堆空间中的同一个对象实体）
3. 对于像String、File、Date和包装类等，他们都重写了Object类中的equals()方法，用于比较两个对象的实体内容是否相等
4. ==和equals()的区别
   - ==：使用范围为基本数据类型、引用数据类型。在基本数据类型中使用是判断数据值是否相等；在引用数据类型中使用比较的是两个引用变量的地址值是否相等。（或者说比较两个引用是否指向同一个对象实体）
   - equals()：使用范围只能使用在引用数据类型上。对于类来说，要想使用equals()来判断数据需要重写，包括数据也是，需要重写自己的逻辑才能判断，否则，还是使用的==来比较地址值。引用数据类型有属性也是引用数据类型，那么该引用数据类型比较时，内部的引用数据类型属性也要重写equals()方法

### 五、toString()

1. 自定义的类，在没有重写Object类的toString()的情况下，默认返回的是当前对象的地址值
2. 像String、File、Date或包装类等Object的子类，他们都重写了Object类的toString()，在调用toString()时，返回当前对象的实体内容

# 十二、单例（Singleton）模式

### 一、单例模式的含义

- 采用一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法

### 二、实现思路

- 如果我们要让类在一个虚拟机中只产生一个对象，我们首先必须将类的构造器的访问权限设置为private，这样，就不能new操作符在类的外部产生类的对象了，但是在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，只能调用该类的某个静态方法以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象的变量也必须定义成静态的

### 三、饿汉式和懒汉式实现方式

1. 饿汉式

	```java
	class Bank{
	
	    // 1、类的构造器私有化
	    private Bank(){
	    }
	
	    // 2、在类的内部创建当前类的实例，属性也必须声明为静态的
	    private static Bank instance = new Bank();
	
	    // 3、使用getXxx()方法获取当前的实例，必须声明为static的
	    public static Bank getInstance() {
	        return instance;
	    }
	}
	```

2. 懒汉式

	```java
	class Bank{
	
	    // 1、类的构造器私有化
	    private Bank(){
	    }
	
	    // 2、在类的内部创建当前类的实例，属性也必须声明为静态的，但是不去创建对象
	    private static Bank instance = null;
	
	    // 3、使用getXxx()方法获取当前的实例，必须声明为static的。如果未创建对象，则在方法内部进行创建
	    // 	  还需要加锁
	    public static Bank getInstance() {
	        if(instance == null){
	            instance = new Bank();
	        }
	        return instance;
	    }
	}
	```

### 四、饿汉式和懒汉式优劣势

1. 特点
	- 饿汉式：立即加载，随着类的加载，当前的唯一实例就创建了
	- 懒汉式：延迟加载，在需要使用的时候，进行创建
2. 优缺点
	- 饿汉式：写法简单，由于内存中较早加载，使用更方便、更快、线程安全。内存占用时间较长
	- 懒汉式：在需要的时候进行创建，节省空间。线程不安全

### 五、单例模式的应用场景

1. Windows的Task Manager（任务管理器）就是很典型的单例模式
2. Windows的Recyle Bin（回收站）也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例
3. Application也是单例的典型应用
4. 应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容就不好追加
5. 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源

# 十三、代码块

### 一、代码块的作用

- 用来初始化类或对象的信息（即初始化类或对象的成员变量）

### 二、代码块的修饰

- 只能使用static进行修饰

### 三、代码块的分类

- 静态代码块：使用static进行修饰
- 非静态代码块：没有使用static修饰

### 四、代码块的使用

1. 静态代码块
   - 随着类的加载而执行，重点在执行
   - 由于类的加载只会执行一次，进而静态代码块只会执行一次
   - 作用：用来初始化类的信息。内部可以声明变量、调用属性或方法、编写输出语句等
   - 静态代码块的执行先于非静态代码块
   - 静态代码块可以声明多个，执行顺序为代码声明的先后顺序
   - 静态代码块内部只能调用静态的结构（即静态的属性、方法），不能调用非静态的结构（即非静态的属性、方法）
2. 非静态代码块
   - 随着对象的创建而执行，重点也是在直接执行
   - 每创建当前类的一个实例，就会执行一次非静态代码块
   - 作用：用来初始化对象的信息。内部可以声明变量、调用属性或方法、编写输出语句等
   - 静态代码块的执行先于非静态代码块
   - 非静态代码块可以声明多个，执行顺序为代码声明的先后顺序
   - 非静态代码块内部可以调用静态的结构（即静态的属性、方法），也可以调用非静态的结构（即非静态的属性、方法）

# 十四、类中属性赋值的位置及过程

### 一、实例变量赋值的位置

1. 默认初始化
2. 显式初始化
3. 代码块中初始化
4. 构造器中初始化
5. 有了对象以后，通过“对象.属性”或“对象.方法”的方式进行赋值

### 二、实例变量赋值执行的顺序

1. 默认初始化
2. 显式初始化 / 代码块中初始化
3. 构造器中初始化

### 三、代码实例化执行顺序

- 由父及子，静态先行

# 十五、抽象性

### 一、abstract的概念

- 抽象的

### 二、abstract修饰范围

- 类、方法

### 三、abstract的使用

1. abstract修饰类
   - 此类称为抽象类
   - 抽象类不能实例化
   - 抽象类中是包含构造器的，因为子类对象实例化时，需要直接或间接的调用父类的构造器
   - 抽象类中可以没有抽象方法。反之，抽象方法所在的类一定是抽象类
2. abstract修饰方法
   - 此方法即为抽象方法
   - 抽象方法只能方法的声明，没有方法体
   - 抽象方法其功能是确定的（通过方法的声明即可确定），只是不知道具体实现
   - 子类必须必须重写父类中的所有抽象方法之后，方可实例化。否则，此子类仍然是抽象类
3. abstract不能修饰的结构
   - 属性
   - 构造器
   - 代码块
4. abstract不能共用的关键字
   - 不能用abstract修饰私有方法：private方法不能被继承和重写
   - 静态方法：为了避免静态方法使用类进行调用
   - final的方法：final修饰的方法不能被重写
   - final的类：final类修饰的类不能有子类

# 十六、接口（interface）

### 一、接口概述

- 接口就是规范，定义的是一组规则，体现了现实世界中“如果你要...则必须要,,,”的思想。继承是一个“是不是”的is-a关系，而接口实现则是“能不能”的has-a关系

### 二、接口内部结构的说明

1. 可以声明
   - 属性：必须使用public static final 修饰，不写默认还是有public static final 修饰
   - 方法：jdk8之前声明抽象方法，修饰符为pubic abstract；jdk8声明静态方法、默认方法；jdk9声明私有方法。不    写默认还是有pubic abstract 修饰
2. 不可以声明
   - 构造器
   - 代码块

### 三、接口与类

1. 接口与类的关系：实现关系
2. 类实现接口的格式：class A extends SuperA implements B,C,D{}
   - A相较于SuperA来讲，叫做子类
   - A相较于B,C来讲，叫做实现类
3. 接口与类的说明
   - 类可以实现多个接口
   - 类针对于接口的多实现，一定程度上就弥补了类的单继承和局限性
   - 类必须将实现的接口中的所有抽象方法都重写（或实现），方可实例化。否则，此实现类必须声明为抽象类

### 四、接口与接口

- 接口与接口的关系：继承关系，且可以多继承

### 五、接口的多态性

- 接口多态性格式：接口名 变量名 = new 实现类对象

  ```java
  1、 创建接口实现类的对象
      接口名 变量名 = new 实现类对象
      Computer computer = new Computer();
  	// 此处的printer为USB接口的实现类
   	Printer printer = new Printer() 
      computer.print(printer);
      
  2、创建接口实现类的匿名对象
      Computer computer = new Computer();
   	// 此处的printer为USB接口的实现类
      computer.print(new Printer());
      
  3、创建接口匿名实现类的对象
      Computer computer = new Computer();
   	// 此处为USB接口接口匿名实现类的对象
  	USB usb = new USB(){
          // 方法
      }
      computer.print(usb);
  
  4、创建接口匿名实现类的匿名对象
      Computer computer = new Computer();
   	// 此处为USB接口接口匿名实现类的对象
      computer.print(new USB(){
          // 方法
      });
  
  5. 若实现类与接口中的默认方法有重名的方法名，则使用以下格式去调用接口的默认方法
      接口名.super.方法名();
  ```

### 六、抽象类和接口的区别

1. 共性

   - 都可以声明抽象方法
   - 都不能实例化

2. 不同

   - 抽象类一定有构造器，接口没有构造器
   - 类与类之间是继承关系，类与接口之间是实现关系，接口与接口之间是多继承关系

   |    区别点    |                            抽象类                            |                     接口                     |
   | :----------: | :----------------------------------------------------------: | :------------------------------------------: |
   |     定义     |                     可以包含抽象方法的类                     |        主要是抽象方法和全局常量的集合        |
   |     组成     |           构造方法、抽象方法、普通方法、常量、变量           | 常量、抽象方法、（jdk8：默认方法、静态方法） |
   |     使用     |                  子类继承抽象类（extends）                   |          子类实现接口（implements）          |
   |     关系     |                      抽象类实现多个接口                      |    接口不能继承抽象类，但允许继承多个接口    |
   | 常见设计模式 |                           模板模式                           |         简单工厂、工厂方法、代理模式         |
   |     对象     |               都通过对象的多态性产生实例化对象               |       都通过对象的多态性产生实例化对象       |
   |     局限     |                     抽象类有单继承的局限                     |                 接口没有局限                 |
   |     实际     |                         作为一个模板                         |          是作为一个标准或是一种能力          |
   |     选择     | 如果抽象类和接口都可以使用的话，优先选择使用接口，因为避免单继承的局限 |                                              |

### 七、接口的新特性

1. jdk8声明静态方法：接口中声明的静态方法只能被接口来调用，不能被使用其实现类进行调用

   ```java
   public static void method1(){
   }
   ```

2. jdk8声明默认方法：

   - 接口中声明的默认方法可以被实现类继承，实现类在没有重写此方法的情况下，默认调用接口中声明的默认方法。如果被实现类重写了次方法，则调用的是自己重写的方法。
   - 类实现了两个接口，而两个接口中定义了同名同参的默认方法。则实现类在没有重写此两个接口的默认方法的情况下会报错（接口冲突）。此时实现类必须要重写接口中定义的同名同参数的方法
   - 子类（或实现类）继承了父类并实现了接口，父类和接口中声明了同名同参数的方法。（其中，接口中的方法是默认方法）。默认情况下，子类（或实现类）在没有重写此方法的情况下，调用的是父类中的方法。这就是类优先原则
   - 实现类手动调用接口中默认方法格式为：接口名.super.默认方法

   ```java
   public default void method(){
   }
   ```

3. jdk9声明私有方法：

   -  private修饰方法时，私有方法只能被接口中的默认方法调用 
   -  private+static修饰方法， 私有静态方法可以被接口中的默认方法和静态方法调用 
   -  private修饰方法时，此方法不能被abstract修饰 

# 十七、内部类

### 一、内部类的概念

- 将一个类A定义在另一个类B里面，里面的那个类就称为内部类（InnerClass）,类B则称为外部类（OuterClass）

### 二、内部类的使用原则

- 当一个事物A的内部，还有一个部分需要一个完整的结构B进行描述，而这个内部的完整的结构B又只为外部事物A提供服务，不在其他地方单独使用，那么整个内部的完整结构B最好使用内部类
- 遵循高内聚、低耦合原则

### 三、内部类的分类

1. 成员内部类：直接声明在外部类的里面
   - 使用static修饰的静态的成员内部类
   - 不使用static修饰的非静态的成员内部类
2. 局部内部类：声明在方法内、构造器内、代码块内的内部类
   - 匿名局部内部类
   - 非匿名局部内部类

### 三、成员内部类

1. 从类的角度解释
   - 内部类内部可以声明属性、方法、构造器、代码块、内部类等结构
   - 此内部类可以声明父类，可以实现结构
   - 可以使用final修饰
   - 可以使用abstract修饰
2. 从外部类的成员的角度解释
   - 在内部类可以调用外部类的结构。比如属性、方法等
   - 内部类可以使用四种权限修饰符进行修饰
   - 可以使用static进行修饰内部类

### 四、内部类的使用

1. 创建静态的成员内部类的实例

   ```java
   class Person {
   
       //静态内部类
       static class Dog {
           public void eat() {
               System.out.println("啃骨头");
           }
       }
   }
   
   public class HelloWorld {
       public static void main(String[] args) {
           // 创建静态内部类的实例
           Person.Dog dog = new Person.Dog();
           dog.eat();
       }
   }
   ```

2. 创建非静态的成员内部类的实例

   ```java
   class Person {
       
       private String name;
   
       // 非静态内部类
       class Bird {
           
           private String name;
           
           public void eat() {
               // 内部类调用外部类的属性
               System.out.println(Person.this.name);
               System.out.println("吃虫子");
           }
       }
   
   }
   
   public class HelloWorld {
       public static void main(String[] args) {
           // 创建非静态内部类的实例
           Person person = new Person();
           Person.Bird bird = person.new Bird();
           bird.eat();
       }
   }
   
   ```

3. 创建局部内部类的实例

   ```java
   class Student{
   
       public Comparable method1(){
           // 方式1：提供了接口的实现类的对象
           class MyComparable implements Comparable{
   
               @Override
               public int compareTo(Object o) {
                   return 0;
               }
           }
           MyComparable myComparable = new MyComparable();
           return myComparable;
       }
   
       public Comparable method2(){
           // 方式2：提供了接口的实现类的匿名对象
           class MyComparable implements Comparable{
   
               @Override
               public int compareTo(Object o) {
                   return 0;
               }
           }
           return new MyComparable();
       }
   
       public Comparable method3() {
           // 方式3：提供了接口的匿名实现类的对象
           Comparable comparable = new Comparable() {
   
               @Override
               public int compareTo(Object o) {
                   return 0;
               }
           };
           return comparable;
       }
   
       public Comparable method4(){
           // 方式4：提供了接口的匿名实现类的匿名对象
           return new Comparable() {
               @Override
               public int compareTo(Object o) {
                   return 0;
               }
           };
       }
   }
   
   public class HelloWorld {
       public static void main(String[] args) {
           Student student = new Student();
           student.method1().compareTo(45);
           student.method2();
           student.method3();
           student.method4();
       }
   }
   
   ```

# 十八、枚举类

### 一、枚举类的理解

- 枚举类型本质上也是一种类，只不过是这个类的对象是有限的、固定的几个，不能让用户随意创建

### 二、枚举类的举例

- 性别：Man(男)、Woman(女)
- 三原色：Red(红色)、Green(绿色)、Blue(蓝色)

### 三、枚举类的使用

1. 若枚举只有一个对象，则可以作为一种单例模式的实现方式

2. 使用enum关键字定义的枚举类，默认其父类是java.lang.Enum类，所以使用enum定义类时不能再使用继承。

3. 使用enum关键字定义的枚举类可以实现接口中的抽象方法，通过枚举类的对象调用即可，当通过不同的枚举类对象调用此方法时执行的是同一个方法；让枚举类的每一个对象重写接口中的抽象方法，当通过不同的枚举类对象调用此方法时，执行的是不同的实现方法，也就是相当于匿名的实现类

4. Enum类中常用的方法

   - Season.Spring.toString：默认输出常量的名称
   - Season.Spring..name：默认输出常量的名称
   - Season.values：输出所有的常量
   - Season.valueOf(常量名称)：输出特定常量名称的常量对象。找不到此值的则报错

5. 枚举类的实现

   - 在jdk5之前，需要程序员自定义枚举类型

     ```java
     class Season{
     
         // 将属性设置为私有的，防止修改数据
         private final String seasonName;
     
         private final String seasonDesc;
     
         // 将构造器私有化，防止修改数据
         private Season(String seasonName, String seasonDesc) {
             this.seasonName = seasonName;
             this.seasonDesc = seasonDesc;
         }
     
         // 只提供get方法
         public String getSeasonName() {
             return seasonName;
         }
     
         public String getSeasonDesc() {
             return seasonDesc;
         }
     
         // 创建固定个数的实例对象并设置为常量
         public static final Season SPRING = new Season("Spring","春暖花开");
         public static final Season SUMMER = new Season("Summer","夏日炎炎");
         public static final Season AUTUMN = new Season("Autumn","秋高气爽");
         public static final Season WINTER = new Season("Winter","白雪皑皑");
     
         @Override
         public String toString() {
             return "Season{" +
                     "seasonName='" + seasonName + '\'' +
                     ", seasonDesc='" + seasonDesc + '\'' +
                     '}';
         }
     }
     
     ```

   - 在jdk5之后，Java支持enum关键字来快速定义枚举类型

     ```java
     public enum Season {
     
         // 必须在枚举类的开头声明多个对象，对象之间使用"，"隔开，并且不能使用 public static final修饰
         // 这些都是实例化的对象
         SPRING("Spring","春暖花开"){
             @Override
             public void show() {
                 System.out.println("春");
             }
         },
         SUMMER("Summer","夏日炎炎"){
             @Override
             public void show() {
                 System.out.println("夏");
             }
         },
         AUTUMN("Autumn","秋高气爽"){
             @Override
             public void show() {
                 System.out.println("秋");
             }
         },
         WINTER("Winter","白雪皑皑"){
             @Override
             public void show() {
                 System.out.println("冬");
             }
         };
     
         // 声明当前类的对象的实例变量，使用private final修饰
         private final String seasonName;
     
         private final String seasonDesc;
     
         // 私有化构造器，如果该枚举类属性为空，则使用默认的空参构造器即可，也不需要声明为私有化，	  // 因为enum默认构造器私有
         private Season(String seasonName, String seasonDesc) {
             this.seasonName = seasonName;
             this.seasonDesc = seasonDesc;
         }
     
         public String getSeasonName() {
             return seasonName;
         }
     
         public String getSeasonDesc() {
             return seasonDesc;
         }
     }
     
     
     // 或者枚举类中没有任何属性，只有对象名称
     public enum Status{
         BUSY,FREE;
     }
     ```

# 十九、注解（Annotation）

### 一、注解的概念

- 注解是从jdk5开始引入的，以“@注解名”在代码中存在
- 注解可以像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明
- 注解可以添加一些参数值，这些信息被保存在Annotation的“name=value”对中
- 注解可以在类编译、运行时进行加载，体现不同的功能

### 二、注释与注解

- 注解可以看作是一种注释，通过使用Annotation，程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充的信息。但是注解不同于单行注释和多行注释
- 对于单行注释和多行注释是给程序员看的
- 注解是可以被编译器或其他程序读取的。程序可根据注解的不同做出相应的处理

### 三、自定义注解

```java
public @interface MyAnnotation{
    
    // 注解属性，需要结合反射使用。数组属性
    String[] names;
    
    // 注解属性，需要结合反射使用。String属性
    String value;
}
```

### 四、元注解

1. 元注解的理解：对现有注解进行解释说明的注解
2. 元注解的例子
	- @Target：用于描述注解的使用范围，可以使用枚举类型ElementType的10个常量对象来指定
	- @Retention：用于描述注解的声明周期，可以通过枚举类型RetentionPolicy的3个常量对象来指定，分别为SOURCE（源代码）、CLASS（字节码）、RUNTIME（运行时）。唯有RUNTIME阶段才能被反射读取到
	- @Document：表明这个注解应该被javadoc工具记录
	- @Inherited：允许子类继承父类的注解

# 二十、单元测试

### 一、测试分类

- 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值
- 白盒测试：需要写代码。关注程序具体的执行流程

### 二、JUnit单元测试介绍及使用

1. JUnit单元测试是程序员测试，即所谓白盒测试，因为程序员知道被测试的软件如何完成功能和完成什么样的功能
2. JUnit单元测试的使用
	- 需要导入的包为：junit-4.12.jar、hamcrest-core-1.3.jar
	- 所在的类必须是public的，非抽象的，包含唯一的无参构造器
	- @Test标记的方法本身必须是public的，非抽象的，非静态的，void无返回值，（）无参数的

# 二十一、包装类

### 一、使用包装类的意义

- 为了使基本数据类型的变量具备引用数据类型变量的相关特征（封装性、继承性、多态性），我们给各个基本数据类型的变量都提供了对应的包装类

### 二、基本数据对应的包装类

- byte --> Byte
- short--> Short
- int --> Interger
- long --> Long
- float --> Float
- double --> Double
- <----------以上的包装类继承于Number类-------------->
- char --> Character
- boolean --> Boolean

### 三、基本数据类型与包装类的相互转换

1. 转换的意义
	- 在有些场景下，需要使用基本数据类型对应的包装的对象，此时就需要将基本数据类型的变量转化为包装类的对象
	- 对于包装类来讲，既然我们使用的是对象，那么对象是不能进行加减乘除运算的。对了能进行运算，需要将包装类转为基本数据类型
2. 基本数据类型转为包装类
	- 使用包装类的构造器
	- 调用包装的类的xxxValueOf(变量)
	- 自动装箱，如 Interger num1 = 10
3. 包装类转为基本数据类型
	- 使用包装类.xxxValue()
	- 自动拆箱，如 int num2 = num1
4. 注意点
   - 基本数据类型和包装类的默认值是不同的，基本数据类型的默认值是数字型等，包装类默认值为null
   - Double类型的包装类默认值为null，但是一旦赋值后或new之后，默认值就会变为0.0
   - 一个包装类和一个基本数据类型的数据进行比较，编译器会先自动拆箱进行比较

### 四、包装类、基本数据类型与String类型的转化

1. 基本数据类型、包装类转为String类型
   - 使用String.valueOf(基本数据类型、包装类)
   - 直接使用连接符“+”。如 String num = 10+“”
   - 调用包装类的toSting()方法
2. Stringl类型转为基本数据类型、包装类
   - 调用包装类的 .parseXxx(字符串)。如 Interger.parseIInt(str1)