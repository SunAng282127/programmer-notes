# 一、面向对象的概述

### 一、学习面向对象内容的三条主线

- Java类及类的成员：属性、方法、构造器、代码块、内部类
- 面向对象的特征：封装、继承、多态、（抽象）
- 其他关键字的使用：this、super、package、import、static、final、interface、abstract等

### 二、面向过程VS面向对象

- 面向过程是以函数为组织单位，是一种执行者思维，适合解决简单问题。扩展能力差、后期维护难度较大
- 面向对象以类为组织单位，每种事物都具备自己的属性和行为/功能，是一种设计者思维。适合解决复杂问题。代码扩展性强、可维护性高
- 二者关系：二者相辅相成，面向对象离不开面向过程

### 三、类和对象概述

- 类和对象使面向对象的核心概念
- 类：具有相同特征的事物的抽象描述，是抽象的，概念上的定义
- 对象：实际存在的该类事物的每个个体，是具体的，因而也成为实例

# 二、类的实例化与内存解析

### 一、类的内部成员

- 属性：也就是成员变量、field（字段、域）
- 方法：（成员）方法、函数、Method

### 二、面向对象完成具体功能操作的三步

- 创建类，并设计类的内部成员（属性、方法）
- 创建类的对象。
- 通过对象，调用其内部声明的属性或方法，完成相关的功能

### 三、类的实例化

- 等价描述：类的实例化 <=> 创建类的对象<=>创建类的实例

- 格式：类类型 对象名 = 通过new创建的对象实体

  ```java
  // 创建Phone的对象
  Phone p1 = new Phone();
  // 通过Phone的对象，调用其内部声明的属性或方法
  // 格式为 对象.属性 或 对象.方法
  p1.name = "huwei";
  pi.call();
  ```

### 四、对象的内存解析

##### 一、对象在内存中的分配涉及到的内存结构

- 栈（stack）：方法内定义的变量（局部变量），存储在栈中。还存放方法的栈针
- 堆（heap）：new出来的结构（数组的实体、对象的实体），包括对象中的属性（成员变量）
- 方法区（method area）：存放类的模板

##### 二、类中对象的内存解析

- 在通过new创建的多个对象，对象实例存放在栈中，每个对象在堆空间中有一个对象实体，堆中对象实体的地址值赋值给栈中的对象实例
- 在堆中的每一个对象实体保存着一份类的属性，属性是引用类型的，则在堆中保存的是引用类型的地址或者null
- 如果修改某一个对象的某属性值时，不会影响其他对象此属性的值
- 如果栈中两个对象实例指向堆空间中同一个对象实体（地址值相同）。如果通过其中某一个对象变量修改对象的属性时，会导致另一个对象此属性的值

#  三、成员变量和局部变量

### 一、变量的分类

- 按照数据类型来分：基本数据类型（8种）、引用数据类型（数组、类、接口、枚举、注解、记录）
- 按照变量在类中声明的位置不同：成员变量（或属性）、局部变量（方法内、方法形参、构造器内、构造器形参、代码块内等）
- 成员变量：在方法体外，类体内声明的变量称为成员变量
- 局部变量：在方法体内部等位置声明的变量称为局部变量

### 二、成员变量VS局部变量

1. 相同点：
   - 变量声明的格式相同：数据类型 变量名 = 变量值
   - 变量都有其有效的作用域，出了作用域就会失效
   - 变量先声明再赋值
2. 不同点：
   - 类中声明的位置不同：成员变量是声明在类内，方法外的变量；局部变量是声明在方法、构造器内部的变量
   - 在内存中分配的位置不同：成员变量是随着对象的创建，存储在堆空间中；局部变量存储在栈空间中
   - 生命周期不同：成员变量随对象的创建而创建，随着对象的消亡而消亡；局部变量随着方法对应的栈帧入栈，局部变量会在栈中分配，随着方法对应的栈帧出栈，局部变量消亡
   - 作用域不同：成员变量在整个类的内部都是有效的；局部变量仅限于声明此局部变量所在的方法（或构造器、代码块）中
   - 是否可以有权限修饰符进行修饰：成员变量可以使用权限修饰符；局部变量不可以使用任何权限修饰符
   - 是否有默认值：成员变量都有默认初始化值，意味着如果没有给成员变量进行初始化赋值，则会有默认初始化值；局部变量都没有默认初始化值，意味着在使用局部变量之前，必须要显示的赋值，否则报错。对于方法的形参而言，在调用方法时给此形参赋值即可

# 四、方法

### 一、方法的理解

- 方法是类或对象行为特征的抽象，用来完成某个功能操作。在某些语言中也称为函数或过程
- 将功能封装成方法的目的是，可以实现代码重用，减少冗余，简化代码
- Java中的方法不能独立存在，所有的方法必须定义在类中
- Java中的方法不调用，不执行。每调用一次，就执行一次
- 方法内可以调用本类中的方法或属性
- 方法内不能定义方法

### 二、方法声明的格式

```java
权限修饰符 [其他修饰符] 返回值类型 方法名(形参列表) [throws 异常类型]{ // 方法名
    // 方法体
}
```

##### 一、权限修饰符：private、缺省、protected、public

##### 二、返回值类型：描述当调用完此方法时，是否需要返回一个结果

- 无返回值类型：使用void表示即可
- 有具体的返回值类型：需要指明返回的数据类型。可以是基本数据类型，也可以是引用数据类型。需要在方法内部配合使用“return + 返回值类型的变量或常量”

##### 三、方法名：属于标识符。需要满足标识符的规定和规范。见名知意

##### 四、形参列表：形参，属于局部变量，且可以声明多个

- 无形参列表：不能省略一对括号
- 有形参列表：根据方法调用时，需要的不确定的变量的类型和个数，确定形参的类型和个数

```java
//格式：
(形参类型1 形参1,形参类型2 形参2,……){

}
```

##### 五、方法体：当我们调用一个方法时，真正执行的代码。体现了此方法的功能

##### 六、return返回的作用

- 结束一个方法
- 结束一个方法的同时，可以返回数据给方法的调用者（方法声明中如果有返回值类型，则方法内需要搭配return使用，当然抛异常的时候return就不是必需品了）
- 在return关键字的直接后面不能声明执行语句

##### 七、方法调用的内存解析

- 形参：方法在声明时，一对()内声明的一个或多个形式参数，简称为形参。形参为基本数据类型时复制的是实参的值；形参为引用数据类型时复制的时实参的引用地址。所以Java中的传递还是值传递
- 实参：方法在被调用时，实际传递给形参的变量或常量，就称为实际参数，简称为实参
- 调用方法时，方法栈帧先入栈，当此方法执行完毕时则出栈，下一个方法栈帧入栈。以此类推

##### 八、方法应用

# 五、对象数组的使用以及内存解析

