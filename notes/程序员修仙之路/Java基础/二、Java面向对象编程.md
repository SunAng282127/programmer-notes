# 一、面向对象的概述

### 一、学习面向对象内容的三条主线

- Java类及类的成员：属性、方法、构造器、代码块、内部类
- 面向对象的特征：封装、继承、多态、（抽象）
- 其他关键字的使用：this、super、package、import、static、final、interface、abstract等

### 二、面向过程VS面向对象

- 面向过程是以函数为组织单位，是一种执行者思维，适合解决简单问题。扩展能力差、后期维护难度较大
- 面向对象以类为组织单位，每种事物都具备自己的属性和行为/功能，是一种设计者思维。适合解决复杂问题。代码扩展性强、可维护性高
- 二者关系：二者相辅相成，面向对象离不开面向过程

### 三、类和对象概述

- 类和对象使面向对象的核心概念
- 类：具有相同特征的事物的抽象描述，是抽象的，概念上的定义
- 对象：实际存在的该类事物的每个个体，是具体的，因而也成为实例

# 二、类的实例化与内存解析

### 一、类的内部成员

- 属性：也就是成员变量、field（字段、域）
- 方法：（成员）方法、函数、Method
- 构造器

### 二、面向对象完成具体功能操作的三步

- 创建类，并设计类的内部成员（属性、方法）
- 创建类的对象。
- 通过对象，调用其内部声明的属性或方法，完成相关的功能

### 三、类的实例化

- 等价描述：类的实例化 <=> 创建类的对象<=>创建类的实例

- 格式：类类型 对象名 = 通过new创建的对象实体

  ```java
  // 创建Phone的对象
  Phone p1 = new Phone();
  // 通过Phone的对象，调用其内部声明的属性或方法
  // 格式为 对象.属性 或 对象.方法
  p1.name = "huwei";
  pi.call();
  ```

### 四、对象的内存解析

##### 一、对象在内存中的分配涉及到的内存结构

- 栈（stack）：方法内定义的变量（局部变量），存储在栈中。还存放方法的栈针
- 堆（heap）：new出来的结构（数组的实体、对象的实体），包括对象中的属性（成员变量）
- 方法区（method area）：存放类的模板

##### 二、类中对象的内存解析

- 在通过new创建的多个对象，对象实例存放在栈中，每个对象在堆空间中有一个对象实体，堆中对象实体的地址值赋值给栈中的对象实例
- 在堆中的每一个对象实体保存着一份类的属性，属性是引用类型的，则在堆中保存的是引用类型的地址或者null
- 如果修改某一个对象的某属性值时，不会影响其他对象此属性的值
- 如果栈中两个对象实例指向堆空间中同一个对象实体（地址值相同）。如果通过其中某一个对象变量修改对象的属性时，会导致另一个对象此属性的值

#  三、成员变量和局部变量

### 一、变量的分类

- 按照数据类型来分：基本数据类型（8种）、引用数据类型（数组、类、接口、枚举、注解、记录）
- 按照变量在类中声明的位置不同：成员变量（或属性）、局部变量（方法内、方法形参、构造器内、构造器形参、代码块内等）
- 成员变量：在方法体外，类体内声明的变量称为成员变量
- 局部变量：在方法体内部等位置声明的变量称为局部变量

### 二、成员变量VS局部变量

1. 相同点：
   - 变量声明的格式相同：数据类型 变量名 = 变量值
   - 变量都有其有效的作用域，出了作用域就会失效
   - 变量先声明再赋值
2. 不同点：
   - 类中声明的位置不同：成员变量是声明在类内，方法外的变量；局部变量是声明在方法、构造器内部的变量
   - 在内存中分配的位置不同：成员变量是随着对象的创建，存储在堆空间中；局部变量存储在栈空间中
   - 生命周期不同：成员变量随对象的创建而创建，随着对象的消亡而消亡；局部变量随着方法对应的栈帧入栈，局部变量会在栈中分配，随着方法对应的栈帧出栈，局部变量消亡
   - 作用域不同：成员变量在整个类的内部都是有效的；局部变量仅限于声明此局部变量所在的方法（或构造器、代码块）中
   - 是否可以有权限修饰符进行修饰：成员变量可以使用权限修饰符；局部变量不可以使用任何权限修饰符
   - 是否有默认值：成员变量都有默认初始化值，意味着如果没有给成员变量进行初始化赋值，则会有默认初始化值；局部变量都没有默认初始化值，意味着在使用局部变量之前，必须要显示的赋值，否则报错。对于方法的形参而言，在调用方法时给此形参赋值即可

# 四、方法

### 一、方法的理解

- 方法是类或对象行为特征的抽象，用来完成某个功能操作。在某些语言中也称为函数或过程
- 将功能封装成方法的目的是，可以实现代码重用，减少冗余，简化代码
- Java中的方法不能独立存在，所有的方法必须定义在类中
- Java中的方法不调用，不执行。每调用一次，就执行一次
- 方法内可以调用本类中的方法或属性
- 方法内不能定义方法

### 二、方法声明的格式

```java
权限修饰符 [其他修饰符] 返回值类型 方法名(形参列表) [throws 异常类型]{ // 方法名
    // 方法体
}
```

##### 一、权限修饰符：private、缺省、protected、public

##### 二、返回值类型：描述当调用完此方法时，是否需要返回一个结果

- 无返回值类型：使用void表示即可
- 有具体的返回值类型：需要指明返回的数据类型。可以是基本数据类型，也可以是引用数据类型。需要在方法内部配合使用“return + 返回值类型的变量或常量”

##### 三、方法名：属于标识符。需要满足标识符的规定和规范。见名知意

##### 四、形参列表：形参，属于局部变量，且可以声明多个

- 无形参列表：不能省略一对括号
- 有形参列表：根据方法调用时，需要的不确定的变量的类型和个数，确定形参的类型和个数

```java
//格式：
(形参类型1 形参1,形参类型2 形参2,……){

}
```

##### 五、方法体：当我们调用一个方法时，真正执行的代码。体现了此方法的功能

##### 六、return返回的作用

- 结束一个方法
- 结束一个方法的同时，可以返回数据给方法的调用者（方法声明中如果有返回值类型，则方法内需要搭配return使用，当然抛异常的时候return就不是必需品了）
- 在return关键字的直接后面不能声明执行语句

##### 七、方法调用的内存解析

- 形参：方法在声明时，一对()内声明的一个或多个形式参数，简称为形参。形参为基本数据类型时复制的是实参的值；形参为引用数据类型时复制的时实参的引用地址。所以Java中的传递还是值传递
- 实参：方法在被调用时，实际传递给形参的变量或常量，就称为实际参数，简称为实参
- 调用方法时，方法栈帧先入栈，当此方法执行完毕时则出栈，下一个方法栈帧入栈。以此类推

##### 八、方法应用

1. 方法重载（overload）
	- 方法重载：在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可。满足这样特征的多个方法，彼此之间构成方法的重载。参数列表不同，意味着参数个数或参数类型的不同
	- 重载的特点：与修饰符、返回类型无关，只看参数列表，且参数列表必须不同。（参数个数或参数类型不同，与参数名称无关）。调用时，根据方法参数列表的不同来区别
	- 重载方法调用：JVM通过找方法名称和方法参数列表，调用匹配的方法。先找个数、类型最匹配的；再找个数和类型可以兼容的，如果同时多个方法可以兼容将会报错
2. 可变个数形参的方法
	- 使用场景：在调用方法时，可能会出现方法形参的类型是确定的，但是参数的个数不确定。此时，就可以使用可变个数形参的方法
	- 格式：(参数类型… 参数名)
	- 说明：可变个数形参的方法在调用时，针对于可变的形参赋的实参的个数可以为0、1或多个；可变个数形参的方法与同一个类中，同名的多个方法之间可以构成重载；可变个数形参的方法与同一个类中方法名相同，且与可变个数形参类型相同的数组参数不构成重载，可以认为可变个数参数相当于数组，遍历也是像数组一样遍历；可变个数形参必须声明在形参列表的最后且只能出现一次可变个数参数
3. 方法值传递机制
	- 对于方法内声明的局部变量，如果是基本数据类型的变量，则将此变量保存的数据值传递出去；如果是引用数据类型的变量，则将此变量保存的地址值传递出去
	- 方法的参数的传递机制：值传递机制
	- 如果形参是基本数据类型的变量，则将实参保存的数据值赋给形参；如果形参是引用数据类型的变量，则将实参保存的地址值赋给形参
4. 递归方法
   - 方法自己调用自己的现象就称为递归
   - 递归方法分类：直接递归、间接递归
   - 使用说明：递归方法包含了一种隐式的循环；递归方法会重复执行某段代码，但是这种重复执行无须循环控制；递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环，最终发生栈内存溢出
   - 递归调用会占用大量的系统堆栈，内存耗用多，在递归调用层次多时速度要比循环慢的多，所以在使用递归时要慎重；在要求高性能的情况下尽量避免使用递归，递归调用既花时间又耗内存，考虑使用循环迭代

# 五、关键字的使用

### 一、package关键字的使用

1. 说明：
   - package：包
   - package用于指明该文件中定义的类、接口等结构所在的包
   - 一个源文件只能有一个声明包的package语句
   - package语句作为Java源文件的第一条语句出现，若缺省该语句，则指明为无名包
   - 包名，属于标识符，满足标识符命名的规则和规范（全部小写）、见名知意。
   - 包通常使用所在公司域名的倒置，如com.sun.xxx
   - 包对应于文件系统的目录，package语句中使用“.”来指明包（目录）的层次，每“.”一次就表示一层文件目录
   - 同一个包下可以声明多个结构（类、接口），但是不能定义同名的结构（类、接口）。不同的包下可以定义同名的结构（类、接口）
2. 包的作用
   - 包可以包含类和子包，划分项目层次，便于管理
   - 帮助管理大型软件系统：将功能相近的类划分到同一个包中
   - 帮助解决类命名冲突的问题
   - 控制访问权限

### 二、import关键字的使用

1. 为了使用定义在其他包中的Java类，需要使用import语句来显示引入指定包下所需的类。相当于import语句告诉编译器到哪里去寻找这个类
2. 注意事项：
   - import语句，声明在包的声明和类的声明之间
   - 如果需要导入多个类或接口，那么就并列显示多个import语句即可
   - 如果使用a.*导入结构，表示可以导入a包下的所有的结构，但是不包括子包下结构（类或接口）
   - 如果导入的类或接口是java.lang包下的，或者是当前包下的，则可以省略此import语句
   - 如果已经导入java.a包中的类，那么如果需要使用a包的子包下的类的话仍需要导入（包中包）
   - 如果在代码中使用不同包下的同名的类，那么就需要使用类的全类名的方式指明调用的是哪个类
   - import static组合的使用：调用指定类或接口下的静态属性或方法

### 三、this关键字的使用

1. this的定义

   - this在方法（实例方法或者说是非static的方法）内部使用，表示调用该方法的对象。用于创建好的对象
   - this在构造器内部使用，表示该构造器正在初始化的对象。用于正在创建的对象

2. this的使用

   - this可以调用的结构有成员变量、方法和构造器

3. this调用属性和方法

   - 针对方法内的使用情况（准确的说是非static修饰的方法），一般情况我们通过对象a调用方法，可以在方法内调用当前对象a的属性或其他方法。此时，我们可以在属性和其他方法前使用“this.”，表示当前属性或方法所属的对象a，但是，一般情况下，我们都选择省略此“this.”结构
   - 针对方法内的使用情况（准确的说是非static修饰的方法），特殊情况下如果方法的形参与对象的属性同名了，则必须使用“this.”进行区分，修饰的变量即为属性（或者说是成员变量）。没有使用this.修饰的变量即为局部变量

4. 构造器中使用this

   - 一般情况，我们通过构造器创建对象时，可以在构造器内调用当前正在创建的对象的属性或方法。此时，我们可以在属性或方法前使用“this.”，表示当前属性或方法所属的对象。但是，一般情况下，我们都选择省略此“this."结构

   - 特殊情况，如果构造器的形参与正在创建的对象的属性同名了，我们必须使用“this.”进行区分。使用this,修饰的变量即为属性（或者说是成员变量）。没有使用this.修饰的变量，即为局部变量

   - 如果一个类中声明了n个构造器，则最多有（n-1）个构造器可以声明在this(形参列表)的结构

   - 构造器调用构造器的使用

     ```java
     // this调用构造器
     // 格式：this(形参列表)
     // 可以在类的构造器中，调用当前类中指定的其他构造器
     // 要求：this(形参列表)必须声明在当前构造器的首行，且在同一个构造器中最多声明一次
     
     public class User{
         
         private String name;
         
         private String sex;
         
         // 无参构造器
         public User(){}
         
         // 有参构造器
         public User(String name){
             // 调用无参构造器
             this();
         }
         
          // 有参构造器
         public User(String name,String sex){
             // 调用无参构造器
             this(name);
             this.sex = sex
         }
     }
     ```

### 四、super关键字的使用

1. super的理解：可以调用父类的属性、方法和构造器
2. super调用属性、方法
   - 子类继承父类以后，就可以在子类的方法或构造器中，调用父类声明的属性或方法。（满足封装性的前提下）调用时，需要使用“super.”的结构，表示调用父类的属性或方法
   - 一般情况下，我们可以考虑省略“super.”的结构。但是，如果出现子类重写了父类的方法或子父类中出现了同名的属性时，则必须使用“super.”的声明，显示地调用父类被重写的方法或父类中声明的同名的属性
3. super调用构造器
   - 子类继承父类时，不会继承父类的构造器。只能通过“super(形参列表)”的方式调用父类指定的构造器
   - super(形参列表)必须声明在构造器的首行
   - 在构造器的首行，this(形参列表)和super(形参列表)只能二选一
   - 如果在子类构造器中既没有显示地调用this(形参列表)和super(形参列表)，则子类此构造器默认调用super()，即调用父类中空参的构造器
   - 子类的任何一个构造器中，要么会调用本类中重载的构造器，要么会调用父类的构造器，只能是这两种情况之一
   - 如果一个类中声明了n个构造器，则最多有（n-1）个构造器可以声明在this(形参列表)的结构，则剩下的那个一定使用super(形参列表)
   - 在通过子类的构造器创建对象时，一定在调用子类构造器的过程中，直接或间接的调用父类的构造器。也正因为调用父类的构造器，才会将父类中声明的属性或方法加载到内存中，供子类对象使用
4. 无论是this还是super都是逐层的往上找属性或方法，也就是就近原则。this是从本层级找，本层级找不到则找父类，以此类推；super是从父类开始找，父类找不到则找父类的父类，以此类推

# 六、封装性

### 一、封装的意义和实现

- 高内聚，低耦合：内聚指一个模块内各个元素彼此结合的紧密程度；耦合指一个软件结构内不同模块之间互连程度的度量。内聚意味着重用和独立，耦合意味着牵一发动全身。高内聚指的是类的内部数据操作细节自己完成，不允许外部干涉；低耦合仅暴露少量的方法给外部使用，尽量方便外部调用
- 实现封装就是控制类或成员的可见性范围，需要依赖访问控制修饰符，也称为权限修饰符来控制

### 二、权限修饰符

- 四种权限修饰符：private、缺省、protected、public

- 权限修饰符作用：使用四种修饰符来修饰类及类的内部信息。当这些成员被调用时，体现可见性的大小

- 权限修饰符具体修饰的结构：外部类使用public和缺省修饰；成员变量、成员方法、构造器、成员内部类使用public、protected、缺省、private修饰

- 权限修饰符范围

  |  修饰符   | 本类内部 | 本包内 | 其他包的子类 | 其他包非子类 |
  | :-------: | :------: | :----: | :----------: | :----------: |
  |  private  |   可以   | 不可以 |    不可以    |    不可以    |
  |   缺省    |   可以   |  可以  |    不可以    |    不可以    |
  | protected |   可以   |  可以  |     可以     |    不可以    |
  |  public   |   可以   |  可以  |     可以     |     可以     |

### 三、封装性的体现

- 私有化（private）类的属性，提供公共（public）的get和set方法，对此属性进行获取或修改
- 将类中不需要对外暴露的方法，设置为private
- 单例模式中构造器private的，避免在类的外部创建实例

# 七、继承性

### 一、继承的理解

1. 自上而下：定义了一个类A，在定义另一个类B时，发现类B的功能与A相似，考虑类B继承于A
2. 自下而上：定义了类B、C、D等，发现B、C、D有类似的属性和方法，则可以考虑将相同的属性和方法进行抽取，封装到类A中，让类B、C、D继承于类A，同时，B、C、D中的相似功能可以删除掉了

### 二、继承的好处

1. 继承的出现减少了代码冗余，提高了代码的复用性
2. 继承的出现，更有利于功能的扩展
3. 继承的出现让类与类之间产生了is-a的关系，为多态的使用提供了前提。继承描述事物之间的所属关系，这种关系是is-a的关系。可见，父类更通用、更一般，子类更具体

### 三、继承的格式

1. 类A：父类、superClass类、超类、基类
2. 类B：子类、subClass类、派生类

```java
class A(
	//属性、方法
)
    
class B extends A{
    // 属性、方法
}
```

### 四、继承的特点

- 继承过程中子类获取到父类中声明的所有属性和方法
- 由于封装性的影响，子类可能不能直接调用父类中声明的属性或方法
- 子类继承父类以后，还可以扩展自己特有的功能（体现，增加特有的属性、方法）
- 不要为了继承而继承，在继承之前，判断一下是否有is-a的关系
- Java中声明的类，如果没有显示的声明其父类时，则默认继承于java.lang.Object
- Java支持多层继承（继承体系）。子类和父类的概念是相对的，有直接父类和间接父类
- Java类只支持单继承，不支持多重继承
- 一个父类可以同时拥有多个父类

### 五、方法重写 （override）

- 重写的含义：子类对父类继承过来的方法进行的覆盖、覆写操作就称为方法的重写。类的属性不能重写，只是重新定义一个新的属性，名称相同而已

- 重写的规则：理解为子类中方法的权限修饰符、返回值类型（引用数据类型）、抛出异常范围都变大或相等

  ```
  Ⅰ 父类被重写的方法与子类重写的方法的方法名和形参列表必须相同；
  
  Ⅱ 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符。子类不能重写父类中声明为private权限修饰符的方法；
  
  Ⅲ 关于返回值类型：
  	1、父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型必须是void
  	2、父类被重写的方法的返回值类型是基本数据类型，则子类重写的方法的返回值类型必须与被重写的方法的返回值		  类型相同
  	3、父类被重写的方法的返回值类型是引用数据类型（比如类），则子类重写的方法的返回值类型可以与被重写的方		  法的返回值类型相同 或 是被重写的方法的返回值类型的子类
  
  Ⅳ 异常问题：子类重写的方法抛出的异常类型可以父类被重写的方法抛出的异常类型相同，或是父类被重写的方法抛出	的异常类型的子类
  
  Ⅴ 重写的方法体无要求
  ```

# 八、多态性

# 九、构造器

#### 一、构造器的作用

- 搭配new关键字，创建类的对象
- 在创建对象的同时，可以给对象的相关属性赋值

### 二、构造器的使用说明

- 构造器声明的格式：权限修饰符 类名(形参列表){构造体}
- 创建类以后，在没有显示提供任何构造器的情况下，系统会默认提供一个空参的构造器，且默认造器的权限与类声明的权限相同
- 一旦类中显示声明了构造器，则系统不再提供默认的空参构造器，除非自己再声明一个空参的构造器
- 一个类中可以声明多个构造器，彼此之间构成重载

# 十、类中属性、JavaBean、UML

### 一、类中属性（实例变量为例子）赋值过程

1. 在类中的属性中，给属性赋值的位置：

   - 默认赋值
   - 显示赋值
   - 构造器赋值
   - 通过“对象.方法”的方式赋值
   - 通过“对象.属性”的方式赋值

2. 赋值的先后执行顺序

   默认赋值 -> 显示赋值 -> 构造器赋值 -> 通过“对象.方法”的方式赋值/通过“对象.属性”的方式赋值

3. 赋值过程在对象创建过程中可以执行的次数

   - 只执行一次：默认赋值、显示赋值、构造器赋值
   - 可以执行多次：通过“对象.方法”的方式赋值、通过“对象.属性”的方式赋值

### 二、JavaBean

- JavaBean是一种Java语言写成的可重用组件
- JavaBean标准：类是公共的；有一个无参的公共的构造器；有属性且有对应的get、set方法

### 三、UML类图

- UML（统一建模语言），用来描述软件模型和架构的图形化语言

- 常用的UML工具软件有PowerDesinger、Rose和Enterprice Architect

- UML工具软件不仅可以绘制开发中所需的各种图表，还可以生成对应的源代码

- 在软件开发过程中，使用UML类图可以更加直观地描述类内部结构（类的属性和操作）以及类之间的关系（如关系、依赖、聚合等）

  ```
  +表示public类型，-表示private类型，#表示protected类型，不写就是缺省类型
  属性的写法为：属性的权限(+、-)：属性名称：属性的类型
  方法的写法为：方法的权限(+、-) 方法名(参数名：参数类型)：返回值类型。若方法有下划线则代表是构造器
  斜体表示抽象方法或类
  继承：实现箭头指向的是父类
  ```

