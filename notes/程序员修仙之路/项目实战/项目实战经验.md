# 一、工具类的使用

## 一、Hutool工具包HttpRequest

1. 请求头的封装

   ```java
   Map<String,String> headerMap = new HashMap<>();
   headerMap.put("headerKey1","headerValue1");
   headerMap.put("headerKey2","headerValue2");
   headerMap.put("Content-Type","application/json");
   ```

2. 请求参数的封装（JSON格式参数）

   ```java
   JSONObject bodyJSON = new JSONObject();
   bodyJSON.put("param", "value");
   ```

3. 接口的调用

   ```java
   String result = HttpRequest.post("url").headerMap(headerMap, true).body(bodyJSON.toString()).execute().body();
   ```

4. 返回值的格式

   ```json
   {
   	"code": 0,
   	"data": {
   		"hikInfo": null,
   		"infos": [{
   			"protocol": "hls",
   			"deviceName": "结构施工作业面施工情况",
   			"url": "",
   			"channelId": "145",
   			"heart": true,
   			"cameraIndexCode": null
   		}]
   	},
   	"msg": "ok",
   	"path": null,
   	"extra": null,
   	"timestamp": "1719973588578",
   	"errorMsg": "",
   	"isSuccess": true
   }
   ```

5. 接口返回值的处理。使用`com.alibaba.fastjson`依赖包

   ```java
   JSONObject jsonObject = JSON.parseObject(result);
   // 具体要看接口返回值包含哪些，假设包含code，则使用如下获取
   Integer code = jsonObject.getInteger("code");
   
   // 获取内置的JSON
   JSONObject data = jsonObject.getJSONObject("data");
   
   // 获取JSON中某个字符串类型的字段
   String hikInfo = data.getString("hikInfo");
   
   // 获取JSON中的数组，也可以转为自定义类
   JSONArray infosArray = data.getJSONArray("infos");
   List<Map> infoList = infosArray.toJavaList(Map.class);
   ```

## 二、Logger日志的使用

1. ` @Slf4j `是` private final Logger log = LoggerFactory.getLogger(XYZ.class); `的简写版

   - 引入jar依赖包

     ```xml
     <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-log4j12</artifactId>
        <version>1.7.30</version>
     </dependency>
     ```

   - 使用方式

     ```java
     // import对应的信息：
     import org.slf4j.Logger;
     import org.slf4j.LoggerFactory;
     
     // XXX.class即在哪个类中使用的就用哪个类的.class
     private static final Logger logger = LoggerFactory.getLogger(XXX.class);
     
     // 或者使用注解的方式
     @Slf4j
     public class Controller {
         public String getInfo() {
             log.info("日志信息：{}","填充{}内容字符串");
         }
     }
     ```

   - log4j.properties配置文件 

     ```properties
     ### 设置###
     log4j.rootLogger = debug,stdout,D,E
      
     ### 输出信息到控制抬 ###
     log4j.appender.stdout = org.apache.log4j.ConsoleAppender
     log4j.appender.stdout.Target = System.out
     log4j.appender.stdout.layout = org.apache.log4j.PatternLayout
     log4j.appender.stdout.layout.ConversionPattern = [%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} method:%l%n%m%n
      
     ### 输出DEBUG 级别以上的日志到=E://logs/error.log ###
     log4j.appender.D = org.apache.log4j.DailyRollingFileAppender
     log4j.appender.D.File = E://logs/log.log
     log4j.appender.D.Append = true
     log4j.appender.D.Threshold = DEBUG 
     log4j.appender.D.layout = org.apache.log4j.PatternLayout
     log4j.appender.D.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n
      
     ### 输出ERROR 级别以上的日志到=E://logs/error.log ###
     log4j.appender.E = org.apache.log4j.DailyRollingFileAppender
     log4j.appender.E.File =E://logs/error.log 
     log4j.appender.E.Append = true
     log4j.appender.E.Threshold = ERROR 
     log4j.appender.E.layout = org.apache.log4j.PatternLayout
     log4j.appender.E.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n
     ```

     ```tex
     %m   输出代码中指定的消息
     %p   输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL 
     %r   输出自应用启动到输出该log信息耗费的毫秒数 
     %c   输出所属的类目，通常就是所在类的全名 
     %t   输出产生该日志事件的线程名 
     %n   输出一个回车换行符，Windows平台为“/r/n”，Unix平台为“/n” 
     %d   输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy-MM-dd HH\:mm\:ss}，输出类似:2015-12-09 22:05:36  
     %l   输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：TestLog4j:16
     ```

2. logback

   - 引入jar依赖包

     ```xml
     <dependencies>
         <!-- https://mvnrepository.com/artifact/ch.qos.logback/logback-classic -->
         <dependency>
             <groupId>ch.qos.logback</groupId>
             <artifactId>logback-classic</artifactId>
             <version>1.2.3</version>
         </dependency>
      
     </dependencies>
     ```

   - 使用方式

     ```java
     // import对应的信息：
     import org.slf4j.Logger;
     import org.slf4j.LoggerFactory;
     
     // XXX.class即在哪个类中使用的就用哪个类的.class
     private static final Logger logger = LoggerFactory.getLogger(XXX.class);
     
     // 或者使用注解的方式
     @Slf4j
     public class Controller {
         public String getInfo() {
             log.info("日志信息");
         }
     }
     ```

   - logback.xml配置文件

     ```xml
     <?xml version="1.0" encoding="UTF-8"?>
     <configuration>
         <!-- 日志存放路径 -->
         <property name="log.path" value="/data/sunsh/logs" />
         <!-- 日志输出格式 -->
     	<property name="log.pattern" value="%d{HH:mm:ss.SSS} [%thread] %-5level %logger{20} - [%method,%line] - %msg%n" />
     	<!-- 控制台输出 -->
     	<appender name="console" class="ch.qos.logback.core.ConsoleAppender">
     		<encoder>
     			<pattern>${log.pattern}</pattern>
     		</encoder>
     	</appender>
     	<!-- 系统日志输出 -->
     	<appender name="file_info" class="ch.qos.logback.core.rolling.RollingFileAppender">
     	    <file>${log.path}/sys-info.log</file>
             <!-- 循环政策：基于时间创建日志文件 -->
     		<rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"
                 <!-- 日志文件名格式 -->
     			<fileNamePattern>${log.path}/sys-info.%d{yyyy-MM-dd}.log</fileNamePattern>
     			<!-- 日志最大的历史 60天 -->
     			<maxHistory>60</maxHistory>
     		</rollingPolicy>
     		<encoder>
     			<pattern>${log.pattern}</pattern>
     		</encoder>
     		<filter class="ch.qos.logback.classic.filter.LevelFilter">
                 <!-- 过滤的级别 -->
                 <level>INFO</level>
                 <!-- 匹配时的操作：接收（记录） -->
                 <onMatch>ACCEPT</onMatch>
                 <!-- 不匹配时的操作：拒绝（不记录） -->
                 <onMismatch>DENY</onMismatch>
             </filter>
     	</appender>
     	<appender name="file_error" class="ch.qos.logback.core.rolling.RollingFileAppender">
     	    <file>${log.path}/sys-error.log</file>
             <!-- 循环政策：基于时间创建日志文件 -->
             <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
                 <!-- 日志文件名格式 -->
                 <fileNamePattern>${log.path}/sys-error.%d{yyyy-MM-dd}.log</fileNamePattern>
     			<!-- 日志最大的历史 60天 -->
     			<maxHistory>60</maxHistory>
             </rollingPolicy>
             <encoder>
                 <pattern>${log.pattern}</pattern>
             </encoder>
             <filter class="ch.qos.logback.classic.filter.LevelFilter">
                 <!-- 过滤的级别 -->
                 <level>ERROR</level>
     			<!-- 匹配时的操作：接收（记录） -->
                 <onMatch>ACCEPT</onMatch>
     			<!-- 不匹配时的操作：拒绝（不记录） -->
                 <onMismatch>DENY</onMismatch>
             </filter>
         </appender>
     	<!-- 用户访问日志输出  -->
         <appender name="sys-user" class="ch.qos.logback.core.rolling.RollingFileAppender">
     		<file>${log.path}/sys-user.log</file>
             <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
                 <!-- 按天回滚 daily -->
                 <fileNamePattern>${log.path}/sys-user.%d{yyyy-MM-dd}.log</fileNamePattern>
                 <!-- 日志最大的历史 60天 -->
                 <maxHistory>60</maxHistory>
             </rollingPolicy>
             <encoder>
                 <pattern>${log.pattern}</pattern>
             </encoder>
         </appender>
     	<!-- 系统模块日志级别控制  -->
     	<logger name="com.ruoyi" level="info" />
     	<!-- Spring日志级别控制  -->
     	<logger name="org.springframework" level="warn" />
     	<root level="info">
     		<appender-ref ref="console" />
     	</root>	
     	<!--系统操作日志-->
         <root level="info">
             <appender-ref ref="file_info" />
             <appender-ref ref="file_error" />
         </root>
     	<!--系统用户操作日志-->
         <logger name="sys-user" level="info">
             <appender-ref ref="sys-user"/>
         </logger>
     </configuration> 
     ```

# 二、Linux部署

## 一、防火墙

```shell
# 开启防火墙
systemctl start firewalld.service
# 关闭防火墙
systemctl stop firewalld.service
# 禁止防火墙开机启动
systemctl disable firewalld.service
# 查询端口是否开放
firewall-cmd --query-port=8080/tcp
# 放行端口和http
firewall-cmd --add-service=http --permanent 
firewall-cmd --zone=public --add-port=80/tcp --permanent
# 重启防火墙
firewall-cmd --reload
```

## 二、Linux环境设置

```shell
#设置服务器的名称
hostnamectl set-hostname <主机名> --static


#与网络时间保持同步。安装时间同步工具chrony
yum install chrony

#执行以下命令启动chrony，并设置为开机自启
systemctl start chronyd
systemctl enable chronyd

#查看时间源
chronyc sources

#配置新的时间源
可修改`vim /etc/chrony.conf`以增加新的时间源


#关闭SElinux
#打开配置文件
vim /etc/selinux/config

#在/etc/selinux/config中修改如下内容
SELINUX=disabled

#重启操作系统
reboot
```

## 三、Linux静态网络设置

```shell
# CentOS7中打开文件
vim /etc/sysconfig/network-scripts/ifcfg-ens33


#编辑以下内容
BOOTPROTO="static" 
#IP 的配置方法[none|static|bootp|dhcp]（引导 时不 使用协议|静态分配 IP|BOOTP 协议|DHCP 协议）

ONBOOT="yes" 
#系统启动的时候网络接口是否有效（yes/no）

#IP地址
IPADDR=192.168.2.100 #网段必须符合要求，后面的主机地址自己设置
#网关
GATEWAY=192.168.2.2 #网关要和vm8虚拟交换机网关一样
#域名解析器
DNS1=192.168.2.2  #这个设置成和网关一样就行

#子网掩码默认255.255.255.0
 
 
#重启网络服务
service network restart
 
 
#可能遇到的问题
#物理机能ping通虚拟机，但是虚拟机ping不通物理机，一般都是因为物理机的防火墙问题，把防火墙关闭就行
#虚拟机能ping通物理机，但是虚拟机ping不通外网，一般都是因为DNS的设置有问题
#虚拟机 ping www.baidu.com 显示域名未知等信息，一般查看GATEWAY和DNS设置是否正确
#如果以上全部设置完还是不行，需要关闭NetworkManager服务
	#systemctl stop NetworkManager：关闭
	#systemctl disable NetworkManager：禁用
#如果检查发现systemctl status network有问题，需要检查ifcfg-ens33
```

## 四、Linux下安装Redis

1. 安装方式采用yum在线安装，安装版本为`redis-7.0.14`

2. 下载yum仓库。Redis所在的仓库为remi-release

   ```shell
   wget http://rpms.famillecollet.com/enterprise/remi-release-7.rpm
   ```

3. 安装yum仓库 

   ```shell
   rpm -ivh remi-release-7.rpm --force --nodeps
   ```

4. 安装Redis。`--enablerepo`选项的作用为启用一个仓库 

   ```shell
   yum --enablerepo=remi -y install redis-7.0.14
   ```

5. 配置Redis允许远程访问。Redis服务默认只允许本地访问，若需要进行远程访问，需要做出以下配置

   ```shell
   vim /etc/redis/redis.conf
   
   #修改如下参数
   #监听所有网络接口，默认只监听localhost
   bind 0.0.0.0
   
   #关闭保护模式，默认开启。开始保护模式后，远程访问必须进行认证后才能访问。
   protected-mode no
   
   #其他的设置，例如账号和密码也可设置
   ```

6. 启动Redis

   ```shell
   #启动Redis
   systemctl start redis
   
   #查看Redis的运行状态
   systemctl status redis
   
   #设置Redis开机自启
   systemctl enable redis
   ```

## 五、Linux下安装MinIO

1. 获取MinIO安装包

   ```shell
   wget https://dl.min.io/server/minio/release/linux-amd64/archive/minio-20230809233022.0.0.x86_64.rpm
   ```

2. 安装MinIO

   ```shell
   rpm -ivh minio-20230809233022.0.0.x86_64.rpm
   ```

3. 将MinIO集成于Systemd

   - 修改配置文件。一般Systemd的配置文件都在 `/etc/systemd/system/`或者`/usr/lib/systemd/system/` 目录下

     ```shell
     vim /etc/systemd/system/minio.service
     ```

   - 修改内容

     ```properties
     [Unit]
     Description=MinIO
     Documentation=https://min.io/docs/minio/linux/index.html
     Wants=network-online.target
     After=network-online.target
     AssertFileIsExecutable=/usr/local/bin/minio
     
     [Service]
     WorkingDirectory=/usr/local
     ProtectProc=invisible
     EnvironmentFile=-/etc/default/minio
     ExecStartPre=/bin/bash -c "if [ -z \"${MINIO_VOLUMES}\" ]; then echo \"Variable MINIO_VOLUMES not set in /etc/default/minio\"; exit 1; fi"
     ExecStart=/usr/local/bin/minio server $MINIO_OPTS $MINIO_VOLUMES
     Restart=always
     LimitNOFILE=65536
     TasksMax=infinity
     TimeoutStopSec=infinity
     SendSIGKILL=no
     
     [Install]
     WantedBy=multi-user.target
     ```

4.  编写`EnvironmentFile`文件 

   ```shell
   #打开配置文件
   vim /etc/default/minio
   
   #添加文档内容
   # MINIO_ROOT_USER and MINIO_ROOT_PASSWORD sets the root account for the MinIO server.
   # This user has unrestricted permissions to perform S3 and administrative API operations on any resource in the deployment.
   # Omit to use the default values 'minioadmin:minioadmin'.
   # MinIO recommends setting non-default values as a best practice, regardless of environment
   
   #账号密码可自行修改。
   #MINIO_ROOT_USER和MINIO_ROOT_PASSWORD为用于访问MinIO的用户名和密码，密码长度至少8位
   MINIO_ROOT_USER=minioadmin
   MINIO_ROOT_PASSWORD=minioadmin
   
   # MINIO_VOLUMES sets the storage volume or path to use for the MinIO server.
   
   #需要自行创建资源保存的路径并设置权限为读写，chmod 777 /mnt/data
   MINIO_VOLUMES="/mnt/data"
   
   # MINIO_OPTS sets any additional commandline options to pass to the MinIO server.
   # For example, `--console-address :9001` sets the MinIO Console listen port
   #MINIO_OPTS中的console-address，用于指定管理页面的地址
   MINIO_OPTS="--console-address :9001"
   ```

5. 启动MinIO

   ```shell
   #启动MinIO
   sudo systemctl start minio.service
   
   #查询运行状态
   sudo systemctl status minio.service
   journalctl -f -u minio.service
   
   #设置MinIO开机自启
   systemctl enable minio
   ```

6. 访问MinIO管理页面

   - 管理页面的访问地址为：`http://192.168.10.101:9001`
   - `9000`为MinIO的API的默认端口，配置的`9001`为管理页面端口
   - `ip`需要根据实际情况做出修改

7. 如果访问不到页面和上传的资源，可能是防火墙导致的 

   ```shell
   firewall-cmd --zone=public --add-port=9000/tcp --permanent
   
   firewall-cmd --zone=public --add-port=9001/tcp --permanent
   
   firewall-cmd --reload
   ```

## 六、Linux下安装MySQL8

1. 下载yum库 

   ```
   wget https://dev.mysql.com/get/mysql80-community-release-el7-9.noarch.rpm
   ```

2. 安装yum库

   ```shell
   rpm -ivh mysql80-community-release-el7-9.noarch.rpm
   ```

3. 配置国内镜像。修改`/etc/yum.repo.d/mysql-community.repo`文件中的`[mysql80-community]`中的`baseUrl`参数 

   ```shell
   [mysql80-community]
   name=MySQL 8.0 Community Server
   baseurl=https://mirrors.tuna.tsinghua.edu.cn/mysql/yum/mysql-8.0-community-el7-$basearch/
   enabled=1
   gpgcheck=1
   gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql-2022
          file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysql
   ```

4. 安装MySQL

   ```shell
   yum install -y mysql-community-server
   
   #这种方式更好
   yum install mysql-server --nogpgcheck
   ```

5. 启动MySQL

   ```shell
   #启动MySQL服务
   systemctl start mysqld
   
   #查看MySQL运行状态
   systemctl status mysqld
   ```

6. MySQL用户相关配置

   - 查看root用户初始化密码。MySQL启动后会将root用户的初始密码写入日志，通过以下命令可以获取密码 

     ```shell
     cat /var/log/mysqld.log | grep password
     ```

   - 使用初始密码登录 

     ```shell
     mysql -uroot -p'password'
     ```

   - 修改root用户密码。MySQL默认安装了validate_password插件，默认情况下，要求密码要包含大写字母、小写字母、数字和特殊符号，且密码长度最小为8。若需设置简单密码，可禁用该插件，或调整该插件的密码强度级别 

     ```shell
     ALTER USER 'root'@'localhost' IDENTIFIED BY 'Sunsh.282127';
     ```

   - 授予root用户远程登录权限 

     ```shell
     CREATE USER 'root'@'%' IDENTIFIED BY 'Sunsh.282127';
     GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' WITH GRANT OPTION;
     FLUSH PRIVILEGES;
     ```

## 七、Linux下安装JDK17

1. 获取JDK安装包

   ```shell
   wget https://download.oracle.com/java/17/archive/jdk-17.0.8_linux-x64_bin.tar.gz
   ```

2. 解压JDK安装包到`/opt`目录下

   ```shell
   tar -zxvf jdk-17.0.8_linux-x64_bin.tar.gz -C /opt
   ```

3. 测试JDK安装效果

   ```shell
   /opt/jdk-17.0.8/bin/java -version
   ```

4. 后端代码使用IDEA的maven插件对项目进行打包，可以指定打包名称。将打包好的jar包上传到`/opt/lease`目录下，若目录不存在，自行创建即可

   ```xml
   <build>
   	<finalName>web-app</finalName>
   </build>
   ```

5. 集成Systemd。例如，创建`lease-app.service`文件 

   ```shell
   #创建文件
   vim /etc/systemd/system/lease-app.service
   
   #添加文件内容
   [Unit]
   Description=lease-app
   After=syslog.target
   
   [Service]
   User=root
   ExecStart=/opt/jdk-17.0.8/bin/java -jar /opt/lease/web-app 1>/opt/lease/app.log 2>&1
   SuccessExitStatus=143
   
   [Install]
   WantedBy=multi-user.target
   ```

6. 启动项目

   ```shell
   systemctl start lease-app
   ```

## 八、Linux下安装Nginx并部署单体服务

1. 创建`/etc/yum.repos.d/nginx.repo`文件并新增内容

   ```shell
   #创建源文件
   vim /etc/yum.repos.d/nginx.repo
   
   #新增内容
   [nginx-stable]
   name=nginx stable repo
   baseurl=http://nginx.org/packages/centos/$releasever/$basearch/
   gpgcheck=1
   enabled=1
   gpgkey=https://nginx.org/keys/nginx_signing.key
   module_hotfixes=true
   
   [nginx-mainline]
   name=nginx mainline repo
   baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/
   gpgcheck=1
   enabled=0
   gpgkey=https://nginx.org/keys/nginx_signing.key
   module_hotfixes=true
   ```

2. 在线安装

   ```shell
   yum -y install nginx
   ```

3. 启动Nginx

   ```shell
   #启动Nginx
   systemctl start nginx
   
   #查看Nginx
   systemctl status nginx
   
   #开机自启
   systemctl enable nginx
   ```

4. 访问Nginx服务默认首页。http://localhost  

5. 可以在Window系统中模拟域名映射，也可在阿里官网申请域名。Windows的域名映射配置文件位于`C:\Windows\System32\drivers\etc\hosts`，需要使用管理员身份修改。使用管理员身份运行任意文本编辑器，然后使用其打开`hosts`文件，并增加如下内容：

   ```shell
   <域名真实地址IP（可以为Nginx所在服务器）> <域名1> <域名2>
   #示例
   192.168.10.102 lease.sunsh.com admin.lease.sunsh.com
   ```

6. 后端代码使用IDEA的maven插件对项目进行打包，可以指定打包名称

   ```xml
   <build>
   	<finalName>app</finalName>
   </build>
   ```

7. 前端代码修改 `.env.production`文件中`VITE_APP_BASE_URL`环境变量的值，换成调用接口服务器的IP或域名

   ```nginx
   VITE_APP_BASE_URL='http://lease.sunsh.com'
   ```

8. 前端构建项目命令。观察项目的根目录是否出现`dist`目录 

   ```vue
   npm run build
   ```

9. 将前端项目编译得到`dist`文件上传至Nginx所在服务器的`/usr/share/nginx/html/app`目录下， 最终的目录结构为 

   ```
   /usr
   └── share
       └── nginx
           └── html
               └── app
                   ├── static
                   └── index.html
                   └── ...              
   ```

10. 创建`/etc/nginx/conf.d/app.conf`文件。`nginx.conf`通过` include /etc/nginx/conf.d/*.conf`引入了`/etc/nginx/conf.d`目录下的所有`.conf`文件 

    ```nginx
    #创建文件
    vim /etc/nginx/conf.d/app.conf
    
    #添加内容
    server {
        #主机端口号
        listen       80; 
        #主机域名
        server_name  lease.sunsh.com;
        
        #/的意思就是代理所有的请求，但是由于nginx匹配遵循最长匹配规则，
        #而且下面配置了/app接口的代理，
        #所以此location会匹配除了/app开头之外的所有接口和静态资源
        location / {
            root   /usr/share/nginx/html/app;
            index  index.html;
        }
        #/app的意思就是代理http://192.168.10.101:8081/中所有以/app开头的请求
        location /app {
            proxy_pass http://192.168.10.101:8081;
        }
    }
    ```

11.  重新加载Nginx配置文件

    ```shell
    systemctl reload nginx
    ```

12. 访问项目： http://lease.sunsh.com

## 九、Linux下安装Nacos

1. 以安装nacos1.1.4为例

2. 在某个目录中下载nacos的压缩包，[下载连接](https://github.com/alibaba/nacos/releases)

   ```shell
   wget https://github.com/alibaba/nacos/releases/download/1.1.4/nacos-server-1.1.4.tar.gz
   ```

3. 解压缩

   ```
   tar -zxvf 压缩包名称
   ```

4. 单机模式启动

   ```shell
   sh startup.sh -m standalone
   ```

5. 如果启动报错，错误信息是缺少Java运行时环境，则需要以下操作

   ```bash
   vim ~/.bashrc
   
   #在.bashrc的末尾处添加命令
   export JAVA_HOME=bin目录的父目录全路径
   export PATH=$JAVA_HOME/bin:$PATH
   
   source ~/.bashrc 
   
   sh startup.sh -m standalone
   ```

6. 访问地址为：http://localhost:8848/nacos。默认账号密码均为nacos

## 十、Linux下安装Canal

1. Canal就是一个很好的数据库同步工具。canal是阿里巴巴旗下的一款开源项目，纯Java开发。基于数据库增量日志解析，提供增量数据订阅&消费，目前主要支持了MySQL

2. Canal的原理是基于`mysql binlog`技术，所以一定需要开启 MySQL 的 binlog 写入功能

   ```shell
   # 开启mysql服务
   service mysqld start
   
   # 检查binlog功能是否有开启
   mysql> show variables like 'log_bin';
   
   # 如果显示状态为OFF表示该功能未开启，开启binlog功能
   # 修改 mysql 的配置文件 my.cnf
   vi /etc/my.cnf
   
   # 追加内容：
   log-bin=mysql-bin #binlog文件名
   binlog_format=ROW #选择row模式
   server_id=1 #mysql实例id,不能和canal的slaveId重复
   
   # 重启 mysql：
   service mysqld restart
   
   # mysql中创建用户
   mysql>CREATE USER 'canal'@'%' IDENTIFIED BY '密码';
   mysql>GRANT SHOW VIEW, SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO
   'canal'@'%';
   mysql>FLUSH PRIVILEGES;
   ```

3. 下载安装Canal服务

   ```shell
   # 切换到/opt目录下，新建canal目录
   # 进入canal目录中
   wget https://github.com/alibaba/canal/releases/download/canal-1.1.8-alpha-2/canal.adapter-1.1.8-SNAPSHOT.tar.gz
   
   tar zxvf canal.deployer-1.1.8.tar.gz
   
   # 修改配置文件
   vi conf/example/instance.properties
   
   # 修改内容
   # 需要改成自己的数据库信息
   canal.instance.master.address=192.168.44.132:3306
   
   #需要改成自己的数据库用户名与密码
   
   canal.instance.dbUsername=canal
   canal.instance.dbPassword=canal
   
   #需要改成同步的数据库表规则，例如只是同步一下表
   #canal.instance.filter.regex=.*\\..*
   canal.instance.filter.regex=guli_ucenter.ucenter_member
   ```




