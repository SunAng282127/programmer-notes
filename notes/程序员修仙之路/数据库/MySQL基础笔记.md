# 一、数据库概述

## 一、数据库的作用

- 持久化：把数据保存到可掉电式存储设备中以供之后使用，数据持久化意味着将内存中的数据保存到硬盘上加以固化
- 持久化的主要作用是将内存中的数据存储在关系型数据库中

## 二、数据库与数据库管理系统

1. DB：数据库（Database）：即存储数据的仓库，其本质是一个文件提供。保存了一系列有组织的数据
2. DBMS：数据库管理系统（Database Management System）：一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制。用户通过数据库管理系统访问数据库中表内的数据。MySQL就是数据库管理系统的一种
3. SQL：结构化查询语言（Structured Query Language）：专门用来与数据库通信的语言

## 三、Oracle VS MySQL

1. Oracle更适合大型跨国企业的使用，因为他们对费用不敏感，但是对性能要求以及安全性有更高的要求
2. MySQL由于其体积小、速度块、总体拥有成本低，可处理上千万条记录的大型数据库，尤其是开放源码这一特点，使得很多互联网公司、中小型网站选择使用MySQL作为网站数据库

## 四、RDBMS VS 非RDBMS 

### 一、关系型数据库（RDBMS）

1. 实质
	- 关系型数据库模型是把复杂的数据结构归结为简单的二元关系（即二维表格形式）
	- 关系型数据库以row（行）和列（column）的形式存储数据。这一系列的行和列被称为表（table），一组表组成了一个库（database）
	- 表和表之间的数据记录有关系（relationship）。现实世界中的各种实体以及实体之间的各种联系均用关系模式来表示。关系型数据库，就是建立在关系模型基础上的数据库
	- SQL就是关系型数据库的查询语句
2. 优势
	- 复杂查询：可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询
	- 事物支持：使得对于安全性能很高的数据访问要求得以实现

### 二、非关系型数据库（非RDBMS）

1. 实质
	- 非关系型数据库是基于键值对存储数据，不需要经过SQL层的解析，性能非常高、同时通过减少不常用的功能，进一步提高性能
	- 大部分主流的非关系型数据库都是免费的
2. 分类
	- 键值型数据库：键值型数据库通过key-value键值的方式存储数据，其中key和value可以是简单的对象，也可以是复杂的对象。key作为唯一的标识符，优点是查找速度快，在这方面优于关系型数据库，缺点是无法像关系型数据库一样使用条件过滤，如果不知道去哪里找数据，就要遍历所有的键，这样会消耗大量的计算。键值型数据库典型的使用场景是作为没存缓存。Redis是最流行的键值型数据路
	- 文档型数据库：此类数据库可存放并获取文档，可以是xml、json等格式。再数据库中文档作为处理信息的基本单位，一个文档就相当于一条记录、文档数据库所存放的文档就相当于键值数据库所存放的值。MongoDB是最流行的文档型数据库
	- 搜索引擎数据库：虽然关系型数据库采用了索引提升检索效率，但是针对全文索引效率却很低。搜索引擎数据库是应用再搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检索的时候才能保证性能最优。核心原理是“倒排索引”。Elasticsearch是最流行的搜索引擎数据库
	- 列存数据库：列存数据库是相对于行式存储的数据库，而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的I/O，适合于分布式文件系统，不足在于功能相对有限。HBase是最流行的列式数据库
	- 图形数据库

## 五、关系型数据库设计原则

### 一、设计原则

1. 关系型数据库的典型数据结构就是数据表，这些数据表的组成都是结构化的
2. 将数据放到表中，表再放到库中
3. 一个数据库中可以有多个表，每个表都有一个名字，用来标识自己。表名具有唯一性
4. 表具有一些特性，这些特性定义了数据在表中如何存储，类似于Java中类的设计

### 二、表、记录、字段

1. E-R（entity-relationship，实体-联系）模型中的有三个主要概念是：实体集、属性、联系集
2. 一个实体集（class）对应于数据库中的一个表（table）；一个实体（instance）则对应数据库表中的一行（row），也称为一条记录（record）；一个属性（attribute）对应于数据库表中的一列（column）。也称为一个字段（field）。ORM思想（Object Relational Mapping）体现为：
	- 数据库中一个表	<----->	Java或Python中的一个类
	- 表中的一条数据    <----->     类中的一个对象（或实体）
	- 表中的一个列        <----->     类中的一个字段、属性（field）
3. 表的关联关系
	- 表与表之间的数据记录有关系（relationship）。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示
	- 一对一关联（one-to-one）：外键唯一，主表的主键和从表的外键（唯一），形成主外键关系，外键唯一；外键是主键，主表的主键和从表的主键，形成主外键关系
	- 一对多关系（one-to-many）：在从表（多方）创建一个字段，字段作为外键指向主表（一方）的主键
	- 多对多关系（many-to-many）：要表示多对多关系，必须创建第三个表，该表通常称为联接表，它将多对多关系划分为两个一对多关系。将这两个表的主键都插入到第三个表中
	- 自我引用（Self reference）：一个表通过本表的某个字段关联本表

# 二、MySQL下载安装设置

## 一、MySQL下载地址

[Mysql最新下载地址](https://dev.mysql.com/downloads/mysql/)

## 二、MySQL安装步骤

1. 下载Mysql安装包
2. 如若提示缺少VSCode安装包，在[VSCode下载地址](https://learn.microsoft.com/zh-cn/cpp/windows/latest-supported-vc-redist?view=msvc-170#visual-studio-2015-2017-2019-and-2022)下载安装VS即可
3. 傻瓜式安装即可，换一下安装路径

## 三、MySQL登录

1. mysql的启动与关闭命令

	```mysql
	net start mysql(数据库管理软件名称) // 开启数据库
	net stop mysql(数据库管理软件名称) // 关闭数据库
	```

2. mysql的登录

	```mysql
	mysql -u 用户名 =p直接写密码
	mysql -u 用户名 -P 端口号 -h url主机地址 -p // 端口号和url主机地址是3306和本地的数据库可以省略
	```

## 四、MySQL命令行使用

1. show databases;    查询所有的数据库
2. create database 新的数据库名称;    创建新的数据库
3. drop database 数据库名称;    删除数据库
4. use 数据库名;    使用指定的数据库，才能进行以下操作
5. create table 表名(字段名1 字段类型1,字段名2 字段类型2);    创建新的表
6. drop table 表名;    删除表
7. show create database 创建的数据库名称/创建的表名;    查询创建的数据库或表的创建信息
8. show varibles like 'character_%';    查询数据库中所使用的字符集

# 三、基本的SELECT语句

## 一、SQL分类

1. DDL（Data Definition Languages，数据定义语言），这些语言定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除和修改数据库和数据表的结构。主要语句关键字包含：CREAT、DROP、ALTER、RENAME、TRUNCATE等。DDL的操作一旦执行，就不可回滚
2. DML（Data Manipulation Languages，数据操作语言），用于添加、删除、更新和查询数据库记录，并检查数据完整性。主要语句关键字包含：INSERT、DELETE、UPDATE、SELECT等。DML的操作情况，一旦执行，也是不可回滚的，但是，在执行DML之前，执行了SET autocommit = FALSE，则执行的DML操作就可以实现回滚
3. DCL（Data Control Languages，数据控制语言），用于定义数据库、表、字段、用户的访问权限和安全级别。主要语句关键字包含：GRANT、REVOKE、COMMIT、ROLLBACK、SAVEPOINT等

## 二、SQL语言规则与规范

### 一、基本规则

1. SQL可以写在一行或者多行。为了提高可读性，各子句分别写，必要时使用缩进
2. 每条命令以';'、'\g'、'\G'结束
3. 关键字不能被缩写也不能分行
4. 关于标点符号
	- 必须保证所有的()、单引号、双引号是成对结束的
	- 必须使用英文状态下的半角输入方式
	- 字符串型和日期时间类型的数据可以使用单引号（‘’）表示
	- 列的别名，尽量使用双引号（”“），而且不建议省略as

### 二、SQL大小写规范

1. MySQL在Windows环境下是大小写不敏感的
2. MySQL在Linux环境下是大小写敏感的
	- 数据库名、表名、表的别名、变量名严格区分大小写的
	- 关键字、函数名、列名（或字段名）、列的别名（字段的别名）是忽略大小写的
3. 推荐采用统一的书写规范
	- 数据库名、表名、表别名、字段名、字段别名等都小写
	- SQL关键字、函数名、绑定变量等都大写

### 三、注释

```mysql
单行注释：#注释文字（MySQL特有的方式）
单行注释：-- 注释文字（--后面必须包含一个空格）
多行注释：/* 注释文字 */
```

### 四、命名规则

1. 数据库、表名不得超过30个字符，变量名限制为29个
2. 必须只能包含A-Z、a-z、0-9、_共63个字符
3. 数据库名、表名、字段名等对象名中间不要包含空格
4. 同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名
5. 必须保证字段不能和保留字、数据库系统或常用方法冲突。如果坚持使用，在SQL语句中使用``（着重号）引起来
6. 保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性、假如数据类型在一个表里是整型，那在另一个表里就别变成字符型

## 三、导入SQL文件方式

1. source 文件的全路径名称
2. 基于图形化工具导入

## 四、最基本的SELECT语句

1. SELECT */字段名1，字段名2…… FROM 表名
	- *：表的全字段
	- 若只查询不用表名的数据，则FROM和表名可以省略
2. 列的别名
	- AS：全称alias（别名），可以省略
	- 列的别名可以使用一对”“引起来
3. 去除重复行
	- DISTINCT：去重关键字，去除重复数据
	- DISTINCT关键字要紧跟SELECT，如果后面有多个字段，则去重的规则是每一行所有的字段加起来去掉重复的数据，而不是单独字段去重
4. 空值参与运算
	- 空值：null
	- null不等同于0、''、’null‘
	- null值参与运算时，结果也是null
	- MySQL可以使用IFNULL将null值替换为指定的数据
5. 着重号
	- 字段、表名等自定义的和保留字、数据库系统或常用方法冲突。如果坚持使用，在SQL语句中使用``（着重号）引起来
6. 查询常数
	- 相当于写死数据
7. 显示表结构
	- 使用DESCRIBE或DESC命令+表名，表示表结构
	- 显示表中字段的详细信息
8. 过滤数据
	- 使用WHERE关键字
	- WHERE需要声明在FROM后，ORDER BY之前

# 四、运算符

## 一、算术运算符

1. 加法与减法运算符（+、-）
	- 一个整数类型的值对整数进行加法和减法操作，结果还是一个整数
	- 一个整数类型的值对浮点数进行加法和减法操作，结果是一个浮点数
	- 加法和减法的优先级相同，进行先加后减操作与进行先减后加操作的结果是一样的
	- 在Java中，+的左右两边如果有字符串，那么表示字符串的拼接。但是在MySQL中+只表示数值相加。如果遇到非数值类型，先尝试转成数值，如果转失败，就按0计算。（MySQL中字符串拼接要使用字符串函数CONCAT()实现）
2. 乘法与除法运算符（*、/或div）
	- 一个数乘以整数1和除以整数1后仍得原数
	- 一个数乘以浮点数1和除以浮点数1后变成浮点数，数值与原数相等
	- 一个数除以整数后，不管是否能除尽，结果都为一个浮点数
	- 一个数除以另一个数，除不尽时，结果为一个浮点数，并保留到小数点后4位
	- 乘法和除法的优先级相同，进行先乘后除与先除后乘操作，得出的结果相同
	- 在数学运算中，0不能用作除数，在MySQL中，一个数除以0为NULL
3. 取模运算（%或mode）
	- 取模的正负号取决于被模数的正负号
	- 被模数也就是%前后的数据

## 二、非算术运算符

1. =、<=>、<>或!=、<、<=、>、>=

	- 等于运算符（=）判断等号两边的值、字符串或表达式是否相等，如果相等则返回1，不相等则返回0
	- 如果等号两边的值、字符串或表达式都为字符串，则MySQL会按照字符串进行比较，其比较的是每个字符串中字符的ANSI编码是否相等
	- 如果等号两边的值都是整数，则MySQL会按照整数来比较两个值的大小
	- 如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较
	- 如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL
	- SQL中赋值符号使用:=
	- 安全等于运算符（<=>）与等于运算符（=）的作用是相似的，唯一的区别是<=>可以用来对NULL进行判断。在两个操作数均为NULL时，其返回值为1，而不为NULL；当一个操作数为NULL时，其返回值为0，而不为NULL。安全等于运算符（<=>）为NULL而生。若使用安全等于运算符查询不等于的数据规则为：NOT 字段名 <=> NULL

2. IS NULL、IS NOT NULL、LEAST、GREATEST、BETWEEN AND、ISNULL、IN、NOT IN、LIKE、REGEXP、RLIKE

	- IS NULL：查询某字段是NULL的数据

	- IS NOT NULL：查询某字段不是NULL的数据

	- ISNULL(字段名) 函数：查询某字段是NULL的数据

	- LEAST(多个字段名) 函数：查询多个字段中最小的数据。数值值则按照数值比较大小；如果对比字段的值都为字符串，则MySQL会按照字符串进行比较，其比较的是每个字符串中字符的ANSI编码的大小

	- GREATEST(多个字段名) 函数：查询某字段中最大的数据。数值值则按照数值比较大小；如果对比字段的值都为字符串，则MySQL会按照字符串进行比较，其比较的是每个字符串中字符的ANSI编码的大小

	- BETWEEN 条件1 AND 条件2：查询条件1和条件2范围内的数据，包含边界。条件1为下限；条件2为上限，且不能交换。不在条件1和条件2区间的写法为：字段名 NOT BETWEEN 条件1 AND 条件2，不包含边界

	- IN(set集合)：查询某字段在set集合中的数据

	- NOT IN(set集合)：查询某字段不在set集合中的数据

	- LIKE：模糊查询。%代表不确定个数（0-多个）的字符；_代表一个不确定的字符；\代表转义字符

	- REGEXP\RLIKE：REGEXP运算符用来匹配字符串，语法格式为：expr REGEXP 匹配条件、如果expr满足匹配条件，返回1；如果不满足，则返回0。若expr或匹配条件任意一个为NULL，则结果为NULL

		```mysql
		'^'匹配以该字符后面的字符开头的字符串
		'$'匹配以该字符前面的字符结尾的字符串
		'.'匹配任何一个单字符
		'[...]'匹配在方括号内的任何字符。例如，"[abc]"匹配"a"或"b"或"c"、为了命名字符的范围，使用一个'-'，"[a-z]"匹配任何字母，"[0-9]"匹配任何数字
		'*'匹配零个或多个在它前面的字符。例如，'x*'匹配任何数量的'x'字符，"[0-9]*"匹配任何数量的数字，而"*"匹配任何数量的任何字符
		```

3. 逻辑运算符

	- 逻辑与（AND或&&）：并且条件
	- 逻辑或（OR或||）：选择条件。逻辑与的优先级低于逻辑与
	- 逻辑非（NOT或!）：
	- 逻辑异或（XOR）： 给定的值中任意一个值为NULL时，则返回NULL；  如果两个非NULL的值都是0或者都不等于0时，则返回0；  如果一个值为0，另一个值不为0时，则返回1。相等于两个条件只需满足其中的一个条件即可，两个都满足也不行

4. 位运算符：在二进制数上进行计算的运算符。位运算符会先将操作数变成二进制，然后进行位运算符，最后将计算结果从二进制变成十进制

	- &：按位与（位AND），当给定值对应的二进制位的数值都为1时，则该位返回1，否则返回0 
	- |：按位或（位OR）， 当给定值对应的二进制位的数值有一个或两个为1时，则该位返回1，否则返回0 
	- ^：按位异或（位XOR），当给定值对应的二进制位的数值不同时，则该位返回1，否则返回0 
	- ~：按位取反（）， 给定的值的二进制数逐位进行取反操作，即将1变为0，将0变为1 
	- `>>`：按位右移，右移指定的位数后，右边低位的数值被移出并丢弃，左边高位空出的位置用0补齐，每向y右移动一位数据除以2
	- `<<`：按位左移， 左移指定的位数后，左边高位的数值被移出并丢弃，右边低位空出的位置用0补齐，每向左移动一位数据乘以2

# 五、排序与分页

## 一、排序

1. 如果没有使用排序操作，默认情况下查询语句返回的数据是按照添加数据的顺序显示的
2. 使用ORDER BY进行排序
3. 升序使用ASC，默认升序；降序使用DESC
4. 可以使用列的别名进行排序。列的别名只能在ORDER BY中使用，不能再WHERE中使用
5. WHERE需要声明在FROM后，ORDER BY之前
6. 可以使用不在SELECT列表中的列排序
7. 在对多列进行排序的时候，首先排序的的第一列必须有相同的列值，才会对第二列进行排序。如果第一列数据中所有值都是唯一的，将不再对第二列进行排序
8. SQL的执行顺序
   - 先执行FROM语句
   - 再执行WHERE语句
   - 然后执行SELECT语句
   - 最后执行ORDER BY语句

## 二、分页

1. 使用LIMIT实现数据的分页显示
2. LIMIT 偏移量,条数：偏移量表示从偏移量+1位数据开始查询，查指定条数的数据
3. MySQL8新特性：LIMIT 条数 OFFSET 偏移量
4. 分页公式：每页显示pageSize条记录，此时显示第pageNo页，则公式为LIMIT (pageNo-1)*pageSize,pageSize

# 六、多表查询

## 一、笛卡尔积

1. 笛卡尔积是一个数学运算。假设有两个集合X和Y，那么X和Y的笛卡尔积就是X和Y的所有可能组合，也就是第一个对象来自于X，第二个对象来自于Y的所有可能。组合的个数即为两个集合中元素个数的乘积数

   ```mysql
   -- 此时查询出来的数据条数为sys_user的个数乘以sys_dept的个数，前表每一条数据都与后表每一条数据关联
   SELECT user_id,dept_id
   FROM sys_user,sys_dept
   ```

2. 笛卡尔积称为交叉连接，英文为CROSS JOIN，在SQL中也使用CROSS JOIN进行连接，它的作用就是可以把任意表进行连接，即使这两张表不相关

3. SQL中出现笛卡尔积的情况

   - 省略多个表的连接条件（或关联条件）
   - 连接条件（或关联条件）无效
   - 所有表中的所有行互相连接

## 二、多表查询的建议和规范

1. 如果查询语句中出现了多个表中都存在的字段，则必须指明此字段所在的表
2. 从SQL优化的角度，建议多表查询时，每个字段前都指明其所在的表
3. 可以给表起别名，如果给表起了别名，在使用此表时必须使用别名，不能再使用原表名
4. 如果有n个表实现多表的查询，则需要至少n-1个连接条件

## 三、多表查询的分类

### 一、等值连接 VS 非等值连接

1. 等值连接：使用=连接查询条件
2. 非等值连接：使用=之外的运算符连接查询条件

### 二、自连接 VS 非自连接

1. 自连接：本表连接本表
2. 非自连接：本表连接外表

### 三、内连接 VS 外连接

1. 内连接：合并具有同一列的两个以上的表的行，结果集中不包含一个表与另一个表不匹配的行

   - 使用JOIN ON进行连接

2. 外连接：合并具有同一列的两个以上的表的行，结果集中除了包含一个表与另一个表匹配的行之外，还查询到了左表或右表中不匹配的行

   - 左外连接：两个表在连接过程中除了返回满足连接条件的行以外还返回左表中不满足条件的行。使用LEFT　JOIN ON进行连接

   - 右外连接：两个表在连接过程中除了返回满足连接条件的行以外还返回右表中不满足条件的行。使用RIGHT

     JOIN ON进行连接

   - 满外连接：两个表在连接过程中除了返回满足连接条件的行以外还返回左表和右表中不满足条件的行。使用FULL JOIN ON进行连接。但是在MySQL中不支持，可以使用UNION或UNION ALL操作进行数据拼合

## 四、实现七种JOIN操作

![查询分类](../../../TyporaImage/SQL JOINS.png)

## 五、UNION操作

1. 利用UNION关键字，可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并时，两个表对应的列数和数据类型必须相同，并且相互对应。各个SELECT语句之间使用UNION或UNION ALL关键字分割
2. UNION操作符：UNION操作符返回两个查询的结果集的并集，去除重复记录
3. UNION ALL操作符：UNION ALL操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重
4. UNION ALL操作语句所需的资源比UNION操作语句少。如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复数据，则尽量使用UNION ALL操作语句，以提高数据查询的效率

## 六、SQL99新特性

- NATURAL JOIN：会自动查询两张（只能用于两张表）连接表中所有相同的字段，然后进行等值连接

	```mysql
	SELECT * FROM sys_user_role
	NATURAL JOIN sys_role
	```

- JOIN...USING：USING指定了具体的相同的字段名称，需要在USING的括号()中填入要指定的同名字段，必须同名。同时使用JOIN...USING可以简化JOIN ON的等值连接

	```mysql
	SELECT * FROM sys_user_role
	LEFT JOIN sys_role USING(role_id)
	```

# 七、函数

## 一、单行函数

### 一、单行函数的含义

1. 操作数据对象
2. 接受参数返回一个结果
3. 只对一行进行变换
4. 每行返回一个结果
5. 可以嵌套
6. 参数可以是一列或一个值

### 二、数值函数

#### 一、基本函数

![MySQl基本数值函数](../../../TyporaImage/MySQL%E5%9F%BA%E6%9C%AC%E6%95%B0%E5%80%BC%E5%87%BD%E6%95%B0.png)

#### 二、角度与弧度互换函数

![角度与弧度互换函数](../../../TyporaImage/MySQL%E6%95%B0%E5%80%BC%E5%87%BD%E6%95%B0%E8%A7%92%E5%BA%A6%E4%B8%8E%E5%BC%A7%E5%BA%A6%E4%BA%92%E6%8D%A2%E5%87%BD%E6%95%B0.png)

#### 三、三角函数

![三角函数](../../../TyporaImage/MySQL%E6%95%B0%E5%80%BC%E5%87%BD%E6%95%B0%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0.png)

#### 四、指数与对数

![MySQL数值函数指数与对数](../../../TyporaImage/MySQL%E6%95%B0%E5%80%BC%E5%87%BD%E6%95%B0%E6%8C%87%E6%95%B0%E4%B8%8E%E5%AF%B9%E6%95%B0.png)

#### 五、进制间的转换

![MySQL数值函数进制间的转换](../../../TyporaImage/MySQL%E6%95%B0%E5%80%BC%E5%87%BD%E6%95%B0%E8%BF%9B%E5%88%B6%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.png)

### 三、字符串函数

![MySQL字符串函数1](../../../TyporaImage/MySQL%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B01.png)

![MySQl字符串函数2](../../../TyporaImage/MySQL%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B02.png)

![MySQL字符串函数3](../../../TyporaImage/MySQL%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B03.png)

### 四、日期和时间函数

1. 获取日期、时间

	![MySQL获取日期、时间](../../../TyporaImage/MySQL%E8%8E%B7%E5%8F%96%E6%97%A5%E6%9C%9F%E3%80%81%E6%97%B6%E9%97%B4.png)

2. 日期与时间戳的转换

	![MySQL日期与时间戳的转换](../../../TyporaImage/MySQL%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4%E6%88%B3%E7%9A%84%E8%BD%AC%E6%8D%A2.png)

3. 获取月份、星期、星期数、天数等函数

	![MySQL获取月份、星期、星期数、天数等函数](../../../TyporaImage/MySQL%E8%8E%B7%E5%8F%96%E6%9C%88%E4%BB%BD%E3%80%81%E6%98%9F%E6%9C%9F%E3%80%81%E6%98%9F%E6%9C%9F%E6%95%B0%E3%80%81%E5%A4%A9%E6%95%B0%E7%AD%89%E5%87%BD%E6%95%B0.png)

4. 日期的操作函数

	![MySQL日期的操作函数](../../../TyporaImage/MySQL%E6%97%A5%E6%9C%9F%E7%9A%84%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0.png)

5. 时间和秒钟转换的函数

	![MySQL时间和秒钟转换的函数](../../../TyporaImage/MySQL%E6%97%B6%E9%97%B4%E5%92%8C%E7%A7%92%E9%92%9F%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%87%BD%E6%95%B0.png)

6. 计算日期和时间的函数

	![MySQl计算日期和时间的函数](../../../TyporaImage/MySQL%E8%AE%A1%E7%AE%97%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E7%9A%84%E5%87%BD%E6%95%B01.png)

	![MySQL计算日期和时间的函数](../../../TyporaImage/MySQL%E8%AE%A1%E7%AE%97%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E7%9A%84%E5%87%BD%E6%95%B02.png)

7. 日期的格式化与解析

	![MySQL日期的格式化与解析](../../../TyporaImage/MySQL%E6%97%A5%E6%9C%9F%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8E%E8%A7%A3%E6%9E%901.png)

	​	 非GET_FORMAT()函数中frmt参数常用的格式符

	​	 ![MySQL日期的格式化与解析2](../../../TyporaImage/MySQL%E6%97%A5%E6%9C%9F%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8E%E8%A7%A3%E6%9E%902.png)

	​     GET_FORMAT()函数中frmt参数常用的格式符

	​	 ![MySQL日期的格式化与解析3](../../../TyporaImage/MySQl%E6%97%A5%E6%9C%9F%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8E%E8%A7%A3%E6%9E%903.png)

### 五、流程控制函数

![MySQL流程控制函数](../../../TyporaImage/MySQL%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0.png)

### 六、加密与解密函数

![MySQL加密解密函数](../../../TyporaImage/MySQL%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%87%BD%E6%95%B0.png)

### 七、MySQL信息函数

![MySQL信息函数](../../../TyporaImage/MySQL%E4%BF%A1%E6%81%AF%E5%87%BD%E6%95%B0.png)

### 八、其他函数

![MysQl其他函数](../../../TyporaImage/MySQL%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0.png)

## 二、聚合函数

### 一、聚合函数的含义

- 聚合函数作用于一组数据，并对一组数据返回一个值
- 聚合函数在MySQL中不能嵌套使用，但是在ORACLE中可以使用。比如不能出现类似“AVG(SUM(字段名称))”形式的调用

### 二、AGE和SUM函数

- 可以对数值型数据使用AGE和SUM函数

### 三、MIN和MAX函数

- 可以对任意数据类型的数据使用MIN和MAX函数

### 四、COUNT函数

1. COUNT(*)返回表中记录总数，适用于任意数据类型
2. COUNT(任一数字)返回表中记录总数，适用于任意数据类型，任何数字COUNT()后返回的结果都是一样
3. COUNT(expr)返回expr不为空的记录总数，其中expr为表中的任一字段
   - 如果使用的是MyISAM存储引擎，则COUNT(*)、COUNT(1)和COUNT(expr)的效率是相同的，都是O(1)
   - 如果使用的是InnoDB存储引擎，则COUNT(*)=COUNT(1)>COUNT(expr)

### 五、GROUP BY

1. GROUP BY的作用：可以使用GROUP BY子句将表中的数据分为若干组

2. GROUP BY使用注意点

   - GROUP BY中使用字段的先后顺序对结果并不会产生影响
   - GROUP BY不一定要和聚合函数一起配合使用
   - 在SELECT列表中所有未包含在组函数中的列都应该包含在GROUP BY子句中。人话为SELECT中出现的非组函数的字段必须声明在GROUP BY中，反之，GROUP BY中声明的字段可以不出现在SELECT中

3. MySQL使用GROUP BY中的WITH ROLLUP

   ```mysql
   SELECT dept_id,AVG(salary) avg_sal FROM employees GROUP BY dept_id WITH ROLLUP;
   ```

   - 使用WITH ROLLUP关键字之后，在所有查询到的分组记录之后增加一条记录，该记录计算查询出的所有记录的总和，即统计记录数量
   - 当使用WITH ROLLUP时，不能同时使用ORDER BY子句进行结果排序，即WITH ROLLUP和ORDER BY是互相排斥的

### 六、HAVING

1. HAVING用于过滤数据
2. 如果过滤条件中使用了聚合函数，则必须使用HAVING来替换WHERE，当然WHERE和HAVING可以配合使用，只是HWERE条件中不能出现聚合函数，而HAVING过滤条件可以出现非聚合函数。一般带有聚合函数的过滤条件放在HAVING里面，未有聚合函数的过滤条件放在WHERE里面，因为WHERE的执行效率高
3. HAVING必须声明在GROUP BY的后面。当前HAVING也可以单独使用在非HAVING的查询语句中，但是没有实际开发意义，因为聚合函数没有分组，只会出现一个结果再去过滤就意义不大了
4. WHERE和HAVING的对比
	- WHERE可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件；HAVING建议要与GROUP BY配合使用，可以把分组计算的函数和分组字段作为筛选条件
	- 如果需要通过连接从关联表中获取需要的数据，WHERE是先筛选后连接，而HAVING是先连接后筛选

### 七、SELECT执行过程

1. 查询语法结构

	```mysql
	SELECT ...,....,...------------------------------>
	FROM ... JOIN ...-------------------------------->FROM从哪些表中筛选
	ON 多表的连接条件--------------------------------->ON关联多表查询时，去除笛卡尔积
	JOIN ...
	ON ...
	WHERE 不包含组函数的过滤条件---------------------->WHERE从表中筛选的条件
	AND/OR 不包含组函数的过滤条件
	GROUP BY ...,...-------------------------------->GROUP BY分组依据
	HAVING 包含组函数的过滤条件----------------------->HAVING在统计结果中再次筛选
	ORDER BY ... ASC/DESC--------------------------->ORDER BY排序
	LIMIT ...,...----------------------------------->LIMIT分页
	```

2. 查询执行顺序

	```mysql
	FROM  -> JOIN -> ON -> 
	WHERE -> 
	GROUP BY -> HAVING -> 
	SELECT 的字段 -> DISTINCT ->
ORDER BY -> LIMIT
	```

	在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个 虚拟表 ，然后将这个虚拟表传入下一个步骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的
	
	```
	SELECT 是先执行 FROM 这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤：
		1. 首先先通过 CROSS JOIN 求笛卡尔积，相当于得到虚拟表 vt（virtual table）1-1；
		2. 通过 ON 进行筛选，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表 vt1-2；
		3. 添加外部行。如果我们使用的是左连接、右链接或者全连接，就会涉及到外部行，也就是在虚拟表 vt1-2 		的基础上增加外部行，得到虚拟表 vt1-3。
	当然如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得到是我们的原始数据。
	
	当我们拿到了查询数据表的原始数据，也就是最终的虚拟表 vt1 ，就可以在此基础上再进行 WHERE 阶段 。在这个阶段中，会根据 vt1 表的结果进行筛选过滤，得到虚拟表 vt2 。
	
	然后进入第三步和第四步，也就是 GROUP 和 HAVING 阶段 。在这个阶段中，实际上是在虚拟表 vt2 的
	基础上进行分组和分组过滤，得到中间的虚拟表 vt3 和 vt4 。
	
	当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到 SELECT 和 DISTINCT阶段 。
	
	首先在 SELECT 阶段会提取想要的字段，然后在 DISTINCT 阶段过滤掉重复的行，分别得到中间的虚拟表vt5-1 和 vt5-2 。
	
	当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是 ORDER BY 阶段 ，得到虚拟表 vt6 。
	
	最后在 vt6 的基础上，取出指定行的记录，也就是 LIMIT 阶段 ，得到最终的结果，对应的是虚拟表vt7 。
	```

# 八、子查询

## 一、子查询的含义

- 子查询指一个查询语句嵌套在另一个查询语句内部的查询
- SQL中子查询的使用大大增强了SELECT查询的能力，因为很多时候查询需要从结果集中获取数据，或者需要从同一个表中先计算出一个数据结果，然后与这个数据结果（可能是某个标量，也可能是某个集合）进行比较

## 二、子查询的基本使用

1. 子查询（内查询）在主查询之前一次执行完成
2. 子查询的结果被主查询（外查询）使用
3. 注意事项
   - 子查询要包含在括号内
   - 将子查询放在比较条件的右侧
   - 单行操作符对应单行子查询，多行操作符对应多行子查询

## 三、子查询的分类

### 一、分类方式一

- 按照内查询的结果返回一条还是多条记录，将子查询分为单行子查询、多行子查询

### 二、分类方式二

1. 按照内查询是否被执行多次，将子查询划分为相关（或关联）子查询和不相关（或非关联）子查询
2. 子查询从数据表中查询了数据结果，如果这个数据结果只执行了一次，然后这个数据结果作为主查询的条件进行执行，那么这样的子查询叫做不相关子查询
3. 如果子查询需要执行多次，即采用循环的方式，先从外部查询开始，每次都传入子查询进行查询，然后再将结果反馈给外部，这种嵌套的执行方式就称为相关子查询

## 四、单行子查询

### 一、单行比较操作符

![MySQL单行比较操作符](../../../TyporaImage/MySQL单行比较操作符.png)

### 二、WHERE中的子查询

```mysql
SELECT employee_id, manager_id, department_id
FROM employees
WHERE manager_id =
				(SELECT manager_id
				 FROM employees
				 WHERE employee_id = 174)
AND department_id =
				(SELECT department_id
				 FROM employees
				 WHERE employee_id = 174))
AND employee_id = 174;
```

### 三、HAVING中的子查询

1. 首先执行子查询
2. 向主查询中的HAVING子句返回结果

```mysql
SELECT department_id, MIN(salary)
FROM employees
GROUP BY department_id
HAVING MIN(salary) >
				(SELECT MIN(salary)
				 FROM employees
				 WHERE department_id = 50);
```

### 四、CASE中的子查询

```mysql
SELECT employee_id, last_name,
(CASE department_id
WHEN
(SELECT department_id FROM departments
WHERE location_id = 1800)
THEN 'Canada' ELSE 'USA' END) location
FROM employees;
```

### 五、FROM中的子查询

- FROM中使用子查询相当于建立了一张临时表，此此查询必须使用括号并加别名

## 五、多行子查询

### 一、多行比较操作符 

![MySQL多行比较操作符](../../../TyporaImage/MySQL多行比较操作符.png)

1. IN：等于列表中的任意一个

   ```mysql
   SELECT employee_id, manager_id, department_id
   FROM employees
   WHERE manager_id IN
   				(SELECT manager_id
   				 FROM employees
   				 WHERE employee_id IN (174,141))
   AND department_id IN
   				(SELECT department_id
   				 FROM employees
   				 WHERE employee_id IN (174,141))
   AND employee_id NOT IN(174,141);
   ```

2. ANY：需要和单行比较操作符一起使用，和子查询返回的某一个值比较

   ```mysql
   SELECT employee_id, manager_id, department_id
   FROM employees
   WHERE salary < ANY
   				(SELECT salary
   				 FROM employees
   				 WHERE employee_id IN (174,141))
   ```

3. ALL：需要和单行比较操作符一起使用，和子查询返回的所有值比较

   ```mysql
   SELECT employee_id, manager_id, department_id
   FROM employees
   WHERE salary < ALL
   				(SELECT salary
   				 FROM employees
   				 WHERE employee_id IN (174,141))
   ```

4. SOME：实际上是ANY的别名，作用相同，一般常使用ANY

### 二、空值问题

1. 无论是在单行子查询还是多行子查询中都需要注意空值问题
2. 如果是操作子查询中出现空值，则整体查询语句可能会查不出数据。所以尽量在子查询中去除空值

## 六、相关子查询

### 一、相关子查询的含义

- 如果子查询的执行流程依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为 关联子查询

### 二、相关子查询的执行流程

1. GET：从主查询中获取候选列
2. EXECUTE：子查询使用主查询的数据
3. USE：如果满足子查询的条件则返回该行

### 三、子查询的适用位置

- 除了GROUP BY和LIMIT之外的地方，都可以声明子查询

### 四、EXISTS与NOT EXISTS关键字

1. 如果在子查询中不存在满足条件的行
   - 条件返回FALSE
   - 继续在子查询中查找
2. 如果在子查询中存在满足条件的行
   - 不在子查询中继续查找
   - 条件返回TRUE
3. NOT EXISTS关键字表示如果不存在某种条件，则返回TRUE，否则返回FALSE

```mysql
# 查询公司管理者的employee_id，last_name，job_id，department_id信息
SELECT employee_id, last_name, job_id, department_id
FROM employees e1
WHERE EXISTS 
			( SELECT *
			  FROM employees e2
			  WHERE e2.manager_id = e1.employee_id);
# 其中在子查询中只要满足 e2.manager_id = e1.employee_id 就会返回TRUE,e1.employee_id相对应的行就会被查询出来
# 子查询中的SELECT查询的字段名称无所谓，用什么都行
```

# 九、创建和管理表

## 一、标识符命名规则

- 数据库名、表名不得超过30个字符，变量名限制为29个
- 必须只能包含 A–Z, a–z, 0–9, _共63个字符 
- 数据库名、表名、字段名等对象名中间不要包含空格 
- 同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名 
- 必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用`（着重号）引起来 
- 保持字段名和类型的一致性：在命名字段并为其指定数据类型的时候一定要保证一致性，假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了 

## 二、创建和管理数据库

### 一、创建数据库

注意：DATABASE 不能改名。一些可视化工具可以改名，它是建新库，把所有表复制到新库，再删旧库完成的

```mysql
#方式一：创建的数据库使用的是默认的字符集
CREATE DATABASE 数据库名;
#方式二：显示指明了要创建的数据库的字符集
CREATE DATABASE 数据库名 CHARACTER SET 字符集;
#方式三：判断数据库是否已经存在，不存在则创建数据库
CREATE DATABASE IF NOT EXISTS 数据库名 CHARACTER SET 字符集;
```

### 二、管理数据库

```mysql
#查看当前所有的数据库
SHOW DATABASES;
#查看当前正在使用的数据库
SELECT DATABASE();
#查看指定库下所有的表
SHOW TABLES FROM 数据库名
#查看数据库的创建信息
SHOW CREATE DATABASE 数据库名;
SHOW CREATE DATABASE 数据库名\G
#使用/切换数据库
USE 数据库名;

#更改数据库字符集
SHOW CREATE DATABASE 数据库名

#删除数据库
DROP DATABASE 数据库名
DROP DATABASE IF EXISTS 数据库名
```

## 三、创建和管理表

### 一、创建表

1. 创建表的前提

   - CREATE TABLE权限
   - 存储空间

2. 创建表的规则

   - 必须指定的有表名，列名（或字段名）、数据类型、长度
   - 可选指定的有约束条件和默认值

3. 语法格式

   ```mysql
   #方式一：创建库中不存在的表
   CREATE TABLE [IF NOT EXISTS] 表名(
   字段1, 数据类型 [约束条件] [默认值],
   字段2, 数据类型 [约束条件] [默认值],
   字段3, 数据类型 [约束条件] [默认值],
   ……
   [表约束条件]
   );
   
   #方式二：基于查询语句查询到的字段创建表2，并导入数据（若不想导入数据，则添加where 1=2这样的条件即可）
   CREATE TABLE 表2
   AS
   SELECT 字段1，字段2......
   FROM 表1
   ```

### 二、修改表

```mysql
#查询表的结构
DESC 表名
#修改表
ALTER TABLE
#添加一个字段，默认新加的字段加到表的最后，也可以指明为首位或者某个字段后
ALTER TABLE 表名 ADD 需要添加的字段名 字段类型 FIRST（AFTER 指定的字段）
#修改一个字段，数据类型（一般不会修改）、长度、默认值
ALTER TABLE 表名 MODIFY 需要修改的字段名 字段类型(字段长度) DEFAULT 默认值
#重命名字段，重命名操作中包含修改字段的操作
ALTER TABLE 表名 CHANGE 原字段名称 新字段名称 字段类型
#删除某字段
ALTER TABLE 表名 DROP COLUMN 字段名
```

### 三、重命名表

```mysql
RENAME TABLE 原表名 TO 新表名 
ALTER TABLE 原表名 RENAME TO 新表名
```

### 四、删除表

```mysql
DROP TABLE IF EXISTS 表名
```

### 五、清空表

- TRUNCATE：实现对表中数据的删除，没有where条件，同时保留表结构。一旦执行此操作，数据不可回滚。TRUNCATE执行速度快，且使用的系统和事物日志资源少，但TRUNCATE无事物且不触发TRIGGER，有可能造成事故，故不建议在开发代码中使用此语句
- DELETE：实现对数据的删除，可以有where条件，同时保留表结构。一旦执行此操作，数据可以回滚，但是数据库设置了SET autocommit=TRUE，则执行的DELETE操作就不可以实现回滚

```mysql
TRUNCATE TABLE 表名
DELETE FROM 表名
```

## 四、COMMIT&ROLLBACK

1. COMMIT：提交数据。一旦执行commit，则数据就被永久的保存在数据库中，意味着数据不可以回滚
2. ROLLBACK：回滚数据。一旦执行ROLLBACK，则可以实现数据的回滚。回滚到最近的一次COMMIT之后

# 十、数据处理之增删改

## 一、添加数据

```mysql
#方式一：一条一条的添加数据，且没有指明要添加的字段，数据顺序要与表中字段顺序保持一致
INSERT INTO 表名 VALUES(字段1数据,字段2数据....)

#方式一：一条一条的添加数据，且指明要添加的字段，数据顺序要与指明的字段顺序保持一致
INSERT INTO 表名(字段1,字段2....) VALUES(字段1数据,字段2数据....)

#方式三：同时插入多行数据
INSERT INTO 表名(字段1,字段2....) 
VALUES
(字段1数据,字段2数据....),
(字段1数据,字段2数据....)

#方式三：将查询结果插入到表中，不必写VALUES子句，但子查询中的值列表应与INSERT子句中的列名对应
INSERT INTO 表名(字段1,字段2....)
SELECT 字段1,字段2....
FROM 源表名
WHERE 
```

## 二、更新数据

```mysql
#修改同一行数据中的某个字段
UPDATE 表名 SET 字段名 = 数据 WHERE 

#修改同一行数据中的多个字段
UPDATE 表名 SET 字段名1=数据1,字段名2=数据2 WHERE
```

## 三、删除数据

```mysql
DELETE FROM 表名 WHERE 
```

## 四、MySQL8新特性：计算列

- 简单来说就是某一行的值是通过别的列计算得来的。例如，a列值为1、b列值为2，c列不需要手动插入，定义a+b的结果为c的值，那么c就是计算列，是通过别的列计算得来的
- 新增或更新a和b时会自动更新c

```mysql
CREATE TABLE tb1(
id INT,
a INT,
b INT,
c INT GENERATED ALWAYS AS (a + b) VIRTUAL
);
```

# 十一、MySQL数据类型

## 一、MySQL中的字段类型

![MySQL字段类型](../../../TyporaImage/MySQl字段类型.png)

![MySQL常见数据类型属性](../../../TyporaImage/MySQL常见数据类型属性.png)

## 二、整数类型

### 一、类型介绍

![MySQL整数类型](../../../TyporaImage/MySQL整数类型.png)

### 二、可选属性

1. M
   - 表示显示宽度，M的取值范围是(0, 255)。例如，int(5)：当数据宽度小于5位的时候在数字前面需要用 字符填满宽度。该项功能需要配合“ ZEROFILL ”使用，表示用“0”填满宽度，否则指定显示宽度无效。符号位也占用一个宽度
   - 如果设置了显示宽度，那么插入的数据宽度超过显示宽度限制，不会对插入的数据有任何影响，还是按照类型的实际宽度进行保存，即显示宽度与类型可以存储的值范围无关 。从MySQL 8.0.17开始，整数数据类型不推荐使用显示宽度属性
   - 整型数据类型可以在定义表结构时指定所需要的显示宽度，如果不指定，则系统为每一种类型指定默认的宽度值
2. UNSIGNED
   - 无符号类型（非负），所有的整数类型都有一个可选的属性UNSIGNED（无符号属性），无 符号整数类型的最小取值为0
   - 如果需要在MySQL数据库中保存非负整数值时，可以将整数类型设置为无符号类型
   - int类型默认显示宽度为int(11)，无符号int类型默认显示宽度为int(10)
3. ZEROFILL
   - 0填充,（如果某列是ZEROFILL，那么MySQL会自动为当前列添加UNSIGNED属性），如果指定了ZEROFILL只是表示不够M位时，用0在左边填充，如果超过M位，只要不超过数据存储范围即可
   - 在 int(M) 中，M 的值跟 int(M) 所占多少存储空间并无任何关系。 int(3)、int(4)、int(8) 在磁盘上都是占用 4 bytes 的存储空间。也就是说，int(M)，必须和UNSIGNED ZEROFILL一起使用才有意义。如果整数值超过M位，就按照实际位数存储。只是无须再用字符 0 进行填充

### 三、适用场景

- TINYINT ：一般用于枚举数据，比如系统设定取值范围很小且固定的场景
- SMALLINT ：可以用于较小范围的统计数据，比如统计工厂的固定资产库存数量等
- MEDIUMINT ：用于较大整数的计算，比如车站每日的客流量等
- INT、INTEGER ：取值范围足够大，一般情况下不用考虑超限问题，用得最多。比如商品编号
- BIGINT ：只有当你处理特别巨大的整数时才会用到。比如双十一的交易量、大型门户网站点击量、证券公司衍生产品持仓等

## 三、浮点类型

### 一、浮点数

![MySQL浮点类型](../../../TyporaImage/MySQL浮点类型.png)

### 二、定点数

|         数据类型         | 字节数  |        含义        |
| :----------------------: | :-----: | :----------------: |
| DECIMAL(M,D),DEC,NUMERIC | M+2字节 | 有效范围由M和D决定 |

1. MySQL中的定点数只有DECIMAL一种类型
2. 使用 DECIMAL(M,D) 的方式表示高精度小数。其中，M被称为精度，D被称为标度。0<=M<=65， 0<=D<=30，D<M。例如，定义DECIMAL（5,2）的类型，表示该列取值范围是-999.99~999.99
3. DECIMAL(M,D)的最大取值范围与DOUBLE类型一样，但是有效的数据范围是由M和D决定的。 DECIMAL 的存储空间并不是固定的，由精度值M决定，总共占用的存储空间为M+2个字节。也就是 说，在一些对精度要求不高的场景下，比起占用同样字节长度的定点数，浮点数表达的数值范围可以更大一些
4. 定点数在MySQL内部是以 字符串 的形式进行存储，这就决定了它一定是精准的
5. 当DECIMAL类型不指定精度和标度时，其默认为DECIMAL(10,0)。当数据的精度超出了定点数类型的精度范围时，则MySQL同样会进行四舍五入处理
6. 浮点数VS定点数
   - 浮点数相对于定点数的优点是在长度一定的情况下，浮点类型取值范围大，但是不精准，适用于需要取值范围大，又可以容忍微小误差的科学计算场景（比如计算化学、分子建模、流体动力学等）
   - 定点数类型取值范围相对小，但是精准，没有误差，适合于对精度要求极高的场景 （比如涉及金额计算的场景）

## 四、位类型

| 二进制字符串类型 | 长度 |   长度范围   |      占用空间       |
| :--------------: | :--: | :----------: | :-----------------: |
|      BIT(M)      |  M   | 1 <= M <= 64 | 约为(M + 7)/8个字节 |

1. BIT类型中存储的是二进制值，类似010110
2. BIT类型，如果没有指定(M)，默认是1位。这个1位，表示只能存1位的二进制值。这里(M)是表示二进制的位数，位数最小值为1，最大值为64
3. 在向BIT类型的字段中插入数据时，一定要确保插入的数据在BIT类型支持的范围内
4. 使用SELECT命令查询位字段时，可以用 BIN() 二进制表示或 HEX() 十六进制显示函数进行读取
5. 使用b+0查询数据时，可以直接查询出存储的十进制数据的值

## 五、日期时间类型

![MySQL日期时间类型](../../../TyporaImage/MySQL日期时间类型.png)

1. YEAR 类型通常用来表示年，格式为 YYYY
2. DATE 类型通常用来表示年、月、日，格式为 YYYY-MM-DD
3. TIME 类型通常用来表示时、分、秒。不光表示一天之内的时间，而且可以用来表示一个时间间隔，这个时间间隔可以超过 24 小时，格式为HH:MM:SS
4. DATETIME 类型通常用来表示年、月、日、时、分、秒，格式为YYYY-MM-DD HH:MM:SS 
5. TIMESTAMP 类型通常用来表示带时区的年、月、日、时、分、秒，存储的是时间戳，但是显示的则是正常的日期时间格式
   - TIMESTAMP类型也可以表示日期时间，其显示格式与DATETIME类型相同，都是 YYYY-MM-DD HH:MM:SS
   - 需要4个字节的存储空间。但是TIMESTAMP存储的时间范围比DATETIME要小很多，只能存储 “1970-01-01 00:00:01 UTC”到“2038-01-19 03:14:07 UTC”之间的时间。其中，UTC表示世界统一时间，也叫作世界标准时间
   - 存储数据的时候需要对当前时间所在的时区进行转换，查询数据的时候再将时间转换回当前的时区。因此，使用TIMESTAMP存储的同一个时间值，在不同的时区查询时会显示不同的时间
   - TIMESTAMP和DATETIME的区别：TIMESTAMP存储空间比较小，表示的日期时间范围也比较小；底层存储方式不同，TIMESTAMP底层存储的是毫秒值，距离1970-1-1 0:0:0 0毫秒的毫秒值；两个日期比较大小或日期计算时，TIMESTAMP更方便、更快；TIMESTAMP和时区有关。TIMESTAMP会根据用户的时区不同，显示不同的结果。而DATETIME则只能反映出插入时当地的时区，其他时区的人查看数据必然会有误差的

## 六、文本字符串类型

![MySQL文本字符串类型](../../../TyporaImage/MySQL文本字符串类型.png)

### 一、CHAR和VARCHAR类型

1. CHAR类型

   - CHAR(M) 类型一般需要预先定义字符串长度。如果不指定(M)，则表示长度默认是1个字符
   - 如果保存时，数据的实际长度比CHAR类型声明的长度小，则会在 右侧填充 空格以达到指定的长度。当MySQL检索CHAR类型的数据时，CHAR类型的字段会去除尾部的空格
   - 定义CHAR类型字段时，声明的字段长度即为CHAR类型字段所占的存储空间的字节数

2. VARCHAR类型

   - VARCHAR(M) 定义时， 必须指定 长度M，否则报错
   - MySQL4.0版本以下，varchar(20)：指的是20字节，如果存放UTF8汉字时，只能存6个（每个汉字3字节） ；MySQL5.0版本以上，varchar(20)：指的是20字符
   - 检索VARCHAR类型的字段数据时，会保留数据尾部的空格。VARCHAR类型的字段所占用的存储空间为字符串实际长度加1个字节

3. CHAR或VARCHAR适用的场景

   |    类型    |   特点   |    空间上    | 时间上 |       适用场景       |
   | :--------: | :------: | :----------: | :----: | :------------------: |
   |  CHAR(M)   | 固定长度 | 浪费存储空间 | 效率高 | 存储不大，速度要求高 |
   | VARCHAR(M) | 可变长度 | 节省存储空间 | 效率低 |     非CHAR的情况     |

   - 存储很短的信息。比如门牌号码101，201……这样很短的信息应该用char，因为varchar还要占个 byte用于存储信息长度，本来打算节约存储的，结果得不偿失

   - 固定长度的。比如使用uuid作为主键，那用char应该更合适。因为他固定长度，varchar动态根据长度的特性就消失了，而且还要占个长度信息

   - 十分频繁改变的column。因为varchar每次存储都要有额外的计算，得到长度等工作，如果一个非常频繁改变的，那就要有很多的精力用于计算，而这些对于char来说是不需要的，则使用VARCHAR会更好

   - MyISAM 数据存储引擎和数据列：MyISAM数据表，最好使用固定长度(CHAR)的数据列代替可变长度(VARCHAR)的数据列。这样使得整个表静态化，从而使 数据检索更快 ，用空间换时间；

     MEMORY 存储引擎和数据列：MEMORY数据表目前都使用固定长度的数据行存储，因此无论使用CHAR或VARCHAR列都没有关系，两者都是作为CHAR类型处理的；

     InnoDB 存储引擎，建议使用VARCHAR类型。因为对于InnoDB数据表，内部的行存储格式并没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），而且主要影响性能的因素是数据行使用的存储总量，由于char平均占用的空间多于varchar，所以除了简短并且固定长度的，其他考虑varchar。这样节省空间，对磁盘I/O和数据存储总量比较好

### 二、TEXT类型

| 文本字符串类型 |        特点        | 长度 |             长度范围             | 占用的存储空间 |
| :------------: | :----------------: | :--: | :------------------------------: | :------------: |
|    TINYTEXT    |  小文本、可变长度  |  L   |          0 <= L <= 255           |   L+2个字节    |
|      TEXT      |   文本、可变长度   |  L   |         0 <= L <= 65535          |   L+2个字节    |
|   MEDIUMTEXT   | 中等文本、可变长度 |  L   |        0 <= L <= 16777215        |   L+3个字节    |
|    LONGTEXT    |  大文本、可变长度  |  L   | 0 <= L<= 4294967295（相当于4GB） |   L+4个字节    |

## 七、ENUM枚举类型

| 文本字符串类型 | 长度 |    长度范围     | 占用的存储空间 |
| :------------: | :--: | :-------------: | :------------: |
|      ENUM      |  L   | 1 <= L <= 65535 |   1或2个字节   |

1. ENUM类型也叫作枚举类型，ENUM类型的取值范围需要在定义字段时进行指定。设置字段值时，ENUM类型只允许从成员中选取单个值，不能一次选取多个值

2. 当ENUM类型包含1～255个成员时，需要1个字节的存储空间；当ENUM类型包含256～65535个成员时，需要2个字节的存储空间；ENUM类型的成员个数的上限为65535个

3. 创建ENUM枚举类型以及添加ENUM枚举类型数据

   ```mysql
   #创建表
   CREATE TABLE test_enum(
   season ENUM('春','夏','秋','冬','unknow')
   );
   
   #添加数据
   INSERT INTO test_enum
   VALUES('春'),('秋');
   # 忽略大小写
   INSERT INTO test_enum
   VALUES('UNKNOW');
   # 允许按照角标的方式获取指定索引位置的枚举值，数据库中的索引是从1开始的
   INSERT INTO test_enum
   VALUES('1'),(3);
   # 当ENUM类型的字段没有声明为NOT NULL时，插入NULL也是有效的
   INSERT INTO test_enum
   VALUES(NULL);
   ```

## 八、SET类型

当SET类型包含的成员个数不同时，其所占用的存储空间也是不同的，具体如下：

| 成员个数范围（L表示实际成员个数） | 占用的存储空间 |
| :-------------------------------: | :------------: |
|            1 <= L <= 8            |    1个字节     |
|           9 <= L <= 16            |    2个字节     |
|           17 <= L <= 24           |    3个字节     |
|           25 <= L <= 32           |    4个字节     |
|           33 <= L <= 64           |    8个字节     |

1. SET表示一个字符串对象，可以包含0个或多个成员，但成员个数的上限为 64 。设置字段值时，可以取取值范围内的 0 个或多个值

2. SET类型在存储数据时成员个数越多，其占用的存储空间越大。注意：SET类型在选取成员时，可以一次选择多个成员，这一点与ENUM类型不同

3. 创建SET类型以及添加数据

   ```mysql
   #创建表
   CREATE TABLE test_set(
   s SET ('A', 'B', 'C')
   );
   
   #添加数据
   INSERT INTO test_set (s) VALUES ('A'), ('A,B');
   #插入重复的SET类型成员时，MySQL会自动删除重复的成员
   INSERT INTO test_set (s) VALUES ('A,B,C,A');
   #向SET类型的字段插入SET成员中不存在的值时，MySQL会抛出错误。
   INSERT INTO test_set (s) VALUES ('A,B,C,D');
   ```

## 九、二进制字符串类型

### 一、BINARY与VARBINARY类型

| 二进制字符串类型 |   特点   |       值的长度       | 占用空间  |
| :--------------: | :------: | :------------------: | :-------: |
|    BINARY(M)     | 固定长度 | M （0 <= M <= 255）  |  M个字节  |
|   VARBINARY(M)   | 可变长度 | M（0 <= M <= 65535） | M+1个字节 |

1. BINARY和VARBINARY类似于CHAR和VARCHAR，只是它们存储的是二进制字符串
2. BINARY (M)为固定长度的二进制字符串，M表示最多能存储的字节数，取值范围是0~255个字符。如果未指定(M)，表示只能存储 1个字节 。例如BINARY (8)，表示最多能存储8个字节，如果字段值不足(M)个字 节，将在右边填充'\0'以补齐指定长度
3. VARBINARY (M)为可变长度的二进制字符串，M表示最多能存储的字节数，总字节数不能超过行的字节长度限制65535，另外还要考虑额外字节开销，VARBINARY类型的数据除了存储数据本身外，还需要1或2个字节来存储数据的字节数。VARBINARY类型 必须指定(M) ，否则报错

### 二、BLOB类型

| 二进制字符串类型 | 值的长度 |             长度范围              |   占用空间   |
| :--------------: | :------: | :-------------------------------: | :----------: |
|     TINYBLOB     |    L     |           0 <= L <= 255           | L + 1 个字节 |
|       BLOB       |    L     |   0 <= L <= 65535（相当于64KB）   | L + 2 个字节 |
|    MEDIUMBLOB    |    L     | 0 <= L <= 16777215 （相当于16MB） | L + 3 个字节 |
|     LONGBLOB     |    L     | 0 <= L <= 4294967295（相当于4GB） | L + 4 个字节 |

1. BLOB是一个二进制大对象，可以容纳可变数量的数据

2. MySQL中的BLOB类型包括TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB 4种类型，它们可容纳值的最大长度不同。可以存储一个二进制的大对象，比如图片、音频和视频等

3. 需要注意的是，在实际工作中，往往不会在MySQL数据库中使用BLOB类型存储大对象数据，通常会将图 

   片、音频和视频文件存储到 服务器的磁盘上 ，并将图片、音频和视频的访问路径存储到MySQL中

4. TEXT和BLOB的使用注意事项：

   - BLOB和TEXT值也会引起自己的一些问题，特别是执行了大量的删除或更新操作的时候。删除这种值会在数据表中留下很大的" 空洞 "，以后填入这些"空洞"的记录可能长度不同。为了提高性能，建议定期使用 OPTIMIZE TABLE 功能对这类表进行 碎片整理 
   - 如果需要对大文本字段进行模糊查询，MySQL 提供了 前缀索引 。但是仍然要在不必要的时候避免检索大型的BLOB或TEXT值。例如，SELECT * 查询就不是很好的想法，除非你能够确定作为约束条件的WHERE子句只会找到所需要的数据行。否则，你可能毫无目的地在网络上传输大量的值
   - 把BLOB或TEXT列 分离到单独的表 中。在某些环境中，如果把这些数据列移动到第二张数据表中，可以让你把原数据表中的数据列转换为固定长度的数据行格式，那么它就是有意义的。这会 减少主表中的碎片 ，使你得到固定长度数据行的性能优势。它还使你在主数据表上运行 SELECT * 查询的时候不会通过 网络传输大量的BLOB或TEXT值

## 十、JSON类型

1. JSON（JavaScript Object Notation）是一种轻量级的 数据交换格式 。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。它易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。JSON可以将JavaScript对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式

2. 在MySQL 5.7中，就已经支持JSON数据类型。在MySQL 8.x版本中，JSON类型提供了可以进行自动验证的JSON文档和优化的存储结构，使得在MySQL中存储和读取JSON类型的数据更加方便和高效

3. 创建并使用JSON类型

   ```mysql
   #创建JSON字段
   CREATE TABLE test_json(
   字段名为js json
   );
   
   #添加json数据
   INSERT INTO test_json (js)
   VALUES ('{"name":"songhk", "age":18, "address":{"province":"beijing",
   "city":"beijing"}}');
   
   #当需要检索JSON类型的字段中数据的某个具体值时，可以使用“->”和“->>”符号
   SELECT js -> '$.name' AS NAME,js -> '$.age' AS age ,js -> '$.address.province'
   AS province, js -> '$.address.city' AS city FROM test_json
   ```

## 十一、空间类型

# 十二、约束

## 一、约束概述

### 一、约束的意义

- 数据完整性（Data Integrity）是指数据的精确性（Accuracy）和可靠性（Reliability）。它是防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的
- 为了保证数据的完整性，SQL规范以约束的方式对表数据进行额外的条件限制
  1. 实体完整性（Entity Integrity） ：例如，同一个表中，不能存在两条完全相同无法区分的记录 
  2. 域完整性（Domain Integrity） ：例如：年龄范围0-120，性别范围“男/女” 
  3. 引用完整性（Referential Integrity） ：例如：员工所在部门，在部门表中要能找到这个部门 
  4. 用户自定义完整性（User-defined Integrity） ：例如：用户名唯一、密码不能为空等，本部门经理的工资不得高于本部门职工的平均工资的5倍

### 二、约束的含义

- 约束是表级的强制规定
- 可以在创建表时规定约束（通过CREATE TABLE语句），或者在表创建之后通过 ALTER TABLE 语句规定约束

### 三、约束的分类

1. 根据约束数据列的限制，约束分为

   - 单列约束：每个约束只约束一列
   - 多列约束：每个约束约束多列数据

2. 根据约束的作用范围，约束分为

   - 列级约束：只能作用在一个列上，跟在列的定义后面

   - 表级约束：可以作用在多个列上，不与列一起，而是单独定义

   - 表格对比

     |          |     位置     |       支持的约束类型       |   是否可以起约束名   |
     | :------: | :----------: | :------------------------: | :------------------: |
     | 列级约束 |   列的后面   | 语法都支持，但外键没有效果 |        不可以        |
     | 表级约束 | 所有列的下面 | 默认和非空不支持，其他支持 | 可以，但是主键没效果 |

3. 根据约束起的作用，约束分为

   - NOT NULL非空约束，规定某个字段不能为空
   - UNIQUE唯一约束，规定某个字段在整个表中是唯一的
   - PRIMARY KEY主键(非空且唯一)约束
   - FOREIGN KEY外键约束 
   - CHECK检查约束。注意点，MySQL不支持check约束，但可以使用check约束，而没有任何效果
   - DEFAULT默认值约束

## 二、约束的查询

- 查看某个表已有的约束

  ```mysql
  #information_schema数据库名（系统库）
  #table_constraints表名称（专门存储各个表的约束）
  SELECT * FROM information_schema.table_constraints
  WHERE table_name = '表名称';
  ```

## 三、非空约束

### 一、作用

- 限制某个字段/某列的值不允许为空

### 二、关键字

- NOT NULL

### 三、特点

- 默认，所有的类型的值都可以是NULL，包括INT、FLOAT等数据类型 
- 非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空 
- 一个表可以有很多列都分别限定了非空 
- 空字符串''不等于NULL，0也不等于NULL

### 四、添加非空约束

1. 建表时

   ```mysql
   CREATE TABLE 表名称(
   字段名 数据类型,
   字段名 数据类型 NOT NULL,
   字段名 数据类型 NOT NULL
   );
   ```

2. 建表后

   ```mysql
   alter table 表名称 modify 字段名 数据类型 not null;
   ```

### 五、删除非空约束

```mysql
alter table 表名称 modify 字段名 数据类型 NULL;
#去掉not null，相当于修改某个非注解字段，该字段允许为空

alter table 表名称 modify 字段名 数据类型;
#去掉not null，相当于修改某个非注解字段，该字段允许为空
```

## 四、唯一性约束

### 一、作用

- 用来限制某个字段/某列的值不能重复
- 即是限制了唯一性约束，该限制唯一性约束的字段仍然允许出现多个空置NULL

### 二、关键字

- UNIQUE 

### 三、特点

- 同一个表可以有多个唯一约束
- 唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一
- 唯一性约束允许列值为空
- 在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同
- MySQL会给唯一约束的列上默认创建一个唯一索引
- 关键字key可以省略

### 四、添加唯一性约束

1. 建表时

   ```mysql
   create table 表名称(
   字段名 数据类型,
   字段名 数据类型 unique,
   字段名 数据类型 unique key,
   字段名 数据类型
   );
   create table 表名称(
   字段名 数据类型,
   字段名 数据类型,
   字段名 数据类型,
   [constraint 约束名] unique key(字段名)
   )
   
   # 列子
   create table student(
   sid int,
   sname varchar(20),
   tel char(11) unique,
   cardid char(18) unique key
   );
   
   CREATE TABLE USER(
   id INT NOT NULL,
   NAME VARCHAR(25),
   PASSWORD VARCHAR(16),
   -- 使用表级约束语法
   CONSTRAINT uk_name_pwd UNIQUE(NAME,PASSWORD)
   );
   ```

2. 建表后

   ```mysql
   #字段列表中如果是一个字段，表示该列的值唯一。如果是两个或更多个字段，那么复合唯一，
   #即多个字段的组合是唯一的
   
   #方式1：
   alter table 表名称 add unique key(字段列表);
   
   #方式2：
   alter table 表名称 modify 字段名 字段类型 unique;
   ```

### 五、关于复合唯一约束

```mysql
create table 表名称(
字段名 数据类型,
字段名 数据类型,
字段名 数据类型,
unique key(字段列表) 
#字段列表中写的是多个字段名，多个字段名用逗号分隔，表示那么是复合唯一，即多个字段的组合是唯一的
);
```

### 六、删除唯一约束

```mysql
SELECT * FROM information_schema.table_constraints WHERE table_name = '表名'; 
#查看都有哪些约束

ALTER TABLE 表名 DROP INDEX 唯一性约束名称/唯一性索引名称;

#注意：可以通过 show index from 表名称; 查看表的索引
```

- 添加唯一性约束的列上也会自动创建唯一索引
- 删除唯一约束只能通过删除唯一索引的方式删除
- 删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样
- 如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和()中排在第一个的列名相同。也可以自定义唯一性约束名

## 五、主键约束

### 一、作用

- 用来唯一标识表中的一行记录

### 二、关键字

- primary key

### 三、特点

- 主键约束相当于唯一约束 + 非空约束的组合，主键约束列不允许重复，也不允许出现空值
- 一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建
- 主键约束对应着表中的一列或者多列（复合主键） 
- 如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复
- MySQL的主键名总是PRIMARY，就算自己命名了主键约束名也没用
- 当创建主键约束时，系统默认会在所在的列或列组合上建立对应的主键索引（能够根据主键查询的，就根据主键查询，效率更高）。如果删除主键约束了，主键约束对应的索引就自动删除了
- 需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性

### 四、添加主键约束

1. 建表时

   ```mysql
   create table 表名称(
   字段名 数据类型 primary key, #列级模式
   字段名 数据类型,
   字段名 数据类型
   );
   create table 表名称(
   字段名 数据类型,
   字段名 数据类型,
   字段名 数据类型,
   [constraint 约束名] primary key(字段名) #表级模式
   );
   ```

2. 建表后

   ```mysql
   ALTER TABLE 表名称 ADD PRIMARY KEY(字段列表); 
   #字段列表可以是一个字段，也可以是多个字段，如果是多个字段的话，是复合主键
   ```

### 五、关于复合主键

```mysql
create table 表名称(
字段名 数据类型,
字段名 数据类型,
字段名 数据类型,
primary key(字段名1,字段名2) 
#表示字段1和字段2的组合是唯一的，也可以有更多个字段
);
```

### 六、删除主键约束

```mysql
alter table 表名称 drop primary key;
```

## 六、 自增列

### 一、作用

- 某个字段的值自增

### 二、关键字

- auto_increment

### 三、特点和要求

- 一个表最多只能有一个自增长列
- 当需要产生唯一标识符或顺序值时，可设置自增长
- 自增长列约束的列必须是键列（主键列，唯一键列）
- 自增约束的列的数据类型必须是整数类型
- 如果自增列指定了 0 和 null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值。也就是说指定0或null不起作用

### 四、指定自增约束

1. 建表时

   ```mysql
   create table 表名称(
   字段名 数据类型 primary key auto_increment,
   字段名 数据类型 unique key not null,
   字段名 数据类型 unique key,
   字段名 数据类型 not null default 默认值,
   );
   
   create table 表名称(
   字段名 数据类型 default 默认值 ,
   字段名 数据类型 unique key auto_increment,
   字段名 数据类型 not null default 默认值,,
   primary key(字段名)
   );
   ```

2. 建表后

   ```mysql
   alter table 表名称 modify 字段名 数据类型 auto_increment;
   ```

### 五、删除自增约束

```mysql
#alter table 表名称 modify 字段名 数据类型 auto_increment;#给这个字段增加自增约束
alter table 表名称 modify 字段名 数据类型; #去掉auto_increment相当于删除
```

### 六、MySQL 8.0自增主键新特性

1. 在MySQL 8.0之前，自增主键AUTO_INCREMENT的值如果大于max(primary key)+1，在MySQL重启后，会重置AUTO_INCREMENT=max(primary key)+1，这种现象在某些情况下会导致业务主键冲突或者其他难以发现的问题
2.  在MySQL 5.7系统中，对于自增主键的分配规则，是由InnoDB数据字典内部一个计数器来决定的，而该计数器只在内存中维护 ，并不会持久化到磁盘中。当数据库重启时，该计数器会被初始化。上述结果的主要原因是自增主键没有持久化
3. MySQL 8.0将自增主键的计数器持久化到 重做日志 中。每次计数器发生改变，都会将其写入重做日志中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值

## 七、 外键约束 

### 一、作用

- 限定某个表的某个字段的引用完整性

### 二、关键字

- FOREIGN KEY

### 三、主表和从表/父表和子表

1. 主表（父表）：被引用的表，被参考的表 
2. 从表（子表）：引用别人的表，参考别人的表  

### 四、特点

1. 从表的外键列，必须引用/参考主表的主键或唯一约束的列，因为被依赖/被参考的值必须是唯一的 
2. 在创建外键约束时，如果不给外键约束命名，默认名不是列名，而是自动产生一个外键名（例如student_ibfk_1;），也可以指定外键约束名
3. 创建(CREATE)表时就指定外键约束的话，先创建主表，再创建从表
4. 删表时，先删从表（或先删除外键约束），再删除主表
5. 当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据 
6. 在“从表”中指定外键约束，并且一个表可以建立多个外键约束 
7. 从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。如果类型不一样，创建子表时，就会出现错误
8. 当创建外键约束时，系统默认会在所在的列上建立对应的普通索引。但是索引名是外键的约束名。根据外键查询效率很高
9. 删除外键约束后，必须手动删除对应的索引 

### 五、添加外键约束

1. 建表时

   ```mysql
   create table 主表名称(
   字段1 数据类型 primary key,
   字段2 数据类型
   );
   
   create table 从表名称(
   字段1 数据类型 primary key,
   字段2 数据类型,
   [CONSTRAINT <外键约束名称>] FOREIGN KEY（从表的某个字段) references 主表名(被参考字段)
   );
   
   #(从表的某个字段)的数据类型必须与主表名(被参考字段)的数据类型一致，逻辑意义也一样
   #(从表的某个字段)的字段名可以与主表名(被参考字段)的字段名一样，也可以不一样
   -- FOREIGN KEY: 在表级指定子表中的列
   -- REFERENCES: 标示在父表中的列
   ```

2. 建表后

   ```mysql
   #一般情况下，表与表的关联都是提前设计好了的，因此，会在创建表的时候就把外键约束定义好。不过，如果需要修改表的设计（比如添加新的字段，增加新的关联关系），但没有预先定义外键约束，那么，就要用修改表的方式来补充定义
   
   ALTER TABLE 从表名 ADD [CONSTRAINT 约束名] FOREIGN KEY (从表的字段) REFERENCES 主表名(被引用
   字段) [on update xx][on delete xx];
   ```

### 六、外键约束对数据的要求

1. 添加了外键约束后，主表的修改和删除数据受约束
2. 添加了外键约束后，从表的添加和修改数据受约束
3. 在从表上建立外键，要求主表必须存在 
4. 删除主表时，要求从表先删除，或将从表中外键引用该主表的关系先删除 

### 七、约束等级

1. Cascade方式 ：在父表上update/delete记录时，同步update/delete掉子表的匹配记录。
2. Set null方式 ：在父表上update/delete记录时，将子表上匹配记录的列设为null，但是要注意子表的外键列不能为not null 
3. No action方式 ：如果子表中有匹配的记录，则不允许对父表对应候选键进行update/delete操作 
4. Restrict方式 ：同no action， 都是立即检查外键约束。默认方式
5. Set default方式 （在可视化工具SQLyog中可能显示空白）：父表有变更时，子表将外键列设置成一个默认的值，但Innodb不能识别
6. 对于外键约束，最好是采用: ON UPDATE CASCADE ON DELETE RESTRICT 的方式

### 八、删除外键约束

```mysql
#第一步先查看约束名和删除外键约束
SELECT * FROM information_schema.table_constraints WHERE table_name = '表名称';#查看某个表的约束名
ALTER TABLE 从表名 DROP FOREIGN KEY 外键约束名;

#第二步查看索引名和删除索引。（注意，只能手动删除）
SHOW INDEX FROM 表名称; #查看某个表的索引名
ALTER TABLE 从表名 DROP INDEX 索引名;
```

### 九、开发场景

1. 不一定要必须使用外键操作
2. 建和不建外键约束的区别
   - 建外键约束，你的操作（创建表、删除表、添加、修改、删除）会受到限制，从语法层面受到限制
   - 不建外键约束，你的操作（创建表、删除表、添加、修改、删除）不受限制，要保证数据的引用完整性 ，只能依 靠程序员的自觉 ，或者是 在Java程序中进行限定
   - 建和不建外键约束的区别和查询并无关系
3. 阿里开发规范：不得使用外键与级联，一切外键概念必须在应用层解决。外键与级联更新适用于单机低并发 ，不适合 分布式 、 高并发集群 ；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度

## 八、CHECK约束

### 一、作用

- 检查某个字段的值是否符号xx要求，一般指的是值的范围

### 二、关键字

- check

### 三、说明

1. MySQL5.7不支持check约束
2. MySQL8.0不支持check约束

### 四、用法

```mysql
create table employee(
eid int primary key,
ename varchar(5),
gender char check ('男' or '女')
);

CREATE TABLE temp(
id INT AUTO_INCREMENT,
NAME VARCHAR(20),
age INT CHECK(age > 20),
PRIMARY KEY(id)
);
```

## 九、DEFAULT约束

### 一、作用

- 给某个字段/某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值

### 二、关键字

- DEFAULT

### 三、添加默认值约束

1. 建表时

   ```mysql
   create table 表名称(
   字段名 数据类型 primary key,
   字段名 数据类型 unique key not null,
   字段名 数据类型 unique key,
   字段名 数据类型 not null default 默认值,
   );
   
   create table 表名称(
   字段名 数据类型 default 默认值 ,
   字段名 数据类型 not null default 默认值,
   字段名 数据类型 not null default 默认值,
   primary key(字段名),
   unique key(字段名)
   );
   
   #说明：默认值约束一般不在唯一键和主键列上加
   ```

2. 建表后

   ```mysql
   alter table 表名称 modify 字段名 数据类型 default 默认值;
   
   #如果这个字段原来有非空约束，你还保留非空约束，那么在加默认值约束时，还得保留非空约束，
   #否则非空约束就被删除了
   #同理，在给某个字段加非空约束也一样，如果这个字段原来有默认值约束，你想保留，
   #也要在modify语句中保留默认值约束，否则就删除了
   alter table 表名称 modify 字段名 数据类型 default 默认值 not null;
   ```

### 三、删除默认值约束

```mysql
alter table 表名称 modify 字段名 数据类型 ;#删除默认值约束，也不保留非空约束
alter table 表名称 modify 字段名 数据类型 not null; #删除默认值约束，保留非空约束
```

# 十三、视图

## 一、常见的数据库对象

|         对象         |                             描述                             |
| :------------------: | :----------------------------------------------------------: |
|      表(TABLE)       | 表是存储数据的逻辑单元，以行和列的形式存在，列就是字段，行就是记录 |
|       数据字典       | 就是系统表，存放数据库相关信息的表。系统表的数据通常由数据库系统维护， 程序员通常不应该修改，只可查看 |
|  约束 (CONSTRAINT)   |         执行数据校验的规则，用于保证数据完整性的规则         |
|      视图(VIEW)      |    一个或者多个数据表里的数据的逻辑显示，视图并不存储数据    |
|     索引(INDEX)      |               用于提高查询性能，相当于书的目录               |
| 存储过程 (PROCEDURE) | 用于完成一次完整的业务处理，没有返回值，但可通过传出参数将多个值传给调用环境 |
|  存储函数(FUNCTION)  |            用于完成一次特定的计算，具有一个返回值            |
|   触发器 (TRIGGER)   | 相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的处理 |

## 二、视图概述

### 一、使用视图的意义

1. 视图一方面可以帮我们使用表的一部分而不是所有的表
2. 另一方面也可以针对不同的用户制定不同的查询视图。比如，针对一个公司的销售人员，我们只想给他看部分数据，而某些特殊的数据，比如采购的 价格，则不会提供给他。再比如，人员薪酬是个敏感的字段，那么只给某个级别以上的人员开放，其他人的查询视图中则不提供这个字段

### 二、视图的理解

1. 视图是一种虚拟表，本身是不具有数据的，占用很少的内存空间，它是SQL中的一个重要概念
2. 视图建立在已有表的基础上, 视图赖以建立的这些表称为基表
3. 视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化，反之亦然
4. 向视图提供数据内容的语句为 SELECT 语句, 可以将视图理解为存储起来的SELECT语句
   - 在数据库中，视图不会保存数据，数据真正保存在数据表中。当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化；反之亦然
5. 视图，是向用户提供基表数据的另一种表现形式。通常情况下，小型项目的数据库可以不使用视图，但是在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，它可以帮助我们把经常查询的结果集放到虚拟表中，提升使用效率。理解和使用起来都非常方便

### 三、创建视图

1. 在CREATE VIEW语句中嵌入子查询

   ```mysql
   CREATE [OR REPLACE]
   [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]
   VIEW 视图名称 [(字段列表)]
   AS 查询语句
   [WITH [CASCADED|LOCAL] CHECK OPTION]
   ```

2. 精简版

   ```mysql
   CREATE VIEW 视图名称
   AS 查询语句
   ```

#### 一、创建单表视图

```mysql
CREATE VIEW empvu80
AS
SELECT employee_id, last_name, salary
FROM employees
WHERE department_id = 80;

CREATE VIEW emp_year_salary (ename,year_salary)
AS
SELECT ename,salary*12*(1+IFNULL(commission_pct,0))
FROM t_employee;

CREATE VIEW salvu50
AS
SELECT employee_id ID_NUMBER, last_name NAME,salary*12 ANN_SALARY
FROM employees
WHERE department_id = 50;

#说明1：实际上就是我们在 SQL 查询语句的基础上封装了视图 VIEW，这样就会基于 SQL 语句的结果集形成一张虚拟表。
#说明2：在创建视图时，没有在视图名后面指定字段列表，则视图中字段列表默认和SELECT语句中的字段列表一致。如果SELECT语句中给字段取了别名，那么视图中的字段名和别名相同
```

#### 二、创建多表联合视图

```mysql
CREATE VIEW emp_dept
AS
SELECT ename,dname
FROM t_employee LEFT JOIN t_department
ON t_employee.did = t_department.did;

CREATE VIEW dept_sum_vu
(name, minsal, maxsal, avgsal)
AS
SELECT d.department_name, MIN(e.salary), MAX(e.salary),AVG(e.salary)
FROM employees e, departments d
WHERE e.department_id = d.department_id
GROUP BY d.department_name;
```

#### 三、基于视图创建视图

```mysql
CREATE VIEW emp_dept_ysalary
AS
SELECT emp_dept.ename,dname,year_salary
FROM emp_dept INNER JOIN emp_year_salary
ON emp_dept.ename = emp_year_salary.ename;
```

### 四、查看视图

1. 查看数据库的表对象、视图对象 

   ```mysql
   SHOW TABLES;
   ```

2. 查看视图的结构 

   ```mysql
   DESC / DESCRIBE 视图名称;
   ```

3. 查看视图的属性信息

   ```mysql
   # 查看视图信息（显示数据表的存储引擎、版本、数据行数和数据大小等）
   SHOW TABLE STATUS LIKE '视图名称'\G
   ```

4. 查看视图的详细定义信息

   ```mysql
   SHOW CREATE VIEW 视图名称;
   ```

### 五、更新数据的数据

#### 一、一般情况

- MySQL支持使用INSERT、UPDATE和DELETE语句对视图中的数据进行插入、更新和删除操作。当视图中的数据发生变化时，数据表中的数据也会发生变化，反之亦然

#### 二、不可更改的视图

虽然可以更新视图数据，但总的来说，视图作为 虚拟表 ，主要用于 方便查询 ，不建议更新视图的数据。对视图数据的更改，都是通过对实际数据表里数据的操作来完成的

要使视图可更新，视图中的行和底层基本表中的行之间必须存在 一对一 的关系。另外当视图定义出现如下情况时，视图不支持更新操作：

- 在定义视图的时候指定了“ALGORITHM = TEMPTABLE”，视图将不支持INSERT和DELETE操作
- 视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持INSERT操作
- 在定义视图的SELECT语句中使用了 JOIN联合查询 ，视图将不支持INSERT和DELETE操作
- 在定义视图的SELECT语句后的字段列表中使用了 数学表达式 或 子查询 ，视图将不支持INSERT，也 不支持UPDATE使用了数学表达式、子查询的字段值
- 在定义视图的SELECT语句后的字段列表中使用 DISTINCT 、 聚合函数 、 GROUP BY 、 HAVING 、UNION 等，视图将不支持INSERT、UPDATE、DELETE
- 在定义视图的SELECT语句中包含了子查询，而子查询中引用了FROM后面的表，视图将不支持 INSERT、UPDATE、DELETE
- 视图定义基于一个 不可更新视图
- 常量视图

### 六、修改、删除视图

#### 一、修改视图

1. 使用CREATE OR REPLACE VIEW 子句修改视图

   ```mysql
   CREATE OR REPLACE VIEW empvu80
   (id_number, name, sal, department_id)
   AS
   SELECT employee_id, first_name || ' ' || last_name, salary, department_id
   FROM employees
   WHERE department_id = 80;
   #说明：CREATE VIEW 子句中各列的别名应和子查询中各列相对应
   ```

2. ALTER VIEW

   ```mysql
   ALTER VIEW 视图名称
   AS
   查询语句
   ```

#### 二、删除视图

1. 删除视图只是删除视图的定义，并不会删除基表的数据

2. 基于视图a、b创建了新的视图c，如果将视图a或者视图b删除，会导致视图c的查询失败。这 

   样的视图c需要手动删除或修改，否则影响使用

3. 删除视图的语法

   ```mysql
   DROP VIEW IF EXISTS 视图名称;
   ```

### 七、视图的优缺点

#### 一、视图的优点

1. 操作简单
   - 将经常使用的查询操作定义为视图，可以使开发人员不需要关心视图对应的数据表的结构、表与表之间的关联关系，也不需要关心数据表之间的业务逻辑和查询条件，而只需要简单地操作视图即可，极大简 化了开发人员对数据库的操作将经常使用的查询操作定义为视图，可以使开发人员不需要关心视图对应的数据表的结构、表与表之间的关联关系，也不需要关心数据表之间的业务逻辑和查询条件，而只需要简单地操作视图即可，极大简化了开发人员对数据库的操作
2. 减少数据冗余
   - 视图跟实际数据表不一样，它存储的是查询语句。所以，在使用的时候，我们要通过定义视图的查询语句来获取结果集。而视图本身不存储数据，不占用数据存储的资源，减少了数据冗余
3. 数据安全
   - MySQL将用户对数据的访问限制在某些数据的结果集上，而这些数据的结果集可以使用视图来实现。用户不必直接查询或操作数据表。这也可以理解为视图具有 隔离性 。视图相当于在用户和实际的数据表之间加了一层虚拟表
   - 同时，MySQL可以根据权限将用户对数据的访问限制在某些视图上，用户不需要查询数据表，可以直接通过视图获取数据表中的信息。这在一定程度上保障了数据表中数据的安全性
4. 适应灵活多变的需求
   - 当业务系统的需求发生变化后，如果需要改动数据表的结构，则工作量相对较大，可以使用视图来减少改动的工作量。这种方式在实际工作中使用得比较多
5. 能够分解复杂的查询逻辑
   - 数据库中如果存在复杂的查询逻辑，则可以将问题进行分解，创建多个视图获取数据，再将创建的多个视图结合起来，完成复杂的查询逻辑

#### 二、视图的缺点

- 如果我们在实际数据表的基础上创建了视图，那么如果实际数据表的结构变更了，我们就需要及时对相关的视图进行相应的维护。特别是嵌套的视图（就是在视图的基础上创建视图），维护会变得比较复杂， 可读性不好 ，容易变成系统的潜在隐患。因为创建视图的 SQL 查询可能会对字段重命名，也可能包含复杂的逻辑，这些都会增加维护的成本
- 实际项目中，如果视图过多，会导致数据库维护成本的问题
- 在创建视图的时候，你要结合实际项目需求，综合考虑视图的优点和不足，这样才能正确使用视图，使系统整体达到最优

# 十四、存储过程与函数

## 一、存储过程概述

### 一、理解

1. 含义：存储过程的英文是 Stored Procedure 。它的思想很简单，就是一组经过预先编译的SQL语句的封装
   - 执行过程：存储过程预先存储在 MySQL 服务器上，需要执行的时候，客户端只需要向服务器端发出调用存储过程的命令，服务器端就可以把预先存储好的这一系列 SQL 语句全部执行
2. 好处：
   - 简化操作，提高了sql语句的重用性，减少了开发程序员的压力 
   - 减少操作过程中的失误，提高效率
   - 减少网络传输量（客户端不需要把所有的 SQL 语句通过网络发给服务器） 
   - 减少了SQL语句暴露在网上的风险，也提高了数据查询的安全性 
3. 和视图、函数的对比
   - 它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。不过它和视图不同，视图是虚拟表，通常不对底层数据表直接操作，而存储过程是程序化的 SQL，可以 直接操作底层数据表 ，相比于面向集 合的操作方式，能够实现一些更复杂的数据处理
   - 一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。相较于函数，存储过程是没有返回值的
4. 分类
   - 没有参数（无参数无返回） 
   - 仅仅带 IN 类型（有参数无返回） 
   - 仅仅带 OUT 类型（无参数有返回） 
   - 既带 IN 又带 OUT（有参数有返回） 
   - 带 INOUT（有参数有返回）
   - 注意点：IN、OUT、INOUT 都可以在一个存储过程中带多个

### 二、创建存储过程

```mysql
CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)
[characteristics ...]
BEGIN
存储过程体
END
```

说明：

1. 参数前面的符号的意思

   - IN ：当前参数为输入参数，也就是表示入参；存储过程只是读取这个参数的值。如果没有定义参数种类， 默认就是 IN ，表示输入参数
   - OUT ：当前参数为输出参数，也就是表示出参；执行完成之后，调用这个存储过程的客户端或者应用程序就可以读取这个参数返回的值了
   - INOUT ：当前参数既可以为输入参数，也可以为输出参数

2. 形参类型可以是 MySQL数据库中的任意类型

3. characteristics表示创建存储过程时指定的对存储过程的约束条件，其取值信息如下：

   ```mysql
   LANGUAGE SQL
   | [NOT] DETERMINISTIC
   | { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }
   | SQL SECURITY { DEFINER | INVOKER }
   | COMMENT 'string'
   ```

   - LANGUAGE SQL ：说明存储过程执行体是由SQL语句组成的，当前系统支持的语言为SQL

   - [NOT] DETERMINISTIC ：指明存储过程执行的结果是否确定。DETERMINISTIC表示结果是确定的。每次执行存储过程时，相同的输入会得到相同的输出。NOT DETERMINISTIC表示结果是不确定的，相同的输入可能得到不同的输出。如果没有指定任意一个值，默认为NOT DETERMINISTIC

   - { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA } ：指明子程序使用SQL语句的限制

     ```mysql
     CONTAINS SQL表示当前存储过程的子程序包含SQL语句，但是并不包含读写数据的SQL语句；
     NO SQL表示当前存储过程的子程序中不包含任何SQL语句；
     READS SQL DATA表示当前存储过程的子程序中包含读数据的SQL语句；
     MODIFIES SQL DATA表示当前存储过程的子程序中包含写数据的SQL语句。
     默认情况下，系统会指定为CONTAINS SQL
     ```

   - SQL SECURITY { DEFINER | INVOKER } ：执行当前存储过程的权限，即指明哪些用户能够执行当前存储过程

     ```mysql
     DEFINER 表示只有当前存储过程的创建者或者定义者才能执行当前存储过程；
     INVOKER 表示拥有当前存储过程的访问权限的用户能够执行当前存储过程。
     如果没有设置相关的值，则MySQL默认指定值为DEFINER
     ```

   - COMMENT 'string' ：注释信息，可以用来描述存储过程

4. 存储过程体中可以有多条SQL语句，如果仅仅一条SQL语句，则可以省略BEGIN和END编写存储过程并不是一件简单的事情，可能存储过程中需要复杂的SQL语句

   ```mysql
   1. BEGIN…END：BEGIN…END 中间包含了多个语句，每个语句都以（;）号为结束符。
   2. DECLARE：DECLARE 用来声明变量，使用的位置在于 BEGIN…END 语句中间，而且需要在其他语句使用之前进
   行变量的声明。
   3. SET：赋值语句，用于对变量进行赋值。
   4. SELECT… INTO：把从数据表中查询的结果存放到变量中，也就是为变量赋值
   ```

5. 需要设置新的结束标记

   ```mysql
   DELIMITER 新的结束标记
   
   #示例
   DELIMITER $
   CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)
   [characteristics ...]
   BEGIN
   sql语句1;
   sql语句2;
   END $
   
   DELIMITER #恢复默认结束标记
   ```

   - 因为MySQL默认的语句结束符号为分号‘;’。为了避免与存储过程中SQL语句结束符相冲突，需要使用DELIMITER改变存储过程的结束符
   - “DELIMITER //”语句的作用是将MySQL的结束符设置为//，并以“END //”结束存储过程。存储过程定义完毕之后再使用“DELIMITER ;”恢复默认结束符。DELIMITER也可以指定其他符号作为结束符
   - 当使用DELIMITER命令时，应该避免使用反斜杠（‘\’）字符，因为反斜线是MySQL的转义字符

### 三、调用存储过程

存储过程有多种调用方法。存储过程必须使用CALL语句调用，并且存储过程和数据库相关，如果要执行其他数据库中的存储过程，需要指定数据库名称，例如CALL dbname.procname

```mysql
CALL 存储过程名(实参列表)
```

1. 调用in模式的参数

   ```mysql
   CALL sp1('值');
   ```

2. 调用out模式的参数

   ```mysql
   SET @name;
   CALL sp1(@name);
   SELECT @name;
   ```

3. 调用inout模式的参数

   ```mysql
   SET @name=值;
   CALL sp1(@name);
   SELECT @name;
   ```

## 二、存储函数的使用

### 一、语法分析

```mysql
CREATE FUNCTION 函数名(参数名 参数类型,...)
RETURNS 返回值类型
[characteristics ...]
BEGIN
函数体 #函数体中肯定有 RETURN 语句
END
```

说明：

1. 参数列表：指定参数为IN、OUT或INOUT只对PROCEDURE是合法的，FUNCTION中总是默认为IN参数
2. RETURNS type 语句表示函数返回数据的类型
   - RETURNS子句只能对FUNCTION做指定，对函数而言这是 强制 的。它用来指定函数的返回类型，而且函数体必须包含一个 RETURN value 语句
3. characteristic 创建函数时指定的对函数的约束。取值与创建存储过程时相同
4. 函数体也可以用BEGIN…END来表示SQL代码的开始和结束。如果函数体只有一条语句，也可以省略BEGIN…END

### 二、调用存储函数

在MySQL中，存储函数的使用方法与MySQL内部函数的使用方法是一样的。换言之，用户自己定义的存储函数与MySQL内部函数是一个性质的。区别在于，存储函数是用户自己定义的，而内部函数是MySQL的开发者定义的

```mysql
SELECT 函数名(实参列表)
```

### 三、对比存储函数和存储过程

|          |  关键字   |    调用语法     |      返回值       |             应用场景             |
| :------: | :-------: | :-------------: | :---------------: | :------------------------------: |
| 存储过程 | PROCEDURE | CALL 存储过程() | 理解为有0个或多个 |           一般用于更新           |
| 存储函数 | FUNCTION  |  SELECT 函数()  |    只能是一个     | 一般用于查询结果为一个值并返回时 |

存储函数可以放在查询语句中使用，存储过程不行。反之，存储过程的功能更加强大，包括能够执行对表的操作（比如创建表，删除表等）和事务操作，这些功能是存储函数不具备的

## 三、存储过程和函数的查看、修改、删除

### 一、查看

1. 使用SHOW CREATE语句查看存储过程和函数的创建信息

   ```mysql
   SHOW CREATE {PROCEDURE | FUNCTION} 存储过程名或函数名
   ```

2. 使用SHOW STATUS语句查看存储过程和函数的状态信息

   ```mysql
   SHOW {PROCEDURE | FUNCTION} STATUS [LIKE 'pattern']
   #[LIKE 'pattern']：匹配存储过程或函数的名称，可以省略。当省略不写时，会列出MySQL数据库中存在的所有存储过程或函数的信息
   ```

3. 从information_schema.Routines表中查看存储过程和函数的信息

   ```mysql
   SELECT * FROM information_schema.Routines
   WHERE ROUTINE_NAME='存储过程或函数的名' [AND ROUTINE_TYPE = {'PROCEDURE|FUNCTION'}];
   
   #如果在MySQL数据库中存在存储过程和函数名称相同的情况，最好指定ROUTINE_TYPE查询条件来指明查询的是存储过程还是函数
   ```

### 二、修改

修改存储过程使用ALTER PROCEDURE语句，修改存储函数使用ALTER FUNCTION语句。但是，这两个语句的结构是一样的，语句中的所有参数也是一样的

修改存储过程或函数，不影响存储过程或函数功能，只是修改相关特性。使用ALTER语句实现

```mysql
ALTER {PROCEDURE | FUNCTION} 存储过程或函数的名 [characteristic ...]
```

其中，characteristic指定存储过程或函数的特性，其取值信息与创建存储过程、函数时的取值信息略有不同

```mysql
{ CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }
| SQL SECURITY { DEFINER | INVOKER }
| COMMENT 'string'
```

1. CONTAINS SQL ，表示子程序包含SQL语句，但不包含读或写数据的语句
2. NO SQL ，表示子程序中不包含SQL语句 
3. READS SQL DATA ，表示子程序中包含读数据的语句
4. MODIFIES SQL DATA ，表示子程序中包含写数据的语句
5. SQL SECURITY { DEFINER | INVOKER } ，指明谁有权限来执行
   - DEFINER ，表示只有定义者自己才能够执行
   - INVOKER ，表示调用者可以执行
6. COMMENT 'string' ，表示注释信息

### 三、删除

```mysql
DROP {PROCEDURE | FUNCTION} [IF EXISTS] 存储过程或函数的名
#IF EXISTS：如果程序或函数不存储，它可以防止发生错误，产生一个用SHOW WARNINGS查看的警告
```

## 四、存储过程的优缺点

### 一、优点

1. 存储过程可以一次编译多次使用。存储过程只在创建时进行编译，之后的使用都不需要重新编译， 这就提升了 SQL 的执行效率
2. 可以减少开发工作量。将代码封装成模块，实际上是编程的核心思想之一，这样可以把复杂的问题拆解成不同的模块，然后模块之间可以重复使用 ，在减少开发工作量的同时，还能保证代码的结构清晰
3. 存储过程的安全性强。我们在设定存储过程的时候可以设置对用户的使用权限 ，这样就和视图一样具有较强的安全性
4. 可以减少网络传输量。因为代码封装到存储过程中，每次使用只需要调用存储过程即可，这样就减少了网络传输量
5. 良好的封装性。在进行相对复杂的数据库操作时，原本需要使用一条一条的SQL语句，可能要连接多次数据库才能完成的操作，现在变成了一次存储过程，只需要连接一次即可

### 二、缺点

1. 可移植性差。存储过程不能跨数据库移植，比如在 MySQL、Oracle 和 SQL Server 里编写的存储过程，在换成其他数据库时都需要重新编写
2. 调试困难。只有少数 DBMS 支持存储过程的调试。对于复杂的存储过程来说，开发和维护都不容易。虽然也有一些第三方工具可以对存储过程进行调试，但要收费
3. 存储过程的版本管理很困难。比如数据表索引发生变化了，可能会导致存储过程失效。我们在开发软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦
4. 它不适合高并发的场景。**高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护， 增加数据库的压力 ，显然就不适用了

# 十五、变量、流程控制与游标

## 一、变量

- 在 MySQL 数据库中，变量分为系统变量 以及用户自定义变量

### 一、系统变量

#### 一、系统变量的分类

- 变量由系统定义，不是用户定义，属于服务器层面。启动MySQL服务，生成MySQL服务实例期间，MySQL将为MySQL服务器内存中的系统变量赋值，这些系统变量定义了当前MySQL服务实例的属性、特征。这些系统变量的值要么是编译MySQL时参数 的默认值，要么是 配置文件 （例如my.ini等）中的参数值
- 系统变量分为全局系统变量（需要添加 global 关键字）以及会话系统变量（需要添加 session 关键字），有时也把全局系统变量简称为全局变量，有时也把会话系统变量称为local变量。如果不写，默认会话级别。静态变量（在 MySQL 服务实例运行期间它们的值不能使用 set 动态修改）属于特殊的全局系统变量
- 每一个MySQL客户机成功连接MySQL服务器后，都会产生与之对应的会话。会话期间，MySQL服务实例会在MySQL服务器内存中生成与该会话对应的会话系统变量，这些会话系统变量的初始值是全局系统变量值的复制
- 全局系统变量针对于所有会话（连接）有效，但不能跨重启
- 会话系统变量仅针对于当前会话（连接）有效。会话期间，当前会话对某个会话系统变量值的修改，不会影响其他会话同一个会话系统变量的值
- 会话1对某个全局系统变量值的修改会导致会话2中同一个全局系统变量值的修改
- 在MySQL中有些系统变量只能是全局的，例如 max_connections 用于限制服务器的最大连接数；有些系统变量作用域既可以是全局又可以是会话，例如 character_set_client 用于设置客户端的字符集；有些系统变量的作用域只能是当前会话，例如 pseudo_thread_id 用于标记当前会话的 MySQL 连接 ID

#### 二、查看系统变量

1. 查看所有或部分系统变量

	```mysql
	#查看所有全局变量
	SHOW GLOBAL VARIABLES;
	
	#查看所有会话变量
	SHOW SESSION VARIABLES;
	或
	SHOW VARIABLES;
	
	#查看满足条件的部分系统变量。
	SHOW GLOBAL VARIABLES LIKE '%标识符%';
	
	#查看满足条件的部分会话变量
	SHOW SESSION VARIABLES LIKE '%标识符%';
	```

2. 查看指定系统变量

	作为 MySQL 编码规范，MySQL 中的系统变量以 两个“@” 开头，其中“@@global”仅用于标记全局系统变量，“@@session”仅用于标记会话系统变量。“@@”首先标记会话系统变量，如果会话系统变量不存在，则标记全局系统变量

	```mysql
	#查看指定的系统变量的值
	SELECT @@global.变量名;
	
	#查看指定的会话变量的值
	SELECT @@session.变量名;
	#或者
	SELECT @@变量名;
	```

3. 修改系统变量的值

	- 修改MySQL 配置文件 ，继而修改MySQL系统变量的值（该方法需要重启MySQL服务）

	- 在MySQL服务运行期间，使用“set”命令重新设置系统变量的值

		```mysql
		#为某个系统变量赋值
		#方式1：
		SET @@global.变量名=变量值;
		#方式2：
		SET GLOBAL 变量名=变量值;
		#为某个会话变量赋值
		#方式1：
		SET @@session.变量名=变量值;
		#方式2：
		SET SESSION 变量名=变量值;
		```

### 二、用户变量

#### 一、用户变量的分类

- 用户变量是用户自己定义的，作为 MySQL 编码规范，MySQL 中的用户变量以 一个“@” 开头。根据作用范围不同，又分为会话用户变量和局部变量
- 会话用户变量：作用域和会话变量一样，只对当前连接会话有效
- 局部变量：只在 BEGIN 和 END 语句块中有效。局部变量只能在存储过程和函数中使用

#### 二、会话用户变量

1. 变量的定义

	```mysql
	#方式1：“=”或“:=”
	SET @用户变量 = 值;
	SET @用户变量 := 值;
	
	#方式2：“:=” 或 INTO关键字
	SELECT @用户变量 := 表达式 [FROM 等子句];
	SELECT 表达式 INTO @用户变量 [FROM 等子句];
	```

2. 查看用户变量的值（查看、比较、运算等）

	```mysql
	SELECT @用户变量
	
	SELECT @num := COUNT(*) FROM employees;
	SELECT @num;
	
	SELECT AVG(salary) INTO @avgsalary FROM employees;
	SELECT @avgsalary;
	
	SELECT @big; #查看某个未声明的变量时，将得到NULL值
	```

#### 三、局部变量

1. 可以使用 DECLARE 语句定义一个局部变量

2. 仅仅在定义它的 BEGIN ... END 中有效

3. 只能放在 BEGIN ... END 中，而且只能放在第一句

	```mysql
	BEGIN
	#声明局部变量
	DECLARE 变量名1 变量数据类型 [DEFAULT 变量默认值];
	DECLARE 变量名2,变量名3,... 变量数据类型 [DEFAULT 变量默认值];
	#为局部变量赋值
	SET 变量名1 = 值;
	SELECT 值 INTO 变量名2 [FROM 子句];
	#查看局部变量的值
	SELECT 变量1,变量2,变量3;
	END
	```

##### 一、定义变量

```mysql
DECLARE 变量名 类型 [default 值]; # 如果没有DEFAULT子句，初始值为NULL
```

##### 二、变量赋值

1. 一般用于赋简单的值

	```mysql
	SET 变量名=值;
	SET 变量名:=值;
	```

2. 一般用于赋表中的字段值

	```mysql
	SELECT 字段名或表达式 INTO 变量名 FROM 表; #一个INTO可以赋值多个变量
	```

##### 三、使用变量

```mysql
SELECT 局部变量名;

#方式1：使用会话用户变量
SET @m=1;
SET @n=1;
SET @sum=@m+@n;
SELECT @sum;


#方式2：使用局部变量
DELIMITER //
CREATE PROCEDURE set_value()
BEGIN
DECLARE emp_name VARCHAR(25);
DECLARE sal DOUBLE(10,2);
SELECT last_name,salary INTO emp_name,sal
FROM employees
WHERE employee_id = 102;
SELECT emp_name,sal;
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE different_salary(IN emp_id INT,OUT dif_salary DOUBLE)
BEGIN
#声明局部变量
DECLARE emp_sal,mgr_sal DOUBLE DEFAULT 0.0;
DECLARE mgr_id INT;
SELECT salary INTO emp_sal FROM employees WHERE employee_id = emp_id;
SELECT manager_id INTO mgr_id FROM employees WHERE employee_id = emp_id;
SELECT salary INTO mgr_sal FROM employees WHERE employee_id = mgr_id;
SET dif_salary = mgr_sal - emp_sal;
END //
DELIMITER ;

#调用
SET @emp_id = 102;
CALL different_salary(@emp_id,@diff_sal);
#查看
SELECT @diff_sal;
```

#### 四、会话用户变量与局部变量对比

|              |       作用域        |      定义位置       |           语法           |
| :----------: | :-----------------: | :-----------------: | :----------------------: |
| 会话用户变量 |      当前会话       |   会话的任何地方    |  加@符号，不用指定类型   |
|   局部变量   | 定义它的BEGIN END中 | BEGIN END的第一句话 | 一般不用加@,需要指定类型 |

## 二、定义条件与处理程序

- 定义条件是事先定义程序执行过程中可能遇到的问题
- 处理程序定义了在遇到问题时应当采取的处理方式，并且保证存储过程或函数在遇到警告或错误时能继续执行。这样可以增强存储程序处理问题的能力，避免程序异常停止运行
- 定义条件和处理程序在存储过程、存储函数中都是支持的

### 一、定义条件

1. 定义条件就是给MySQL中的错误码命名，这有助于存储的程序代码更清晰。它将一个错误名字和指定的错误条件关联起来。这个名字可以随后被用在定义处理程序的 DECLARE HANDLER 语句中

2. 定义条件使用DECLARE语句，语法如下

   ```mysql
   DECLARE 错误名称 CONDITION FOR 错误码（或错误条件）
   ```

3. 错误码的说明

   ```mysql
   #使用MySQL_error_code
   DECLARE Field_Not_Be_NULL CONDITION FOR 1048;
   
   #使用sqlstate_value
   DECLARE Field_Not_Be_NULL CONDITION FOR SQLSTATE '23000';
   ```

   - MySQL_error_code是数值类型错误代码
   - sqlstate_value是长度为5的字符串类型错误代码

### 二、定义处理程序

```mysql
DECLARE 处理方式 HANDLER FOR 错误类型 处理语句
# 这个语法可以翻译为 报错遇到相应的错误类型，则执行处理方式以及处理语句

#方法1：捕获sqlstate_value
DECLARE CONTINUE HANDLER FOR SQLSTATE '42S02' SET @info = 'NO_SUCH_TABLE';
#方法2：捕获mysql_error_value
DECLARE CONTINUE HANDLER FOR 1146 SET @info = 'NO_SUCH_TABLE';
#方法3：先定义条件，再调用
DECLARE no_such_table CONDITION FOR 1146;
DECLARE CONTINUE HANDLER FOR NO_SUCH_TABLE SET @info = 'NO_SUCH_TABLE';
#方法4：使用SQLWARNING
DECLARE EXIT HANDLER FOR SQLWARNING SET @info = 'ERROR';
#方法5：使用NOT FOUND
DECLARE EXIT HANDLER FOR NOT FOUND SET @info = 'NO_SUCH_TABLE';
#方法6：使用SQLEXCEPTION
DECLARE EXIT HANDLER FOR SQLEXCEPTION SET @info = 'ERROR';
```

1. 处理方式：处理方式有3个取值，分别为CONTINUE、EXIT、UNDO
2. 错误类型（即条件）

   - SQLSTATE '字符串错误码' ：表示长度为5的sqlstate_value类型的错误代码
   - MySQL_error_code ：匹配数值类型错误代码
   - 错误名称 ：表示DECLARE ... CONDITION定义的错误条件名称
   - SQLWARNING ：匹配所有以01开头的SQLSTATE错误代码
   - NOT FOUND ：匹配所有以02开头的SQLSTATE错误代码
   - SQLEXCEPTION ：匹配所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE错误代码
3. 处理语句：如果出现上述条件之一，则采用对应的处理方式，并执行指定的处理语句。语句可以是像“ SET 变量 = 值 ”这样的简单语句，也可以是使用 BEGIN ... END 编写的复合语句

### 三、案例

```mysql
#在存储过程中，定义处理程序，捕获sqlstate_value值，当遇到MySQL_error_code值为1048时，执行CONTINUE操作，并且将@proc_value的值设置为-1

DELIMITER //
CREATE PROCEDURE UpdateDataNoCondition()
BEGIN
#定义处理程序
DECLARE CONTINUE HANDLER FOR 1048 SET @proc_value = -1;
SET @x = 1;
UPDATE employees SET email = NULL WHERE last_name = 'Abel';
SET @x = 2;
UPDATE employees SET email = 'aabbel' WHERE last_name = 'Abel';
SET @x = 3;
END //
DELIMITER ;

CALL UpdateDataWithCondition();
```

## 三、流程控制

解决复杂问题不可能通过一个 SQL 语句完成，我们需要执行多个 SQL 操作。流程控制语句的作用就是控制存储过程中SQL 语句的执行顺序，是我们完成复杂操作必不可少的一部分。只要是执行的程序，流程就分为三大类：

- 顺序结构：程序从上往下依次执行 
- 分支结构：程序按条件进行选择执行，从两条或多条路径中选择一条执行
- 循环结构：程序满足一定条件下，重复执行一组语句

针对于MySQL 的流程控制语句主要有 3 类。注意：只能用于**存储程序**

- 条件判断语句：IF 语句和 CASE 语句
- 循环语句：LOOP、WHILE 和 REPEAT 语句
- 跳转语句：ITERATE 和 LEAVE 语句 

### 一、分支结构之IF

1. IF语法结构

   ```mysql
   IF 表达式1 THEN 操作1
   [ELSEIF 表达式2 THEN 操作2]……
   [ELSE 操作N]
   END IF
   
   #根据表达式的结果为TRUE或FALSE执行相应的语句。这里“[]”中的内容是可选的
   ```

2. IF特点

   - 不同的表达式对应不同的操作
   - 使用在begin end中

### 二、分支结构之CASE

CASE语法结构

```mysql
#情况一：类似于switch
CASE 表达式
WHEN 值1 THEN 结果1或语句1(如果是语句，需要加分号)
WHEN 值2 THEN 结果2或语句2(如果是语句，需要加分号)
...
ELSE 结果n或语句n(如果是语句，需要加分号)
END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）

#情况二：类似于多重if
CASE
WHEN 条件1 THEN 结果1或语句1(如果是语句，需要加分号)
WHEN 条件2 THEN 结果2或语句2(如果是语句，需要加分号)
...
ELSE 结果n或语句n(如果是语句，需要加分号)
END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）
```

### 三、循环结构之LOOP

LOOP循环语句用来重复执行某些语句。LOOP内的语句一直重复执行直到循环被退出（使用LEAVE子句），跳出循环过程

```mysql
[loop_label:] LOOP
循环执行的语句
END LOOP [loop_label]

#其中，loop_label表示LOOP语句的标注名称，该参数可以省略

DECLARE id INT DEFAULT 0;
add_loop:LOOP
SET id = id +1;
IF id >= 10 THEN LEAVE add_loop;
END IF;
END LOOP add_loop;
```

### 四、循环结构之WHILE

WHILE语句创建一个带条件判断的循环过程。WHILE在执行语句执行时，先对指定的表达式进行判断，如果为真，就执行循环内的语句，否则退出循环

```mysql
[while_label:] WHILE 循环条件 DO
循环体
END WHILE [while_label];

#while_label为WHILE语句的标注名称；如果循环条件结果为真，WHILE语句内的语句或语句群被执行，直至循环条件为假，退出循环

DELIMITER //
CREATE PROCEDURE test_while()
BEGIN
DECLARE i INT DEFAULT 0;
WHILE i < 10 DO
SET i = i + 1;
END WHILE;
SELECT i;
END //
DELIMITER ;
#调用
CALL test_while();
```

### 五、循环结构之REPEAT

REPEAT语句创建一个带条件判断的循环过程。与WHILE循环不同的是，REPEAT 循环首先会执行一次循环，然后在UNTIL 中进行表达式的判断，如果满足条件就退出，即 END REPEAT；如果条件不满足，则会就继续执行循环，直到满足退出条件为止

```mysql
[repeat_label:] REPEAT
循环体的语句
UNTIL 结束循环的条件表达式（最后不加分号）
END REPEAT [repeat_label]

#repeat_label为REPEAT语句的标注名称，该参数可以省略；REPEAT语句内的语句或语句群被重复，直至expr_condition为真

DELIMITER //
CREATE PROCEDURE test_repeat()
BEGIN
DECLARE i INT DEFAULT 0;
REPEAT
SET i = i + 1;
UNTIL i >= 10
END REPEAT;
SELECT i;
END //
DELIMITER ;
```

### 六、三种循环结构对比

1. 这三种循环都可以省略名称，但如果循环中添加了循环控制语句（LEAVE或ITERATE）则必须添加名称
2. 具体的用法
   - LOOP：一般用于实现简单的"死"循环
   - WHILE：先判断后执行
   - REPEAT：先执行后判断，无条件至少执行一次
3. 循环结构具备的要素
   - 初始化条件
   - 循环条件
   - 循环体
   - 迭代条件

### 七、跳转语句之LEAVE语句

LEAVE语句：可以用在循环语句内，或者以 BEGIN 和 END 包裹起来的程序体内，表示跳出循环或者跳出程序体的操作。可以把 LEAVE 理解为 break

```mysql
#基本语法
LEAVE 标记名
#其中，label参数表示循环的标志。LEAVE和BEGIN ... END或循环一起被使用

DELIMITER //
CREATE PROCEDURE leave_begin(IN num INT)
begin_label: BEGIN
IF num<=0
THEN LEAVE begin_label;
ELSEIF num=1
THEN SELECT AVG(salary) FROM employees;
ELSEIF num=2
THEN SELECT MIN(salary) FROM employees;
ELSE
SELECT MAX(salary) FROM employees;
END IF;
SELECT COUNT(*) FROM employees;
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE leave_while(OUT num INT)
BEGIN
DECLARE avg_sal DOUBLE;#记录平均工资
DECLARE while_count INT DEFAULT 0; #记录循环次数
SELECT AVG(salary) INTO avg_sal FROM employees; #① 初始化条件
while_label:WHILE TRUE DO #② 循环条件
#③ 循环体
IF avg_sal <= 10000 THEN
LEAVE while_label;
END IF;
UPDATE employees SET salary = salary * 0.9;
SET while_count = while_count + 1;
#④ 迭代条件
SELECT AVG(salary) INTO avg_sal FROM employees;
END WHILE;
#赋值
SET num = while_count;
END //
DELIMITER ;
```

### 八、跳转语句之ITERATE语句

ITERATE语句：只能用在循环语句（LOOP、REPEAT和WHILE语句）内，表示重新开始循环，将执行顺序转到语句段开头处。可以把 ITERATE 理解为 continue

```mysql
#基本语法
ITERATE label
#label参数表示循环的标志。ITERATE语句必须跟在循环标志前面

DELIMITER //
CREATE PROCEDURE test_iterate()
BEGIN
DECLARE num INT DEFAULT 0;
my_loop:LOOP
SET num = num + 1;
IF num < 10
THEN ITERATE my_loop;
ELSEIF num > 15
THEN LEAVE my_loop;
END IF;
SELECT '尚硅谷：让天下没有难学的技术';
END LOOP my_loop;
END //
DELIMITER ;
```

## 四、游标

### 一、游标的含义

- 游标，提供了一种灵活的操作方式，让我们能够对结果集中的每一条记录进行定位，并对指向的记录中的数据进行操作的数据结构。游标让SQL这种面向集合的语言有了面向过程开发的能力
- 在 SQL 中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标充当了指针的作用，我们可以通过操作游标来对数据行进行操作
- MySQL中游标可以在存储过程和函数中使用
- 游标类似于Java中迭代器，利于操作集合中的每一条数据

### 二、游标的使用步骤

游标必须在声明处理程序之前被声明，并且变量和条件还必须在声明游标或处理程序之前被声明

1. 声明游标

   ```mysql
   DECLARE cursor_name CURSOR FOR select_statement;
   #此语法在MySQL，SQL Server，DB2 和 MariaDB中都适用
   
   DECLARE cursor_name CURSOR IS select_statement;
   #此语法适用于Oracle 或者 PostgreSQL
   
   #要使用 SELECT 语句来获取数据结果集，而此时还没有开始遍历数据，这里 select_statement 代表的是SELECT 语句，返回一个用于创建游标的结果集
   ```

2. 打开游标

   ```mysql
   OPEN cursor_name
   #当我们定义好游标之后，如果想要使用游标，必须先打开游标。打开游标的时候 SELECT 语句的查询结果集就会送到游标工作区，为后面游标的逐条读取结果集中的记录做准备
   ```

3. 使用游标（从游标中取得数据）

   ```mysql
   FETCH cursor_name INTO var_name [, var_name] ...
   #这句的作用是使用 cursor_name 这个游标来读取当前行，并且将数据保存到 var_name 这个变量中，游标指针指到下一行。如果游标读取的数据行有多个列名，则在 INTO 关键字后面赋值给多个变量名即可
   #var_name必须在声明游标之前就定义好
   #游标的查询结果集中的字段数，必须跟 INTO 后面的变量数一致，否则，在存储过程执行的时候，MySQL 会提示错误
   ```

4. 关闭游标

   ```mysql
   CLOSE cursor_name
   #当我们使用完游标后需要关闭掉该游标。因为游标会占用系统资源 ，如果不及时关闭，游标会一直保持到存储过程结束，影响系统运行的效率。而关闭游标的操作，会释放游标占用的系统资源
   #关闭游标之后，我们就不能再检索查询结果中的数据行，如果需要检索只能再次打开游标
   ```

### 三、游标的案例

```mysql
#创建存储过程“get_count_by_limit_total_salary()”，声明IN参数 limit_total_salary，DOUBLE类型；声明OUT参数total_count，INT类型。函数的功能可以实现累加薪资最高的几个员工的薪资值，直到薪资总和达到limit_total_salary参数的值，返回累加的人数给total_count
DELIMITER //
CREATE PROCEDURE get_count_by_limit_total_salary(IN limit_total_salary DOUBLE,OUT
total_count INT)
BEGIN
DECLARE sum_salary DOUBLE DEFAULT 0; #记录累加的总工资
DECLARE cursor_salary DOUBLE DEFAULT 0; #记录某一个工资值
DECLARE emp_count INT DEFAULT 0; #记录循环个数
#定义游标
DECLARE emp_cursor CURSOR FOR SELECT salary FROM employees ORDER BY salary DESC;
#打开游标
OPEN emp_cursor;
REPEAT
#使用游标（从游标中获取数据）
FETCH emp_cursor INTO cursor_salary;
SET sum_salary = sum_salary + cursor_salary;
SET emp_count = emp_count + 1;
UNTIL sum_salary >= limit_total_salary
END REPEAT;
SET total_count = emp_count;
#关闭游标
CLOSE emp_cursor;
END //
DELIMITER ;
```

### 四、游标的优缺点

1. 优点
   - 游标是 MySQL 的一个重要的功能，为 逐条读取 结果集中的数据，提供了完美的解决方案。跟在应用层面实现相同的功能相比，游标可以在存储程序中使用，效率高，程序也更加简洁
2. 缺点
   - 也会带来一些性能问题，比如在使用游标的过程中，会对数据行进行加锁 ，这样在业务并发量大的时候，不仅会影响业务之间的效率，还会消耗系统资源 ，造成内存不足，这是因为游标是在内存中进行的处理
3. 建议
   - 养成用完之后就关闭的习惯，这样才能提高系统的整体效率

## 五、全局变量的持久化

- 使用SET GLOBAL语句设置的变量值只会 临时生效 。 数据库重启后，服务器又会从MySQL配置文件中读取变量的默认值。 MySQL 8.0版本新增了 SET PERSIST 命令

  ```mysql
  SET PERSIST global max_connections = 1000;
  ```

- MySQL会将该命令的配置保存到数据目录下的 mysqld-auto.cnf 文件中，下次启动时会读取该文件，用其中的配置来覆盖默认的配置文件

# 十六、触发器

## 一、触发器概述

- 触发器是由事件来触发某个操作，这些事件包括 INSERT 、 UPDATE 、 DELETE 事件。所谓事件就是指用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生了，就会自动激发触发器执行相应的操作
- 当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来实现

## 二、触发器的创建

### 一、创建触发器语法

```mysql
CREATE TRIGGER 触发器名称
{BEFORE|AFTER} {INSERT|UPDATE|DELETE} ON 表名
FOR EACH ROW
触发器执行的语句块;
```

1. 表名：表示触发器监控的对象
2. BEFORE|AFTER：表示触发的时间。BEFORE表示在事件之前触发；AFTER表示在事件之后触发
3. INSERT|UPDATE|DELETE：表示触发的事件
   - INSERT：表示插入记录时触发
   - UPDATE：表示更新记录时触发
   - DELETE：表示删除记录时触发
4. 触发器执行的语句块：可以是单条SQL语句，也可以是由BEGIN...END结构组成的复合语句块

### 二、触发器使用案例

```mysql
DELIMITER //
CREATE TRIGGER salary_check_trigger
BEFORE INSERT ON employees FOR EACH ROW
BEGIN
DECLARE mgrsalary DOUBLE;
SELECT salary INTO mgrsalary FROM employees WHERE employee_id = NEW.manager_id;
IF NEW.salary > mgrsalary THEN
SIGNAL SQLSTATE 'HY000' SET MESSAGE_TEXT = '薪资高于领导薪资错误';
END IF;
END //
DELIMITER ;
```

1. 触发器声明过程中的NEW关键字代表INSERT添加语句的新记录
2. 触发器声明过程中的OLD关键字代表UPDATE|DELETE更新或删除语句的旧记录

## 三、查看触发器

查看触发器是查看数据库中已经存在的触发器的定义、状态和语法信息等

1. 查看当前数据库的所有触发器的定义

   ```mysql
   SHOW TRIGGERS\G #在cmd命令中使用\G，在数据库图形化界面中使用“;”
   ```

2. 查看当前数据库中某个触发器的定义

   ```mysql
   SHOW CREATE TRIGGER 触发器名\G #在cmd命令中使用\G，在数据库图形化界面中使用“;”
   ```

3. 从系统库information_schema的TRIGGERS表中查询“salary_check_trigger”触发器的信息

   ```mysql
   SELECT * FROM information_schema.TRIGGERS\G #在cmd命令中使用\G，在数据库图形化界面中使用“;”
   ```

## 四、删除触发器

```mysql
DROP TRIGGER IF EXISTS 触发器名称;
```

## 五、触发器的优缺点

### 一、优点

1. 触发器可以保证数据的完整性
2. 触发器可以帮助我们记录操作日志
3. 触发器还可以用在操作数据前，对数据进行合法性检查

### 二、缺点

1. 可读性差
   - 因为触发器存储在数据库中，并且由事件驱动，这就意味着触发器有可能不受应用层的控制 。这对系统维护是非常有挑战的
2. 相关数据的变更，可能会导致触发器出错
   - 特别是数据表结构的变更，都可能会导致触发器出错，进而影响数据操作的正常运行。这些都会由于触发器本身的隐蔽性，影响到应用中错误原因排查的效率

### 三、注意点

- 如果在子表中定义了外键约束，并且外键指定了ON UPDATE/DELETE CASCADE/SET NULL子句，此时修改父表被引用的键值或删除父表被引用的记录行时，也会引起子表的修改和删除操作，此时基于子表的UPDATE和DELETE语句定义的触发器并不会被激活

# 十七、MySQL其他新特性

## 一、MySQL8新特性概述

### 一、MySQL8新增特性

1. 更简便的NoSQL支持：NoSQL泛指非关系型数据库和数据存储。随着互联网平台的规模飞速发展，传统的关系型数据库已经越来越不能满足需求。从5.6版本开始，MySQL就开始支持简单的NoSQL存储功能。MySQL 8对这一功能做了优化，以更灵活的方式实现NoSQL功能，不再依赖模式（schema）
2. 更好的索引：在查询中，正确地使用索引可以提高查询的效率。MySQL8中新增了隐藏索引和降序索引 。隐藏索引可以用来测试去掉索引对查询性能的影响。在查询中混合存在多列索引时，使用降序索引可以提高查询的性能
3. 更完善的JSON支持：MySQL从5.7开始支持原生JSON数据的存储，MySQL8对这一功能做了优化，增加了聚合函数 JSON_ARRAYAGG()和JSON_OBJECTAGG() ，将参数聚合为JSON数组或对象，新增了行内操作符 ->>，是列路径运算符 ->的增强，对JSON排序做了提升，并优化了JSON的更新操作
4. 安全和账户管理：MySQL8中新增了caching_sha2_password授权插件、角色、密码历史记录和FIPS模式支持，这些特性提高了数据库的安全性和性能，使数据库管理员能够更灵活地进行账户管理工作
5. InnoDB支持：InnoDB是MySQL默认的存储引擎 ，是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。在MySQL 8 版本中，InnoDB在自增、索引、加密、死锁、共享锁等方面做了大量的 改进和优化 ，并且支持原子数据定义语言（DDL），提高了数据安全性，对事务提供更好的支持
6. 数据字典：在之前的MySQL版本中，字典数据都存储在元数据文件和非事务表中。从MySQL 8开始新增了事务数据字典，在这个字典里存储着数据库对象信息，这些数据字典存储在内部事务表中
7. 原子数据定义语句：MySQL8开始支持原子数据定义语句（Automic DDL），即原子DDL。目前，只有InnoDB存储引擎支持原子DDL。原子数据定义语句（DDL）将与DDL操作相关的数据字典更新、存储引擎操作、二进制日志写入结合到一个单独的原子事务中，这使得即使服务器崩溃，事务也会提交或回滚。使用支持原子操作的存储引擎所创建的表，在执行DROP TABLE、CREATE TABLE、ALTER TABLE、RENAME TABLE、TRUNCATE TABLE、CREATE TABLESPACE、DROP TABLESPACE等操作时，都支持原子操作，即事务要么完全操作成功，要么失败后回滚，不再进行部分提交。 对于从MySQL5.7复制到MySQL8版本中的语句，可以添加 IF EXISTS 或 IF NOT EXISTS 语句来避免发生错误
8. 资源管理：MySQL 8开始支持创建和管理资源组，允许将服务器内运行的线程分配给特定的分组，以便线程根据组内可用资源执行。组属性能够控制组内资源，启用或限制组内资源消耗。数据库管理员能够根据不同的工作负载适当地更改这些属性。目前，CPU时间是可控资源，由“虚拟CPU”这个概念来表示，此术语包含CPU的核心数，超线程，硬件线程等等。服务器在启动时确定可用的虚拟CPU数量。拥有对应权限的数据库管理员可以将这些CPU与资源组关联，并为资源组分配线程。 资源组组件为MySQL中的资源组管理提供了SQL接口。资源组的属性用于定义资源组。MySQL中存在两个默认组，系统组和用户组，默认的组不能被删除，其属性也不能被更改。对于用户自定义的组，资源组创建时可初始化所有的属性，除去名字和类型，其他属性都可在创建之后进行更改。 在一些平台下，或进行了某些MySQL的配置时，资源管理的功能将受到限制，甚至不可用。例如，如果安装了线程池插件，或者使用的macOS系统，资源管理将处于不可用状态。在FreeBSD和Solaris系统中，资源线程优先级将失效。在Linux系统中，只有配置了CAP_SYS_NICE属性，资源管理优先级才能发挥作用
9. 字符集支持：MySQL 8中默认的字符集由 latin1 更改为 utf8mb4 ，并首次增加了日语所特定使用的集合，utf8mb4_ja_0900_as_cs
10. 优化器增强：MySQL优化器开始支持隐藏索引和降序索引。隐藏索引不会被优化器使用，验证索引的必要性时不需要删除索引，先将索引隐藏，如果优化器性能无影响就可以真正地删除索引。降序索引允许优化器对多个列进行排序，并且允许排序顺序不一致
11. 公用表表达式：公用表表达式（Common Table Expressions）简称为CTE，MySQL现在支持递归和非递归两种形式的CTE。CTE通过在SELECT语句或其他特定语句前 使用WITH语句对临时结果集进行命名
12. 窗口函数：MySQL8开始支持窗口函数。在之前的版本中已存在的大部分聚合函数在MySQL8中也可以作为窗口函数来使用
13. 正则表达式支持：MySQL在8.0.4以后的版本中采用支持Unicode的国际化组件库实现正则表达式操作，这种方式不仅能提供完全的Unicode支持，而且是多字节安全编码。MySQL增加了REGEXP_LIKE()、 EGEXP_INSTR()、REGEXP_REPLACE()和 REGEXP_SUBSTR()等函数来提升性能。另外，regexp_stack_limit和regexp_time_limit系统变量能够通过匹配引擎来控制资源消耗
14. 内部临时表：TempTable存储引擎取代MEMORY存储引擎成为内部临时表的默认存储引擎 。TempTable存储引擎为VARCHAR和VARBINARY列提供高效存储。internal_tmp_mem_storage_engine会话变量定义了内部临时表的存储引擎，可选的值有两个，TempTable和MEMORY，其中TempTable为默认的存储引擎。temptable_max_ram系统配置项定义了TempTable存储引擎可使用的最大内存数量
15. 日志记录：在MySQL 8中错误日志子系统由一系列MySQL组件构成。这些组件的构成由系统变量log_error_services来配置，能够实现日志事件的过滤和写入
16. 备份锁：新的备份锁允许在线备份期间执行数据操作语句，同时阻止可能造成快照不一致的操作。新备份锁由 LOCK INSTANCE FOR BACKUP 和 UNLOCK INSTANCE 语法提供支持，执行这些操作需要备份管理员特权
17. 增强的MySQL复制：MySQL8复制支持对JSON文档进行部分更新的二进制日志记录 ，该记录使用紧凑的二进制格式，从而节省记录完整JSON文档的空间。当使用基于语句的日志记录时，这种紧凑的日志记录会自动完成，并且可以通过将新的binlog_row_value_options系统变量值设置为PARTIAL_JSON来启用

### 二、MySQL8移除的旧特性

在MySQL 5.7版本上开发的应用程序如果使用了MySQL8.0移除的特性，语句可能会失败，或者产生不同的执行结果。为了避免这些问题，对于使用了移除特性的应用，应当尽力修正避免使用这些特性，并尽可能使用替代方法

1. 查询缓存：查询缓存已被移除，删除项有：
   - 语句：FLUSH QUERY CACHE和RESET QUERY CACHE
   - 系统变量：query_cache_limit、query_cache_min_res_unit、query_cache_size、query_cache_type、query_cache_wlock_invalidate
   - 状态变量：Qcache_free_blocks、Qcache_free_memory、Qcache_hits、Qcache_inserts、Qcache_lowmem_prunes、Qcache_not_cached、Qcache_queries_in_cache、Qcache_total_blocks
   - 线程状态：checking privileges on cached query、checking query cache for query、invalidating query cache entries、sending cached result to client、storing result in query cache、waiting for query cache lock
2. 加密相关
   - 删除的加密相关的内容有：ENCODE()、DECODE()、ENCRYPT()、DES_ENCRYPT()和DES_DECRYPT()函数，配置项des-key-file，系统变量have_crypt，FLUSH语句的DES_KEY_FILE选项，HAVE_CRYPT CMake选项。 对于移除的ENCRYPT()函数，考虑使用SHA2()替代，对于其他移除的函数，使用AES_ENCRYPT()和AES_DECRYPT()替代
3. 空间函数相关
   - 在MySQL 5.7版本中，多个空间函数已被标记为过时。这些过时函数在MySQL8中都已被 移除，只保留了对应的ST_和MBR函数
4. \N和NULL
   - 在SQL语句中，解析器不再将\N视为NULL，所以在SQL语句中应使用NULL代替\N。这项变化不会影响使用LOAD DATA INFILE或者SELECT...INTO OUTFILE操作文件的导入和导出。在这类操作中，NULL仍等同于\N
5. mysql_install_db
   - 在MySQL分布中，已移除了mysql_install_db程序，数据字典初始化需要调用带着--initialize或者--initialize-insecure选项的mysqld来代替实现。另外，--bootstrap和INSTALL_SCRIPTDIR CMake也已被删除
6. 通用分区处理程序
   - 通用分区处理程序已从MySQL服务中被移除。为了实现给定表分区，表所使用的存储引擎需要自有的分区处理程序。 提供本地分区支持的MySQL存储引擎有两个，即InnoDB和NDB，而在MySQL8中只支持InnoDB
7. 系统和状态变量信息
   - 在INFORMATION_SCHEMA数据库中，对系统和状态变量信息不再进行维护。GLOBAL_VARIABLES、SESSION_VARIABLES、GLOBAL_STATUS、SESSION_STATUS表都已被删除。另外，系统变量show_compatibility_56也已被删除。被删除的状态变量有Slave_heartbeat_period、 Slave_last_heartbeat,Slave_received_heartbeats、Slave_retried_transactions、Slave_running。以上被删除的内容都可使用性能模式中对应的内容进行替代
8. mysql_plugin工具
   - mysql_plugin工具用来配置MySQL服务器插件，现已被删除，可使用--plugin-load或--plugin-load-add选项在服务器启动时加载插件或者在运行时使用INSTALL PLUGIN语句加载插件来替代该工具

## 二、窗口函数

### 一、使用窗口函数前后对比

- 使用窗口函数，只用了一步就完成了查询。而且，由于没有用到临时表，执行的效率也更高了。很显然，在这种需要用到分组统计的结果对每一条记录进行计算的场景下，使用窗口函数更好

### 二、窗口函数的分类

1. MySQL从8.0版本开始支持窗口函数。窗口函数的作用类似于在查询中对数据进行分组，不同的是，分组操作会把分组的结果聚合成一条记录，而窗口函数是将结果置于每一条数据记录中

2. 窗口函数可以分为静态窗口函数和动态窗口函数

   - 静态窗口函数的窗口大小是固定的，不会因为记录的不同而不同
   - 动态窗口函数的窗口大小会随着记录的不同而变化

3. 窗口函数总体上可以分为序号函数、分布函数、前后函数、首尾函数和其他函数

   | 函数分类 |       函数        |                           函数说明                           |
   | :------: | :---------------: | :----------------------------------------------------------: |
   | 序号函数 |   ROW_NUMBER()    |                           顺序排序                           |
   | 序号函数 |      RANK()       |        并列排序，会跳过重复的序号，比如序号为1、1、3         |
   | 序号函数 |   DENSE_RANK()    |       并列排序，不会跳过重复的序号，比如序号为1、1、2        |
   | 分布函数 |  PERCENT_RANK()   | 等级值百分比，计算方式为(rank - 1) / (rows - 1)，其中，rank的值为使用RANK()函数产生的序号，rows的值为当前窗口的总记录数 |
   | 分布函数 |    CUME_DIST()    |        累积分布值，主要用于查询小于或等于某个值的比例        |
   | 前后函数 |    LAG(expr,n)    |                 返回当前行的前n行的expr的值                  |
   | 前后函数 |   LEAD(expr,n)    |                 返回当前行的后n行的expr的值                  |
   | 首位函数 | FIRST_VALUE(expr) |                      返回第一个expr的值                      |
   | 首位函数 | LAST_VALUE(expr)  |                     返回最后一个expr的值                     |
   | 其他函数 | NTH_VALUE(expr,n) |                      返回第n个expr的值                       |
   | 其他函数 |     NTILE(n)      |           将分区中的有序数据分为n个桶，记录桶编号            |

### 三、语法结构

```mysql
函数 OVER（[PARTITION BY 字段名 ORDER BY 字段名 ASC|DESC]）
#或
函数 OVER 窗口名 … WINDOW 窗口名 AS （[PARTITION BY 字段名 ORDER BY 字段名 ASC|DESC]）
```

1. OVER 关键字指定函数窗口的范围
   - 如果省略后面括号中的内容，则窗口会包含满足WHERE条件的所有记录，窗口函数会基于所有满足WHERE条件的记录进行计算
   - 如果OVER关键字后面的括号不为空，则可以使用如下语法设置窗口
2. 窗口名：为窗口设置一个别名，用来标识窗口
3. PARTITION BY子句：指定窗口函数按照哪些字段进行分组。分组后，窗口函数可以在每个分组中分别执行
4. ORDER BY子句：指定窗口函数按照哪些字段进行排序。执行排序操作使窗口函数按照排序后的数据记录的顺序进行编号
5. FRAME子句：为分区中的某个子集定义规则，可以用来作为滑动窗口使用

### 四、窗口函数优点

- 窗口函数的特点是可以分组，而且可以在分组内排序。另外，窗口函数不会因为分组而减少原表中的行数，这对我们在原表数据的基础上进行统计和排序非常有用

## 三、公用表表达式

- 公用表表达式（或通用表表达式）简称为CTE（Common Table Expressions）。CTE是一个命名的临时结果集，作用范围是当前语句。CTE可以理解成一个可以复用的子查询，当然跟子查询还是有点区别的，CTE可以引用其他CTE，但子查询不能引用其他子查询。所以，可以考虑代替子查询 
- 依据语法结构和执行方式的不同，公用表表达式分为普通公用表表达式和递归公用表表达式2种

### 一、普通公用表表达式

普通公用表表达式类似于子查询，不过，跟子查询不同的是，它可以被多次引用，而且可以被其他的普通公用表表达式所引用

公用表表达式可以起到子查询的作用。以后如果遇到需要使用子查询的场景，你可以在查询之前，先定义公用表表达式，然后在查询中用它来代替子查询。而且，跟子查询相比，公用表表达式有一个优点，就是定义过公用表表达式之后的查询，可以像一个表一样多次引用公用表表达式，而子查询则不能

```mysql
WITH CTE名称
AS （子查询）
SELECT|DELETE|UPDATE 语句;

WITH emp_dept_id
AS (SELECT DISTINCT department_id FROM employees)
SELECT *
FROM departments d JOIN emp_dept_id e
ON d.department_id = e.department_id;
```

### 二、递归公用表表达式

递归公用表表达式也是一种公用表表达式，只不过，除了普通公用表表达式的特点以外，它还有自己的特点，就是可以调用自己

递归公用表表达式由 2 部分组成，分别是种子查询和递归查询，中间通过关键字 UNION [ALL]进行连接。这里的种子查询，意思就是获得递归的初始值。这个查询只会运行一次，以创建初始数据集，之后递归查询会一直执行，直到没有任何新的查询数据产生，递归返回

递归公用表表达式对于查询一个有共同的根节点的树形结构数据，非常有用。它可以不受层级的限制，轻松查出所有节点的数据。如果用其他的查询方式，就比较复杂了

```mysql
WITH RECURSIVE
CTE名称 AS （子查询）
SELECT|DELETE|UPDATE 语句;

WITH RECURSIVE cte
AS
(
SELECT employee_id,last_name,manager_id,1 AS n FROM employees WHERE employee_id = 100
-- 种子查询，找到第一代领导
UNION ALL
SELECT a.employee_id,a.last_name,a.manager_id,n+1 FROM employees AS a JOIN cte
ON (a.manager_id = cte.employee_id) -- 递归查询，找出以递归公用表表达式的人为领导的人
)
SELECT employee_id,last_name FROM cte WHERE n >= 3;
```

### 三、公用表表达式优点

- 公用表表达式的作用是可以替代子查询，而且可以被多次引用
- 递归公用表表达式对查询有一个共同根节点的树形结构数据非常高效，可以轻松搞定其他查询方式难以处理的查询