# 一、数据库概述

## 一、数据库的作用

- 持久化：把数据保存到可掉电式存储设备中以供之后使用，数据持久化意味着将内存中的数据保存到硬盘上加以固化
- 持久化的主要作用是将内存中的数据存储在关系型数据库中

## 二、数据库与数据库管理系统

1. DB：数据库（Database）：即存储数据的仓库，其本质是一个文件提供。保存了一系列有组织的数据
2. DBMS：数据库管理系统（Database Management System）：一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制。用户通过数据库管理系统访问数据库中表内的数据。MySQL就是数据库管理系统的一种
3. SQL：结构化查询语言（Structured Query Language）：专门用来与数据库通信的语言

## 三、Oracle VS MySQL

1. Oracle更适合大型跨国企业的使用，因为他们对费用不敏感，但是对性能要求以及安全性有更高的要求
2. MySQL由于其体积小、速度块、总体拥有成本低，可处理上千万条记录的大型数据库，尤其是开放源码这一特点，使得很多互联网公司、中小型网站选择使用MySQL作为网站数据库

## 四、RDBMS VS 非RDBMS 

### 一、关系型数据库（RDBMS）

1. 实质
	- 关系型数据库模型是把复杂的数据结构归结为简单的二元关系（即二维表格形式）
	- 关系型数据库以row（行）和列（column）的形式存储数据。这一系列的行和列被称为表（table），一组表组成了一个库（database）
	- 表和表之间的数据记录有关系（relationship）。现实世界中的各种实体以及实体之间的各种联系均用关系模式来表示。关系型数据库，就是建立在关系模型基础上的数据库
	- SQL就是关系型数据库的查询语句
2. 优势
	- 复杂查询：可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询
	- 事物支持：使得对于安全性能很高的数据访问要求得以实现

### 二、非关系型数据库（非RDBMS）

1. 实质
	- 非关系型数据库是基于键值对存储数据，不需要经过SQL层的解析，性能非常高、同时通过减少不常用的功能，进一步提高性能
	- 大部分主流的非关系型数据库都是免费的
2. 分类
	- 键值型数据库：键值型数据库通过key-value键值的方式存储数据，其中key和value可以是简单的对象，也可以是复杂的对象。key作为唯一的标识符，优点是查找速度快，在这方面优于关系型数据库，缺点是无法像关系型数据库一样使用条件过滤，如果不知道去哪里找数据，就要遍历所有的键，这样会消耗大量的计算。键值型数据库典型的使用场景是作为没存缓存。Redis是最流行的键值型数据路
	- 文档型数据库：此类数据库可存放并获取文档，可以是xml、json等格式。再数据库中文档作为处理信息的基本单位，一个文档就相当于一条记录、文档数据库所存放的文档就相当于键值数据库所存放的值。MongoDB是最流行的文档型数据库
	- 搜索引擎数据库：虽然关系型数据库采用了索引提升检索效率，但是针对全文索引效率却很低。搜索引擎数据库是应用再搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检索的时候才能保证性能最优。核心原理是“倒排索引”。Elasticsearch是最流行的搜索引擎数据库
	- 列存数据库：列存数据库是相对于行式存储的数据库，而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的I/O，适合于分布式文件系统，不足在于功能相对有限。HBase是最流行的列式数据库
	- 图形数据库

## 五、关系型数据库设计原则

### 一、设计原则

1. 关系型数据库的典型数据结构就是数据表，这些数据表的组成都是结构化的
2. 将数据放到表中，表再放到库中
3. 一个数据库中可以有多个表，每个表都有一个名字，用来标识自己。表名具有唯一性
4. 表具有一些特性，这些特性定义了数据在表中如何存储，类似于Java中类的设计

### 二、表、记录、字段

1. E-R（entity-relationship，实体-联系）模型中的有三个主要概念是：实体集、属性、联系集
2. 一个实体集（class）对应于数据库中的一个表（table）；一个实体（instance）则对应数据库表中的一行（row），也称为一条记录（record）；一个属性（attribute）对应于数据库表中的一列（column）。也称为一个字段（field）。ORM思想（Object Relational Mapping）体现为：
	- 数据库中一个表	<----->	Java或Python中的一个类
	- 表中的一条数据    <----->     类中的一个对象（或实体）
	- 表中的一个列        <----->     类中的一个字段、属性（field）
3. 表的关联关系
	- 表与表之间的数据记录有关系（relationship）。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示
	- 一对一关联（one-to-one）：外键唯一，主表的主键和从表的外键（唯一），形成主外键关系，外键唯一；外键是主键，主表的主键和从表的主键，形成主外键关系
	- 一对多关系（one-to-many）：在从表（多方）创建一个字段，字段作为外键指向主表（一方）的主键
	- 多对多关系（many-to-many）：要表示多对多关系，必须创建第三个表，该表通常称为联接表，它将多对多关系划分为两个一对多关系。将这两个表的主键都插入到第三个表中
	- 自我引用（Self reference）：一个表通过本表的某个字段关联本表

# 二、MySQL下载安装设置

## 一、MySQL下载地址

[Mysql最新下载地址](https://dev.mysql.com/downloads/mysql/)

## 二、MySQL安装步骤

1. 下载Mysql安装包
2. 如若提示缺少VSCode安装包，在[VSCode下载地址](https://learn.microsoft.com/zh-cn/cpp/windows/latest-supported-vc-redist?view=msvc-170#visual-studio-2015-2017-2019-and-2022)下载安装VS即可
3. 傻瓜式安装即可，换一下安装路径

## 三、MySQL登录

1. mysql的启动与关闭命令

	```mysql
	net start mysql(数据库管理软件名称) // 开启数据库
	net stop mysql(数据库管理软件名称) // 关闭数据库
	```

2. mysql的登录

	```mysql
	mysql -u 用户名 =p直接写密码
	mysql -u 用户名 -P 端口号 -h url主机地址 -p // 端口号和url主机地址是3306和本地的数据库可以省略
	```

## 四、MySQL命令行使用

1. show databases;    查询所有的数据库
2. create database 新的数据库名称;    创建新的数据库
3. drop database 数据库名称;    删除数据库
4. use 数据库名;    使用指定的数据库，才能进行以下操作
5. create table 表名(字段名1 字段类型1,字段名2 字段类型2);    创建新的表
6. drop table 表名;    删除表
7. show create database 创建的数据库名称/创建的表名;    查询创建的数据库或表的创建信息
8. show varibles like 'character_%';    查询数据库中所使用的字符集

# 三、基本的SELECT语句

## 一、SQL分类

1. DDL（Data Definition Languages，数据定义语言），这些语言定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除和修改数据库和数据表的结构。主要语句关键字包含：CREAT、DROP、ALTER、RENAME、TRUNCATE等。DDL的操作一旦执行，就不可回滚
2. DML（Data Manipulation Languages，数据操作语言），用于添加、删除、更新和查询数据库记录，并检查数据完整性。主要语句关键字包含：INSERT、DELETE、UPDATE、SELECT等。DML的操作情况，一旦执行，也是不可回滚的，但是，在执行DML之前，执行了SET autocommit = FALSE，则执行的DML操作就可以实现回滚
3. DCL（Data Control Languages，数据控制语言），用于定义数据库、表、字段、用户的访问权限和安全级别。主要语句关键字包含：GRANT、REVOKE、COMMIT、ROLLBACK、SAVEPOINT等

## 二、SQL语言规则与规范

### 一、基本规则

1. SQL可以写在一行或者多行。为了提高可读性，各子句分别写，必要时使用缩进
2. 每条命令以';'、'\g'、'\G'结束
3. 关键字不能被缩写也不能分行
4. 关于标点符号
	- 必须保证所有的()、单引号、双引号是成对结束的
	- 必须使用英文状态下的半角输入方式
	- 字符串型和日期时间类型的数据可以使用单引号（‘’）表示
	- 列的别名，尽量使用双引号（”“），而且不建议省略as

### 二、SQL大小写规范

1. MySQL在Windows环境下是大小写不敏感的
2. MySQL在Linux环境下是大小写敏感的
	- 数据库名、表名、表的别名、变量名严格区分大小写的
	- 关键字、函数名、列名（或字段名）、列的别名（字段的别名）是忽略大小写的
3. 推荐采用统一的书写规范
	- 数据库名、表名、表别名、字段名、字段别名等都小写
	- SQL关键字、函数名、绑定变量等都大写

### 三、注释

```mysql
单行注释：#注释文字（MySQL特有的方式）
单行注释：-- 注释文字（--后面必须包含一个空格）
多行注释：/* 注释文字 */
```

### 四、命名规则

1. 数据库、表名不得超过30个字符，变量名限制为29个
2. 必须只能包含A-Z、a-z、0-9、_共63个字符
3. 数据库名、表名、字段名等对象名中间不要包含空格
4. 同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名
5. 必须保证字段不能和保留字、数据库系统或常用方法冲突。如果坚持使用，在SQL语句中使用``（着重号）引起来
6. 保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性、假如数据类型在一个表里是整型，那在另一个表里就别变成字符型

## 三、导入SQL文件方式

1. source 文件的全路径名称
2. 基于图形化工具导入

## 四、最基本的SELECT语句

1. SELECT */字段名1，字段名2…… FROM 表名
	- *：表的全字段
	- 若只查询不用表名的数据，则FROM和表名可以省略
2. 列的别名
	- AS：全称alias（别名），可以省略
	- 列的别名可以使用一对”“引起来
3. 去除重复行
	- DISTINCT：去重关键字，去除重复数据
	- DISTINCT关键字要紧跟SELECT，如果后面有多个字段，则去重的规则是每一行所有的字段加起来去掉重复的数据，而不是单独字段去重
4. 空值参与运算
	- 空值：null
	- null不等同于0、''、’null‘
	- null值参与运算时，结果也是null
	- MySQL可以使用IFNULL将null值替换为指定的数据
5. 着重号
	- 字段、表名等自定义的和保留字、数据库系统或常用方法冲突。如果坚持使用，在SQL语句中使用``（着重号）引起来
6. 查询常数
	- 相当于写死数据
7. 显示表结构
	- 使用DESCRIBE或DESC命令+表名，表示表结构
	- 显示表中字段的详细信息
8. 过滤数据
	- 使用WHERE关键字
	- WHERE需要声明在FROM后，ORDER BY之前

# 四、运算符

## 一、算术运算符

1. 加法与减法运算符（+、-）
	- 一个整数类型的值对整数进行加法和减法操作，结果还是一个整数
	- 一个整数类型的值对浮点数进行加法和减法操作，结果是一个浮点数
	- 加法和减法的优先级相同，进行先加后减操作与进行先减后加操作的结果是一样的
	- 在Java中，+的左右两边如果有字符串，那么表示字符串的拼接。但是在MySQL中+只表示数值相加。如果遇到非数值类型，先尝试转成数值，如果转失败，就按0计算。（MySQL中字符串拼接要使用字符串函数CONCAT()实现）
2. 乘法与除法运算符（*、/或div）
	- 一个数乘以整数1和除以整数1后仍得原数
	- 一个数乘以浮点数1和除以浮点数1后变成浮点数，数值与原数相等
	- 一个数除以整数后，不管是否能除尽，结果都为一个浮点数
	- 一个数除以另一个数，除不尽时，结果为一个浮点数，并保留到小数点后4位
	- 乘法和除法的优先级相同，进行先乘后除与先除后乘操作，得出的结果相同
	- 在数学运算中，0不能用作除数，在MySQL中，一个数除以0为NULL
3. 取模运算（%或mode）
	- 取模的正负号取决于被模数的正负号
	- 被模数也就是%前后的数据

## 二、非算术运算符

1. =、<=>、<>或!=、<、<=、>、>=

	- 等于运算符（=）判断等号两边的值、字符串或表达式是否相等，如果相等则返回1，不相等则返回0
	- 如果等号两边的值、字符串或表达式都为字符串，则MySQL会按照字符串进行比较，其比较的是每个字符串中字符的ANSI编码是否相等
	- 如果等号两边的值都是整数，则MySQL会按照整数来比较两个值的大小
	- 如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较
	- 如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL
	- SQL中赋值符号使用:=
	- 安全等于运算符（<=>）与等于运算符（=）的作用是相似的，唯一的区别是<=>可以用来对NULL进行判断。在两个操作数均为NULL时，其返回值为1，而不为NULL；当一个操作数为NULL时，其返回值为0，而不为NULL。安全等于运算符（<=>）为NULL而生。若使用安全等于运算符查询不等于的数据规则为：NOT 字段名 <=> NULL

2. IS NULL、IS NOT NULL、LEAST、GREATEST、BETWEEN AND、ISNULL、IN、NOT IN、LIKE、REGEXP、RLIKE

	- IS NULL：查询某字段是NULL的数据

	- IS NOT NULL：查询某字段不是NULL的数据

	- ISNULL(字段名) 函数：查询某字段是NULL的数据

	- LEAST(多个字段名) 函数：查询多个字段中最小的数据。数值值则按照数值比较大小；如果对比字段的值都为字符串，则MySQL会按照字符串进行比较，其比较的是每个字符串中字符的ANSI编码的大小

	- GREATEST(多个字段名) 函数：查询某字段中最大的数据。数值值则按照数值比较大小；如果对比字段的值都为字符串，则MySQL会按照字符串进行比较，其比较的是每个字符串中字符的ANSI编码的大小

	- BETWEEN 条件1 AND 条件2：查询条件1和条件2范围内的数据，包含边界。条件1为下限；条件2为上限，且不能交换。不在条件1和条件2区间的写法为：字段名 NOT BETWEEN 条件1 AND 条件2，不包含边界

	- IN(set集合)：查询某字段在set集合中的数据

	- NOT IN(set集合)：查询某字段不在set集合中的数据

	- LIKE：模糊查询。%代表不确定个数（0-多个）的字符；_代表一个不确定的字符；\代表转义字符

	- REGEXP\RLIKE：REGEXP运算符用来匹配字符串，语法格式为：expr REGEXP 匹配条件、如果expr满足匹配条件，返回1；如果不满足，则返回0。若expr或匹配条件任意一个为NULL，则结果为NULL

		```mysql
		'^'匹配以该字符后面的字符开头的字符串
		'$'匹配以该字符前面的字符结尾的字符串
		'.'匹配任何一个单字符
		'[...]'匹配在方括号内的任何字符。例如，"[abc]"匹配"a"或"b"或"c"、为了命名字符的范围，使用一个'-'，"[a-z]"匹配任何字母，"[0-9]"匹配任何数字
		'*'匹配零个或多个在它前面的字符。例如，'x*'匹配任何数量的'x'字符，"[0-9]*"匹配任何数量的数字，而"*"匹配任何数量的任何字符
		```

3. 逻辑运算符

	- 逻辑与（AND或&&）：并且条件
	- 逻辑或（OR或||）：选择条件。逻辑与的优先级低于逻辑与
	- 逻辑非（NOT或!）：
	- 逻辑异或（XOR）： 给定的值中任意一个值为NULL时，则返回NULL；  如果两个非NULL的值都是0或者都不等于0时，则返回0；  如果一个值为0，另一个值不为0时，则返回1。相等于两个条件只需满足其中的一个条件即可，两个都满足也不行

4. 位运算符：在二进制数上进行计算的运算符。位运算符会先将操作数变成二进制，然后进行位运算符，最后将计算结果从二进制变成十进制

	- &：按位与（位AND），当给定值对应的二进制位的数值都为1时，则该位返回1，否则返回0 
	- |：按位或（位OR）， 当给定值对应的二进制位的数值有一个或两个为1时，则该位返回1，否则返回0 
	- ^：按位异或（位XOR），当给定值对应的二进制位的数值不同时，则该位返回1，否则返回0 
	- ~：按位取反（）， 给定的值的二进制数逐位进行取反操作，即将1变为0，将0变为1 
	- `>>`：按位右移，右移指定的位数后，右边低位的数值被移出并丢弃，左边高位空出的位置用0补齐，每向y右移动一位数据除以2
	- `<<`：按位左移， 左移指定的位数后，左边高位的数值被移出并丢弃，右边低位空出的位置用0补齐，每向左移动一位数据乘以2

# 五、排序与分页

## 一、排序

1. 如果没有使用排序操作，默认情况下查询语句返回的数据是按照添加数据的顺序显示的
2. 使用ORDER BY进行排序
3. 升序使用ASC，默认升序；降序使用DESC
4. 可以使用列的别名进行排序。列的别名只能在ORDER BY中使用，不能再WHERE中使用
5. WHERE需要声明在FROM后，ORDER BY之前
6. 可以使用不在SELECT列表中的列排序
7. 在对多列进行排序的时候，首先排序的的第一列必须有相同的列值，才会对第二列进行排序。如果第一列数据中所有值都是唯一的，将不再对第二列进行排序
8. SQL的执行顺序
   - 先执行FROM语句
   - 再执行WHERE语句
   - 然后执行SELECT语句
   - 最后执行ORDER BY语句

## 二、分页

1. 使用LIMIT实现数据的分页显示
2. LIMIT 偏移量,条数：偏移量表示从偏移量+1位数据开始查询，查指定条数的数据
3. MySQL8新特性：LIMIT 条数 OFFSET 偏移量
4. 分页公式：每页显示pageSize条记录，此时显示第pageNo页，则公式为LIMIT (pageNo-1)*pageSize,pageSize

# 六、多表查询

## 一、笛卡尔积

1. 笛卡尔积是一个数学运算。假设有两个集合X和Y，那么X和Y的笛卡尔积就是X和Y的所有可能组合，也就是第一个对象来自于X，第二个对象来自于Y的所有可能。组合的个数即为两个集合中元素个数的乘积数

   ```mysql
   -- 此时查询出来的数据条数为sys_user的个数乘以sys_dept的个数，前表每一条数据都与后表每一条数据关联
   SELECT user_id,dept_id
   FROM sys_user,sys_dept
   ```

2. 笛卡尔积称为交叉连接，英文为CROSS JOIN，在SQL中也使用CROSS JOIN进行连接，它的作用就是可以把任意表进行连接，即使这两张表不相关

3. SQL中出现笛卡尔积的情况

   - 省略多个表的连接条件（或关联条件）
   - 连接条件（或关联条件）无效
   - 所有表中的所有行互相连接

## 二、多表查询的建议和规范

1. 如果查询语句中出现了多个表中都存在的字段，则必须指明此字段所在的表
2. 从SQL优化的角度，建议多表查询时，每个字段前都指明其所在的表
3. 可以给表起别名，如果给表起了别名，在使用此表时必须使用别名，不能再使用原表名
4. 如果有n个表实现多表的查询，则需要至少n-1个连接条件

## 三、多表查询的分类

### 一、等值连接 VS 非等值连接

1. 等值连接：使用=连接查询条件
2. 非等值连接：使用=之外的运算符连接查询条件

### 二、自连接 VS 非自连接

1. 自连接：本表连接本表
2. 非自连接：本表连接外表

### 三、内连接 VS 外连接

1. 内连接：合并具有同一列的两个以上的表的行，结果集中不包含一个表与另一个表不匹配的行

   - 使用JOIN ON进行连接

2. 外连接：合并具有同一列的两个以上的表的行，结果集中除了包含一个表与另一个表匹配的行之外，还查询到了左表或右表中不匹配的行

   - 左外连接：两个表在连接过程中除了返回满足连接条件的行以外还返回左表中不满足条件的行。使用LEFT　JOIN ON进行连接

   - 右外连接：两个表在连接过程中除了返回满足连接条件的行以外还返回右表中不满足条件的行。使用RIGHT

     JOIN ON进行连接

   - 满外连接：两个表在连接过程中除了返回满足连接条件的行以外还返回左表和右表中不满足条件的行。使用FULL JOIN ON进行连接。但是在MySQL中不支持，可以使用UNION或UNION ALL操作进行数据拼合

## 四、实现七种JOIN操作

![查询分类](../../../TyporaImage/SQL JOINS.png)

## 五、UNION操作

1. 利用UNION关键字，可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并时，两个表对应的列数和数据类型必须相同，并且相互对应。各个SELECT语句之间使用UNION或UNION ALL关键字分割
2. UNION操作符：UNION操作符返回两个查询的结果集的并集，去除重复记录
3. UNION ALL操作符：UNION ALL操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重
4. UNION ALL操作语句所需的资源比UNION操作语句少。如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复数据，则尽量使用UNION ALL操作语句，以提高数据查询的效率

## 六、SQL99新特性

- NATURAL JOIN：会自动查询两张（只能用于两张表）连接表中所有相同的字段，然后进行等值连接

	```mysql
	SELECT * FROM sys_user_role
	NATURAL JOIN sys_role
	```

- JOIN...USING：USING指定了具体的相同的字段名称，需要在USING的括号()中填入要指定的同名字段，必须同名。同时使用JOIN...USING可以简化JOIN ON的等值连接

	```mysql
	SELECT * FROM sys_user_role
	LEFT JOIN sys_role USING(role_id)
	```

# 七、函数

## 一、单行函数

### 一、单行函数的含义

1. 操作数据对象
2. 接受参数返回一个结果
3. 只对一行进行变换
4. 每行返回一个结果
5. 可以嵌套
6. 参数可以是一列或一个值

### 二、数值函数

#### 一、基本函数

![MySQl基本数值函数](../../../TyporaImage/MySQL%E5%9F%BA%E6%9C%AC%E6%95%B0%E5%80%BC%E5%87%BD%E6%95%B0.png)

#### 二、角度与弧度互换函数

![角度与弧度互换函数](../../../TyporaImage/MySQL%E6%95%B0%E5%80%BC%E5%87%BD%E6%95%B0%E8%A7%92%E5%BA%A6%E4%B8%8E%E5%BC%A7%E5%BA%A6%E4%BA%92%E6%8D%A2%E5%87%BD%E6%95%B0.png)

#### 三、三角函数

![三角函数](../../../TyporaImage/MySQL%E6%95%B0%E5%80%BC%E5%87%BD%E6%95%B0%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0.png)

#### 四、指数与对数

![MySQL数值函数指数与对数](../../../TyporaImage/MySQL%E6%95%B0%E5%80%BC%E5%87%BD%E6%95%B0%E6%8C%87%E6%95%B0%E4%B8%8E%E5%AF%B9%E6%95%B0.png)

#### 五、进制间的转换

![MySQL数值函数进制间的转换](../../../TyporaImage/MySQL%E6%95%B0%E5%80%BC%E5%87%BD%E6%95%B0%E8%BF%9B%E5%88%B6%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.png)

### 三、字符串函数

![MySQL字符串函数1](../../../TyporaImage/MySQL%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B01.png)

![MySQl字符串函数2](../../../TyporaImage/MySQL%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B02.png)

![MySQL字符串函数3](../../../TyporaImage/MySQL%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B03.png)

### 四、日期和时间函数

1. 获取日期、时间

	![MySQL获取日期、时间](../../../TyporaImage/MySQL%E8%8E%B7%E5%8F%96%E6%97%A5%E6%9C%9F%E3%80%81%E6%97%B6%E9%97%B4.png)

2. 日期与时间戳的转换

	![MySQL日期与时间戳的转换](../../../TyporaImage/MySQL%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4%E6%88%B3%E7%9A%84%E8%BD%AC%E6%8D%A2.png)

3. 获取月份、星期、星期数、天数等函数

	![MySQL获取月份、星期、星期数、天数等函数](../../../TyporaImage/MySQL%E8%8E%B7%E5%8F%96%E6%9C%88%E4%BB%BD%E3%80%81%E6%98%9F%E6%9C%9F%E3%80%81%E6%98%9F%E6%9C%9F%E6%95%B0%E3%80%81%E5%A4%A9%E6%95%B0%E7%AD%89%E5%87%BD%E6%95%B0.png)

4. 日期的操作函数

	![MySQL日期的操作函数](../../../TyporaImage/MySQL%E6%97%A5%E6%9C%9F%E7%9A%84%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0.png)

5. 时间和秒钟转换的函数

	![MySQL时间和秒钟转换的函数](../../../TyporaImage/MySQL%E6%97%B6%E9%97%B4%E5%92%8C%E7%A7%92%E9%92%9F%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%87%BD%E6%95%B0.png)

6. 计算日期和时间的函数

	![MySQl计算日期和时间的函数](../../../TyporaImage/MySQL%E8%AE%A1%E7%AE%97%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E7%9A%84%E5%87%BD%E6%95%B01.png)

	![MySQL计算日期和时间的函数](../../../TyporaImage/MySQL%E8%AE%A1%E7%AE%97%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E7%9A%84%E5%87%BD%E6%95%B02.png)

7. 日期的格式化与解析

	![MySQL日期的格式化与解析](../../../TyporaImage/MySQL%E6%97%A5%E6%9C%9F%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8E%E8%A7%A3%E6%9E%901.png)

	​	 非GET_FORMAT()函数中frmt参数常用的格式符

	​	 ![MySQL日期的格式化与解析2](../../../TyporaImage/MySQL%E6%97%A5%E6%9C%9F%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8E%E8%A7%A3%E6%9E%902.png)

	​     GET_FORMAT()函数中frmt参数常用的格式符

	​	 ![MySQL日期的格式化与解析3](../../../TyporaImage/MySQl%E6%97%A5%E6%9C%9F%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8E%E8%A7%A3%E6%9E%903.png)

### 五、流程控制函数

![MySQL流程控制函数](../../../TyporaImage/MySQL%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0.png)

### 六、加密与解密函数

![MySQL加密解密函数](../../../TyporaImage/MySQL%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%87%BD%E6%95%B0.png)

### 七、MySQL信息函数

![MySQL信息函数](../../../TyporaImage/MySQL%E4%BF%A1%E6%81%AF%E5%87%BD%E6%95%B0.png)

### 八、其他函数

![MysQl其他函数](../../../TyporaImage/MySQL%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0.png)

## 二、聚合函数

### 一、聚合函数的含义

- 聚合函数作用于一组数据，并对一组数据返回一个值
- 聚合函数在MySQL中不能嵌套使用，但是在ORACLE中可以使用。比如不能出现类似“AVG(SUM(字段名称))”形式的调用

### 二、AGE和SUM函数

- 可以对数值型数据使用AGE和SUM函数

### 三、MIN和MAX函数

- 可以对任意数据类型的数据使用MIN和MAX函数

### 四、COUNT函数

1. COUNT(*)返回表中记录总数，适用于任意数据类型
2. COUNT(任一数字)返回表中记录总数，适用于任意数据类型，任何数字COUNT()后返回的结果都是一样
3. COUNT(expr)返回expr不为空的记录总数，其中expr为表中的任一字段
   - 如果使用的是MyISAM存储引擎，则COUNT(*)、COUNT(1)和COUNT(expr)的效率是相同的，都是O(1)
   - 如果使用的是InnoDB存储引擎，则COUNT(*)=COUNT(1)>COUNT(expr)

### 五、GROUP BY

1. GROUP BY的作用：可以使用GROUP BY子句将表中的数据分为若干组

2. GROUP BY使用注意点

   - GROUP BY中使用字段的先后顺序对结果并不会产生影响
   - GROUP BY不一定要和聚合函数一起配合使用
   - 在SELECT列表中所有未包含在组函数中的列都应该包含在GROUP BY子句中。人话为SELECT中出现的非组函数的字段必须声明在GROUP BY中，反之，GROUP BY中声明的字段可以不出现在SELECT中

3. MySQL使用GROUP BY中的WITH ROLLUP

   ```mysql
   SELECT dept_id,AVG(salary) avg_sal FROM employees GROUP BY dept_id WITH ROLLUP;
   ```

   - 使用WITH ROLLUP关键字之后，在所有查询到的分组记录之后增加一条记录，该记录计算查询出的所有记录的总和，即统计记录数量
   - 当使用WITH ROLLUP时，不能同时使用ORDER BY子句进行结果排序，即WITH ROLLUP和ORDER BY是互相排斥的

### 六、HAVING

1. HAVING用于过滤数据
2. 如果过滤条件中使用了聚合函数，则必须使用HAVING来替换WHERE，当然WHERE和HAVING可以配合使用，只是HWERE条件中不能出现聚合函数，而HAVING过滤条件可以出现非聚合函数。一般带有聚合函数的过滤条件放在HAVING里面，未有聚合函数的过滤条件放在WHERE里面，因为WHERE的执行效率高
3. HAVING必须声明在GROUP BY的后面。当前HAVING也可以单独使用在非HAVING的查询语句中，但是没有实际开发意义，因为聚合函数没有分组，只会出现一个结果再去过滤就意义不大了
4. WHERE和HAVING的对比
	- WHERE可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件；HAVING建议要与GROUP BY配合使用，可以把分组计算的函数和分组字段作为筛选条件
	- 如果需要通过连接从关联表中获取需要的数据，WHERE是先筛选后连接，而HAVING是先连接后筛选

### 七、SELECT执行过程

1. 查询语法结构

	```mysql
	SELECT ...,....,...------------------------------>
	FROM ... JOIN ...-------------------------------->FROM从哪些表中筛选
	ON 多表的连接条件--------------------------------->ON关联多表查询时，去除笛卡尔积
	JOIN ...
	ON ...
	WHERE 不包含组函数的过滤条件---------------------->WHERE从表中筛选的条件
	AND/OR 不包含组函数的过滤条件
	GROUP BY ...,...-------------------------------->GROUP BY分组依据
	HAVING 包含组函数的过滤条件----------------------->HAVING在统计结果中再次筛选
	ORDER BY ... ASC/DESC--------------------------->ORDER BY排序
	LIMIT ...,...----------------------------------->LIMIT分页
	```

2. 查询执行顺序

	```mysql
	FROM  -> JOIN -> ON -> 
	WHERE -> 
	GROUP BY -> HAVING -> 
	SELECT 的字段 -> DISTINCT ->
ORDER BY -> LIMIT
	```

	在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个 虚拟表 ，然后将这个虚拟表传入下一个步骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的
	
	```
	SELECT 是先执行 FROM 这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤：
		1. 首先先通过 CROSS JOIN 求笛卡尔积，相当于得到虚拟表 vt（virtual table）1-1；
		2. 通过 ON 进行筛选，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表 vt1-2；
		3. 添加外部行。如果我们使用的是左连接、右链接或者全连接，就会涉及到外部行，也就是在虚拟表 vt1-2 		的基础上增加外部行，得到虚拟表 vt1-3。
	当然如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得到是我们的原始数据。
	
	当我们拿到了查询数据表的原始数据，也就是最终的虚拟表 vt1 ，就可以在此基础上再进行 WHERE 阶段 。在这个阶段中，会根据 vt1 表的结果进行筛选过滤，得到虚拟表 vt2 。
	
	然后进入第三步和第四步，也就是 GROUP 和 HAVING 阶段 。在这个阶段中，实际上是在虚拟表 vt2 的
	基础上进行分组和分组过滤，得到中间的虚拟表 vt3 和 vt4 。
	
	当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到 SELECT 和 DISTINCT阶段 。
	
	首先在 SELECT 阶段会提取想要的字段，然后在 DISTINCT 阶段过滤掉重复的行，分别得到中间的虚拟表vt5-1 和 vt5-2 。
	
	当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是 ORDER BY 阶段 ，得到虚拟表 vt6 。
	
	最后在 vt6 的基础上，取出指定行的记录，也就是 LIMIT 阶段 ，得到最终的结果，对应的是虚拟表vt7 。
	```

# 八、子查询

## 一、子查询的含义

- 子查询指一个查询语句嵌套在另一个查询语句内部的查询
- SQL中子查询的使用大大增强了SELECT查询的能力，因为很多时候查询需要从结果集中获取数据，或者需要从同一个表中先计算出一个数据结果，然后与这个数据结果（可能是某个标量，也可能是某个集合）进行比较

## 二、子查询的基本使用

1. 子查询（内查询）在主查询之前一次执行完成
2. 子查询的结果被主查询（外查询）使用
3. 注意事项
   - 子查询要包含在括号内
   - 将子查询放在比较条件的右侧
   - 单行操作符对应单行子查询，多行操作符对应多行子查询

## 三、子查询的分类

### 一、分类方式一

- 按照内查询的结果返回一条还是多条记录，将子查询分为单行子查询、多行子查询

### 二、分类方式二

1. 按照内查询是否被执行多次，将子查询划分为相关（或关联）子查询和不相关（或非关联）子查询
2. 子查询从数据表中查询了数据结果，如果这个数据结果只执行了一次，然后这个数据结果作为主查询的条件进行执行，那么这样的子查询叫做不相关子查询
3. 如果子查询需要执行多次，即采用循环的方式，先从外部查询开始，每次都传入子查询进行查询，然后再将结果反馈给外部，这种嵌套的执行方式就称为相关子查询

## 四、单行子查询

### 一、单行比较操作符

![MySQL单行比较操作符](../../../TyporaImage/MySQL单行比较操作符.png)

### 二、WHERE中的子查询

```mysql
SELECT employee_id, manager_id, department_id
FROM employees
WHERE manager_id =
				(SELECT manager_id
				 FROM employees
				 WHERE employee_id = 174)
AND department_id =
				(SELECT department_id
				 FROM employees
				 WHERE employee_id = 174))
AND employee_id = 174;
```

### 三、HAVING中的子查询

1. 首先执行子查询
2. 向主查询中的HAVING子句返回结果

```mysql
SELECT department_id, MIN(salary)
FROM employees
GROUP BY department_id
HAVING MIN(salary) >
				(SELECT MIN(salary)
				 FROM employees
				 WHERE department_id = 50);
```

### 四、CASE中的子查询

```mysql
SELECT employee_id, last_name,
(CASE department_id
WHEN
(SELECT department_id FROM departments
WHERE location_id = 1800)
THEN 'Canada' ELSE 'USA' END) location
FROM employees;
```

### 五、FROM中的子查询

- FROM中使用子查询相当于建立了一张临时表，此此查询必须使用括号并加别名

## 五、多行子查询

### 一、多行比较操作符 

![MySQL多行比较操作符](../../../TyporaImage/MySQL多行比较操作符.png)

1. IN：等于列表中的任意一个

   ```mysql
   SELECT employee_id, manager_id, department_id
   FROM employees
   WHERE manager_id IN
   				(SELECT manager_id
   				 FROM employees
   				 WHERE employee_id IN (174,141))
   AND department_id IN
   				(SELECT department_id
   				 FROM employees
   				 WHERE employee_id IN (174,141))
   AND employee_id NOT IN(174,141);
   ```

2. ANY：需要和单行比较操作符一起使用，和子查询返回的某一个值比较

   ```mysql
   SELECT employee_id, manager_id, department_id
   FROM employees
   WHERE salary < ANY
   				(SELECT salary
   				 FROM employees
   				 WHERE employee_id IN (174,141))
   ```

3. ALL：需要和单行比较操作符一起使用，和子查询返回的所有值比较

   ```mysql
   SELECT employee_id, manager_id, department_id
   FROM employees
   WHERE salary < ALL
   				(SELECT salary
   				 FROM employees
   				 WHERE employee_id IN (174,141))
   ```

4. SOME：实际上是ANY的别名，作用相同，一般常使用ANY

### 二、空值问题

1. 无论是在单行子查询还是多行子查询中都需要注意空值问题
2. 如果是操作子查询中出现空值，则整体查询语句可能会查不出数据。所以尽量在子查询中去除空值

## 六、相关子查询

### 一、相关子查询的含义

- 如果子查询的执行流程依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为 关联子查询

### 二、相关子查询的执行流程

1. GET：从主查询中获取候选列
2. EXECUTE：子查询使用主查询的数据
3. USE：如果满足子查询的条件则返回该行

### 三、子查询的适用位置

- 除了GROUP BY和LIMIT之外的地方，都可以声明子查询

### 四、EXISTS与NOT EXISTS关键字

1. 如果在子查询中不存在满足条件的行
   - 条件返回FALSE
   - 继续在子查询中查找
2. 如果在子查询中存在满足条件的行
   - 不在子查询中继续查找
   - 条件返回TRUE
3. NOT EXISTS关键字表示如果不存在某种条件，则返回TRUE，否则返回FALSE

```mysql
# 查询公司管理者的employee_id，last_name，job_id，department_id信息
SELECT employee_id, last_name, job_id, department_id
FROM employees e1
WHERE EXISTS 
			( SELECT *
			  FROM employees e2
			  WHERE e2.manager_id = e1.employee_id);
# 其中在子查询中只要满足 e2.manager_id = e1.employee_id 就会返回TRUE,e1.employee_id相对应的行就会被查询出来
# 子查询中的SELECT查询的字段名称无所谓，用什么都行
```

# 九、创建和管理表

## 一、标识符命名规则

- 数据库名、表名不得超过30个字符，变量名限制为29个
- 必须只能包含 A–Z, a–z, 0–9, _共63个字符 
- 数据库名、表名、字段名等对象名中间不要包含空格 
- 同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名 
- 必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用`（着重号）引起来 
- 保持字段名和类型的一致性：在命名字段并为其指定数据类型的时候一定要保证一致性，假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了 

## 二、创建和管理数据库

### 一、创建数据库

注意：DATABASE 不能改名。一些可视化工具可以改名，它是建新库，把所有表复制到新库，再删旧库完成的

```mysql
#方式一：创建的数据库使用的是默认的字符集
CREATE DATABASE 数据库名;
#方式二：显示指明了要创建的数据库的字符集
CREATE DATABASE 数据库名 CHARACTER SET 字符集;
#方式三：判断数据库是否已经存在，不存在则创建数据库
CREATE DATABASE IF NOT EXISTS 数据库名 CHARACTER SET 字符集;
```

### 二、管理数据库

```mysql
#查看当前所有的数据库
SHOW DATABASES;
#查看当前正在使用的数据库
SELECT DATABASE();
#查看指定库下所有的表
SHOW TABLES FROM 数据库名
#查看数据库的创建信息
SHOW CREATE DATABASE 数据库名;
SHOW CREATE DATABASE 数据库名\G
#使用/切换数据库
USE 数据库名;

#更改数据库字符集
SHOW CREATE DATABASE 数据库名

#删除数据库
DROP DATABASE 数据库名
DROP DATABASE IF EXISTS 数据库名
```

## 三、创建和管理表

### 一、创建表

1. 创建表的前提

   - CREATE TABLE权限
   - 存储空间

2. 创建表的规则

   - 必须指定的有表名，列名（或字段名）、数据类型、长度
   - 可选指定的有约束条件和默认值

3. 语法格式

   ```mysql
   #方式一：创建库中不存在的表
   CREATE TABLE [IF NOT EXISTS] 表名(
   字段1, 数据类型 [约束条件] [默认值],
   字段2, 数据类型 [约束条件] [默认值],
   字段3, 数据类型 [约束条件] [默认值],
   ……
   [表约束条件]
   );
   
   #方式二：基于查询语句查询到的字段创建表2，并导入数据（若不想导入数据，则添加where 1=2这样的条件即可）
   CREATE TABLE 表2
   AS
   SELECT 字段1，字段2......
   FROM 表1
   ```

### 二、修改表

```mysql
#查询表的结构
DESC 表名
#修改表
ALTER TABLE
#添加一个字段，默认新加的字段加到表的最后，也可以指明为首位或者某个字段后
ALTER TABLE 表名 ADD 需要添加的字段名 字段类型 FIRST（AFTER 指定的字段）
#修改一个字段，数据类型（一般不会修改）、长度、默认值
ALTER TABLE 表名 MODIFY 需要修改的字段名 字段类型(字段长度) DEFAULT 默认值
#重命名字段，重命名操作中包含修改字段的操作
ALTER TABLE 表名 CHANGE 原字段名称 新字段名称 字段类型
#删除某字段
ALTER TABLE 表名 DROP COLUMN 字段名
```

### 三、重命名表

```mysql
RENAME TABLE 原表名 TO 新表名 
ALTER TABLE 原表名 RENAME TO 新表名
```

### 四、删除表

```mysql
DROP TABLE IF EXISTS 表名
```

### 五、清空表

- TRUNCATE：实现对表中数据的删除，没有where条件，同时保留表结构。一旦执行此操作，数据不可回滚。TRUNCATE执行速度快，且使用的系统和事物日志资源少，但TRUNCATE无事物且不触发TRIGGER，有可能造成事故，故不建议在开发代码中使用此语句
- DELETE：实现对数据的删除，可以有where条件，同时保留表结构。一旦执行此操作，数据可以回滚，但是数据库设置了SET autocommit=TRUE，则执行的DELETE操作就不可以实现回滚

```mysql
TRUNCATE TABLE 表名
DELETE FROM 表名
```

## 四、COMMIT&ROLLBACK

1. COMMIT：提交数据。一旦执行commit，则数据就被永久的保存在数据库中，意味着数据不可以回滚
2. ROLLBACK：回滚数据。一旦执行ROLLBACK，则可以实现数据的回滚。回滚到最近的一次COMMIT之后

# 十、数据处理之增删改

## 一、添加数据

```mysql
#方式一：一条一条的添加数据，且没有指明要添加的字段，数据顺序要与表中字段顺序保持一致
INSERT INTO 表名 VALUES(字段1数据,字段2数据....)

#方式一：一条一条的添加数据，且指明要添加的字段，数据顺序要与指明的字段顺序保持一致
INSERT INTO 表名(字段1,字段2....) VALUES(字段1数据,字段2数据....)

#方式三：同时插入多行数据
INSERT INTO 表名(字段1,字段2....) 
VALUES
(字段1数据,字段2数据....),
(字段1数据,字段2数据....)

#方式三：将查询结果插入到表中，不必写VALUES子句，但子查询中的值列表应与INSERT子句中的列名对应
INSERT INTO 表名(字段1,字段2....)
SELECT 字段1,字段2....
FROM 源表名
WHERE 
```

## 二、更新数据

```mysql
#修改同一行数据中的某个字段
UPDATE 表名 SET 字段名 = 数据 WHERE 

#修改同一行数据中的多个字段
UPDATE 表名 SET 字段名1=数据1,字段名2=数据2 WHERE
```

## 三、删除数据

```mysql
DELETE FROM 表名 WHERE 
```

## 四、MySQL8新特性：计算列

- 简单来说就是某一行的值是通过别的列计算得来的。例如，a列值为1、b列值为2，c列不需要手动插入，定义a+b的结果为c的值，那么c就是计算列，是通过别的列计算得来的
- 新增或更新a和b时会自动更新c

```mysql
CREATE TABLE tb1(
id INT,
a INT,
b INT,
c INT GENERATED ALWAYS AS (a + b) VIRTUAL
);
```

# 十一、MySQL数据类型

## 一、MySQL中的字段类型

![MySQL字段类型](../../../TyporaImage/MySQl字段类型.png)

![MySQL常见数据类型属性](../../../TyporaImage/MySQL常见数据类型属性.png)

## 二、整数类型

### 一、类型介绍

![MySQL整数类型](../../../TyporaImage/MySQL整数类型.png)

### 二、可选属性

1. M
   - 表示显示宽度，M的取值范围是(0, 255)。例如，int(5)：当数据宽度小于5位的时候在数字前面需要用 字符填满宽度。该项功能需要配合“ ZEROFILL ”使用，表示用“0”填满宽度，否则指定显示宽度无效。符号位也占用一个宽度
   - 如果设置了显示宽度，那么插入的数据宽度超过显示宽度限制，不会对插入的数据有任何影响，还是按照类型的实际宽度进行保存，即显示宽度与类型可以存储的值范围无关 。从MySQL 8.0.17开始，整数数据类型不推荐使用显示宽度属性
   - 整型数据类型可以在定义表结构时指定所需要的显示宽度，如果不指定，则系统为每一种类型指定默认的宽度值
2. UNSIGNED
   - 无符号类型（非负），所有的整数类型都有一个可选的属性UNSIGNED（无符号属性），无 符号整数类型的最小取值为0
   - 如果需要在MySQL数据库中保存非负整数值时，可以将整数类型设置为无符号类型
   - int类型默认显示宽度为int(11)，无符号int类型默认显示宽度为int(10)
3. ZEROFILL
   - 0填充,（如果某列是ZEROFILL，那么MySQL会自动为当前列添加UNSIGNED属性），如果指定了ZEROFILL只是表示不够M位时，用0在左边填充，如果超过M位，只要不超过数据存储范围即可
   - 在 int(M) 中，M 的值跟 int(M) 所占多少存储空间并无任何关系。 int(3)、int(4)、int(8) 在磁盘上都是占用 4 bytes 的存储空间。也就是说，int(M)，必须和UNSIGNED ZEROFILL一起使用才有意义。如果整数值超过M位，就按照实际位数存储。只是无须再用字符 0 进行填充

### 三、适用场景

- TINYINT ：一般用于枚举数据，比如系统设定取值范围很小且固定的场景
- SMALLINT ：可以用于较小范围的统计数据，比如统计工厂的固定资产库存数量等
- MEDIUMINT ：用于较大整数的计算，比如车站每日的客流量等
- INT、INTEGER ：取值范围足够大，一般情况下不用考虑超限问题，用得最多。比如商品编号
- BIGINT ：只有当你处理特别巨大的整数时才会用到。比如双十一的交易量、大型门户网站点击量、证券公司衍生产品持仓等

## 三、浮点类型

### 一、浮点数

![MySQL浮点类型](../../../TyporaImage/MySQL浮点类型.png)

### 二、定点数

|         数据类型         | 字节数  |        含义        |
| :----------------------: | :-----: | :----------------: |
| DECIMAL(M,D),DEC,NUMERIC | M+2字节 | 有效范围由M和D决定 |

1. MySQL中的定点数只有DECIMAL一种类型
2. 使用 DECIMAL(M,D) 的方式表示高精度小数。其中，M被称为精度，D被称为标度。0<=M<=65， 0<=D<=30，D<M。例如，定义DECIMAL（5,2）的类型，表示该列取值范围是-999.99~999.99
3. DECIMAL(M,D)的最大取值范围与DOUBLE类型一样，但是有效的数据范围是由M和D决定的。 DECIMAL 的存储空间并不是固定的，由精度值M决定，总共占用的存储空间为M+2个字节。也就是 说，在一些对精度要求不高的场景下，比起占用同样字节长度的定点数，浮点数表达的数值范围可以更大一些
4. 定点数在MySQL内部是以 字符串 的形式进行存储，这就决定了它一定是精准的
5. 当DECIMAL类型不指定精度和标度时，其默认为DECIMAL(10,0)。当数据的精度超出了定点数类型的精度范围时，则MySQL同样会进行四舍五入处理
6. 浮点数VS定点数
   - 浮点数相对于定点数的优点是在长度一定的情况下，浮点类型取值范围大，但是不精准，适用于需要取值范围大，又可以容忍微小误差的科学计算场景（比如计算化学、分子建模、流体动力学等）
   - 定点数类型取值范围相对小，但是精准，没有误差，适合于对精度要求极高的场景 （比如涉及金额计算的场景）

## 四、位类型

| 二进制字符串类型 | 长度 |   长度范围   |      占用空间       |
| :--------------: | :--: | :----------: | :-----------------: |
|      BIT(M)      |  M   | 1 <= M <= 64 | 约为(M + 7)/8个字节 |

1. BIT类型中存储的是二进制值，类似010110
2. BIT类型，如果没有指定(M)，默认是1位。这个1位，表示只能存1位的二进制值。这里(M)是表示二进制的位数，位数最小值为1，最大值为64
3. 在向BIT类型的字段中插入数据时，一定要确保插入的数据在BIT类型支持的范围内
4. 使用SELECT命令查询位字段时，可以用 BIN() 二进制表示或 HEX() 十六进制显示函数进行读取
5. 使用b+0查询数据时，可以直接查询出存储的十进制数据的值

## 五、日期时间类型

![MySQL日期时间类型](../../../TyporaImage/MySQL日期时间类型.png)

1. YEAR 类型通常用来表示年，格式为 YYYY
2. DATE 类型通常用来表示年、月、日，格式为 YYYY-MM-DD
3. TIME 类型通常用来表示时、分、秒。不光表示一天之内的时间，而且可以用来表示一个时间间隔，这个时间间隔可以超过 24 小时，格式为HH:MM:SS
4. DATETIME 类型通常用来表示年、月、日、时、分、秒，格式为YYYY-MM-DD HH:MM:SS 
5. TIMESTAMP 类型通常用来表示带时区的年、月、日、时、分、秒，存储的是时间戳，但是显示的则是正常的日期时间格式
   - TIMESTAMP类型也可以表示日期时间，其显示格式与DATETIME类型相同，都是 YYYY-MM-DD HH:MM:SS
   - 需要4个字节的存储空间。但是TIMESTAMP存储的时间范围比DATETIME要小很多，只能存储 “1970-01-01 00:00:01 UTC”到“2038-01-19 03:14:07 UTC”之间的时间。其中，UTC表示世界统一时间，也叫作世界标准时间
   - 存储数据的时候需要对当前时间所在的时区进行转换，查询数据的时候再将时间转换回当前的时区。因此，使用TIMESTAMP存储的同一个时间值，在不同的时区查询时会显示不同的时间
   - TIMESTAMP和DATETIME的区别：TIMESTAMP存储空间比较小，表示的日期时间范围也比较小；底层存储方式不同，TIMESTAMP底层存储的是毫秒值，距离1970-1-1 0:0:0 0毫秒的毫秒值；两个日期比较大小或日期计算时，TIMESTAMP更方便、更快；TIMESTAMP和时区有关。TIMESTAMP会根据用户的时区不同，显示不同的结果。而DATETIME则只能反映出插入时当地的时区，其他时区的人查看数据必然会有误差的

## 六、文本字符串类型

![MySQL文本字符串类型](../../../TyporaImage/MySQL文本字符串类型.png)

### 一、CHAR和VARCHAR类型

1. CHAR类型

   - CHAR(M) 类型一般需要预先定义字符串长度。如果不指定(M)，则表示长度默认是1个字符
   - 如果保存时，数据的实际长度比CHAR类型声明的长度小，则会在 右侧填充 空格以达到指定的长度。当MySQL检索CHAR类型的数据时，CHAR类型的字段会去除尾部的空格
   - 定义CHAR类型字段时，声明的字段长度即为CHAR类型字段所占的存储空间的字节数

2. VARCHAR类型

   - VARCHAR(M) 定义时， 必须指定 长度M，否则报错
   - MySQL4.0版本以下，varchar(20)：指的是20字节，如果存放UTF8汉字时，只能存6个（每个汉字3字节） ；MySQL5.0版本以上，varchar(20)：指的是20字符
   - 检索VARCHAR类型的字段数据时，会保留数据尾部的空格。VARCHAR类型的字段所占用的存储空间为字符串实际长度加1个字节

3. CHAR或VARCHAR适用的场景

   |    类型    |   特点   |    空间上    | 时间上 |       适用场景       |
   | :--------: | :------: | :----------: | :----: | :------------------: |
   |  CHAR(M)   | 固定长度 | 浪费存储空间 | 效率高 | 存储不大，速度要求高 |
   | VARCHAR(M) | 可变长度 | 节省存储空间 | 效率低 |     非CHAR的情况     |

   - 存储很短的信息。比如门牌号码101，201……这样很短的信息应该用char，因为varchar还要占个 byte用于存储信息长度，本来打算节约存储的，结果得不偿失

   - 固定长度的。比如使用uuid作为主键，那用char应该更合适。因为他固定长度，varchar动态根据长度的特性就消失了，而且还要占个长度信息

   - 十分频繁改变的column。因为varchar每次存储都要有额外的计算，得到长度等工作，如果一个非常频繁改变的，那就要有很多的精力用于计算，而这些对于char来说是不需要的，则使用VARCHAR会更好

   - MyISAM 数据存储引擎和数据列：MyISAM数据表，最好使用固定长度(CHAR)的数据列代替可变长度(VARCHAR)的数据列。这样使得整个表静态化，从而使 数据检索更快 ，用空间换时间；

     MEMORY 存储引擎和数据列：MEMORY数据表目前都使用固定长度的数据行存储，因此无论使用CHAR或VARCHAR列都没有关系，两者都是作为CHAR类型处理的；

     InnoDB 存储引擎，建议使用VARCHAR类型。因为对于InnoDB数据表，内部的行存储格式并没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），而且主要影响性能的因素是数据行使用的存储总量，由于char平均占用的空间多于varchar，所以除了简短并且固定长度的，其他考虑varchar。这样节省空间，对磁盘I/O和数据存储总量比较好

### 二、TEXT类型

| 文本字符串类型 |        特点        | 长度 |             长度范围             | 占用的存储空间 |
| :------------: | :----------------: | :--: | :------------------------------: | :------------: |
|    TINYTEXT    |  小文本、可变长度  |  L   |          0 <= L <= 255           |   L+2个字节    |
|      TEXT      |   文本、可变长度   |  L   |         0 <= L <= 65535          |   L+2个字节    |
|   MEDIUMTEXT   | 中等文本、可变长度 |  L   |        0 <= L <= 16777215        |   L+3个字节    |
|    LONGTEXT    |  大文本、可变长度  |  L   | 0 <= L<= 4294967295（相当于4GB） |   L+4个字节    |

## 七、ENUM枚举类型

| 文本字符串类型 | 长度 |    长度范围     | 占用的存储空间 |
| :------------: | :--: | :-------------: | :------------: |
|      ENUM      |  L   | 1 <= L <= 65535 |   1或2个字节   |

1. ENUM类型也叫作枚举类型，ENUM类型的取值范围需要在定义字段时进行指定。设置字段值时，ENUM类型只允许从成员中选取单个值，不能一次选取多个值

2. 当ENUM类型包含1～255个成员时，需要1个字节的存储空间；当ENUM类型包含256～65535个成员时，需要2个字节的存储空间；ENUM类型的成员个数的上限为65535个

3. 创建ENUM枚举类型以及添加ENUM枚举类型数据

   ```mysql
   #创建表
   CREATE TABLE test_enum(
   season ENUM('春','夏','秋','冬','unknow')
   );
   
   #添加数据
   INSERT INTO test_enum
   VALUES('春'),('秋');
   # 忽略大小写
   INSERT INTO test_enum
   VALUES('UNKNOW');
   # 允许按照角标的方式获取指定索引位置的枚举值，数据库中的索引是从1开始的
   INSERT INTO test_enum
   VALUES('1'),(3);
   # 当ENUM类型的字段没有声明为NOT NULL时，插入NULL也是有效的
   INSERT INTO test_enum
   VALUES(NULL);
   ```

## 八、SET类型

当SET类型包含的成员个数不同时，其所占用的存储空间也是不同的，具体如下：

| 成员个数范围（L表示实际成员个数） | 占用的存储空间 |
| :-------------------------------: | :------------: |
|            1 <= L <= 8            |    1个字节     |
|           9 <= L <= 16            |    2个字节     |
|           17 <= L <= 24           |    3个字节     |
|           25 <= L <= 32           |    4个字节     |
|           33 <= L <= 64           |    8个字节     |

1. SET表示一个字符串对象，可以包含0个或多个成员，但成员个数的上限为 64 。设置字段值时，可以取取值范围内的 0 个或多个值

2. SET类型在存储数据时成员个数越多，其占用的存储空间越大。注意：SET类型在选取成员时，可以一次选择多个成员，这一点与ENUM类型不同

3. 创建SET类型以及添加数据

   ```mysql
   #创建表
   CREATE TABLE test_set(
   s SET ('A', 'B', 'C')
   );
   
   #添加数据
   INSERT INTO test_set (s) VALUES ('A'), ('A,B');
   #插入重复的SET类型成员时，MySQL会自动删除重复的成员
   INSERT INTO test_set (s) VALUES ('A,B,C,A');
   #向SET类型的字段插入SET成员中不存在的值时，MySQL会抛出错误。
   INSERT INTO test_set (s) VALUES ('A,B,C,D');
   ```

## 九、二进制字符串类型

### 一、BINARY与VARBINARY类型

| 二进制字符串类型 |   特点   |       值的长度       | 占用空间  |
| :--------------: | :------: | :------------------: | :-------: |
|    BINARY(M)     | 固定长度 | M （0 <= M <= 255）  |  M个字节  |
|   VARBINARY(M)   | 可变长度 | M（0 <= M <= 65535） | M+1个字节 |

1. BINARY和VARBINARY类似于CHAR和VARCHAR，只是它们存储的是二进制字符串
2. BINARY (M)为固定长度的二进制字符串，M表示最多能存储的字节数，取值范围是0~255个字符。如果未指定(M)，表示只能存储 1个字节 。例如BINARY (8)，表示最多能存储8个字节，如果字段值不足(M)个字 节，将在右边填充'\0'以补齐指定长度
3. VARBINARY (M)为可变长度的二进制字符串，M表示最多能存储的字节数，总字节数不能超过行的字节长度限制65535，另外还要考虑额外字节开销，VARBINARY类型的数据除了存储数据本身外，还需要1或2个字节来存储数据的字节数。VARBINARY类型 必须指定(M) ，否则报错

### 二、BLOB类型

| 二进制字符串类型 | 值的长度 |             长度范围              |   占用空间   |
| :--------------: | :------: | :-------------------------------: | :----------: |
|     TINYBLOB     |    L     |           0 <= L <= 255           | L + 1 个字节 |
|       BLOB       |    L     |   0 <= L <= 65535（相当于64KB）   | L + 2 个字节 |
|    MEDIUMBLOB    |    L     | 0 <= L <= 16777215 （相当于16MB） | L + 3 个字节 |
|     LONGBLOB     |    L     | 0 <= L <= 4294967295（相当于4GB） | L + 4 个字节 |

1. BLOB是一个二进制大对象，可以容纳可变数量的数据

2. MySQL中的BLOB类型包括TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB 4种类型，它们可容纳值的最大长度不同。可以存储一个二进制的大对象，比如图片、音频和视频等

3. 需要注意的是，在实际工作中，往往不会在MySQL数据库中使用BLOB类型存储大对象数据，通常会将图 

   片、音频和视频文件存储到 服务器的磁盘上 ，并将图片、音频和视频的访问路径存储到MySQL中

4. TEXT和BLOB的使用注意事项：

   - BLOB和TEXT值也会引起自己的一些问题，特别是执行了大量的删除或更新操作的时候。删除这种值会在数据表中留下很大的" 空洞 "，以后填入这些"空洞"的记录可能长度不同。为了提高性能，建议定期使用 OPTIMIZE TABLE 功能对这类表进行 碎片整理 
   - 如果需要对大文本字段进行模糊查询，MySQL 提供了 前缀索引 。但是仍然要在不必要的时候避免检索大型的BLOB或TEXT值。例如，SELECT * 查询就不是很好的想法，除非你能够确定作为约束条件的WHERE子句只会找到所需要的数据行。否则，你可能毫无目的地在网络上传输大量的值
   - 把BLOB或TEXT列 分离到单独的表 中。在某些环境中，如果把这些数据列移动到第二张数据表中，可以让你把原数据表中的数据列转换为固定长度的数据行格式，那么它就是有意义的。这会 减少主表中的碎片 ，使你得到固定长度数据行的性能优势。它还使你在主数据表上运行 SELECT * 查询的时候不会通过 网络传输大量的BLOB或TEXT值

## 十、JSON类型

1. JSON（JavaScript Object Notation）是一种轻量级的 数据交换格式 。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。它易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。JSON可以将JavaScript对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式

2. 在MySQL 5.7中，就已经支持JSON数据类型。在MySQL 8.x版本中，JSON类型提供了可以进行自动验证的JSON文档和优化的存储结构，使得在MySQL中存储和读取JSON类型的数据更加方便和高效

3. 创建并使用JSON类型

   ```mysql
   #创建JSON字段
   CREATE TABLE test_json(
   字段名为js json
   );
   
   #添加json数据
   INSERT INTO test_json (js)
   VALUES ('{"name":"songhk", "age":18, "address":{"province":"beijing",
   "city":"beijing"}}');
   
   #当需要检索JSON类型的字段中数据的某个具体值时，可以使用“->”和“->>”符号
   SELECT js -> '$.name' AS NAME,js -> '$.age' AS age ,js -> '$.address.province'
   AS province, js -> '$.address.city' AS city FROM test_json
   ```

## 十一、空间类型

