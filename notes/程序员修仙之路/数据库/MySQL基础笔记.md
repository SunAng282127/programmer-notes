# 一、数据库概述

## 一、数据库的作用

- 持久化：把数据保存到可掉电式存储设备中以供之后使用，数据持久化意味着将内存中的数据保存到硬盘上加以固化
- 持久化的主要作用是将内存中的数据存储在关系型数据库中

## 二、数据库与数据库管理系统

1. DB：数据库（Database）：即存储数据的仓库，其本质是一个文件提供。保存了一系列有组织的数据
2. DBMS：数据库管理系统（Database Management System）：一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制。用户通过数据库管理系统访问数据库中表内的数据。MySQL就是数据库管理系统的一种
3. SQL：结构化查询语言（Structured Query Language）：专门用来与数据库通信的语言

## 三、Oracle VS MySQL

1. Oracle更适合大型跨国企业的使用，因为他们对费用不敏感，但是对性能要求以及安全性有更高的要求
2. MySQL由于其体积小、速度块、总体拥有成本低，可处理上千万条记录的大型数据库，尤其是开放源码这一特点，使得很多互联网公司、中小型网站选择使用MySQL作为网站数据库

## 四、RDBMS VS 非RDBMS 

### 一、关系型数据库（RDBMS）

1. 实质
	- 关系型数据库模型是把复杂的数据结构归结为简单的二元关系（即二维表格形式）
	- 关系型数据库以row（行）和列（column）的形式存储数据。这一系列的行和列被称为表（table），一组表组成了一个库（database）
	- 表和表之间的数据记录有关系（relationship）。现实世界中的各种实体以及实体之间的各种联系均用关系模式来表示。关系型数据库，就是建立在关系模型基础上的数据库
	- SQL就是关系型数据库的查询语句
2. 优势
	- 复杂查询：可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询
	- 事物支持：使得对于安全性能很高的数据访问要求得以实现

### 二、非关系型数据库（非RDBMS）

1. 实质
	- 非关系型数据库是基于键值对存储数据，不需要经过SQL层的解析，性能非常高、同时通过减少不常用的功能，进一步提高性能
	- 大部分主流的非关系型数据库都是免费的
2. 分类
	- 键值型数据库：键值型数据库通过key-value键值的方式存储数据，其中key和value可以是简单的对象，也可以是复杂的对象。key作为唯一的标识符，优点是查找速度快，在这方面优于关系型数据库，缺点是无法像关系型数据库一样使用条件过滤，如果不知道去哪里找数据，就要遍历所有的键，这样会消耗大量的计算。键值型数据库典型的使用场景是作为没存缓存。Redis是最流行的键值型数据路
	- 文档型数据库：此类数据库可存放并获取文档，可以是xml、json等格式。再数据库中文档作为处理信息的基本单位，一个文档就相当于一条记录、文档数据库所存放的文档就相当于键值数据库所存放的值。MongoDB是最流行的文档型数据库
	- 搜索引擎数据库：虽然关系型数据库采用了索引提升检索效率，但是针对全文索引效率却很低。搜索引擎数据库是应用再搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检索的时候才能保证性能最优。核心原理是“倒排索引”。Elasticsearch是最流行的搜索引擎数据库
	- 列存数据库：列存数据库是相对于行式存储的数据库，而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的I/O，适合于分布式文件系统，不足在于功能相对有限。HBase是最流行的列式数据库
	- 图形数据库

## 五、关系型数据库设计原则

### 一、设计原则

1. 关系型数据库的典型数据结构就是数据表，这些数据表的组成都是结构化的
2. 将数据放到表中，表再放到库中
3. 一个数据库中可以有多个表，每个表都有一个名字，用来标识自己。表名具有唯一性
4. 表具有一些特性，这些特性定义了数据在表中如何存储，类似于Java中类的设计

### 二、表、记录、字段

1. E-R（entity-relationship，实体-联系）模型中的有三个主要概念是：实体集、属性、联系集
2. 一个实体集（class）对应于数据库中的一个表（table）；一个实体（instance）则对应数据库表中的一行（row），也称为一条记录（record）；一个属性（attribute）对应于数据库表中的一列（column）。也称为一个字段（field）。ORM思想（Object Relational Mapping）体现为：
	- 数据库中一个表	<----->	Java或Python中的一个类
	- 表中的一条数据    <----->     类中的一个对象（或实体）
	- 表中的一个列        <----->     类中的一个字段、属性（field）
3. 表的关联关系
	- 表与表之间的数据记录有关系（relationship）。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示
	- 一对一关联（one-to-one）：外键唯一，主表的主键和从表的外键（唯一），形成主外键关系，外键唯一；外键是主键，主表的主键和从表的主键，形成主外键关系
	- 一对多关系（one-to-many）：在从表（多方）创建一个字段，字段作为外键指向主表（一方）的主键
	- 多对多关系（many-to-many）：要表示多对多关系，必须创建第三个表，该表通常称为联接表，它将多对多关系划分为两个一对多关系。将这两个表的主键都插入到第三个表中
	- 自我引用（Self reference）：一个表通过本表的某个字段关联本表

# 二、MySQL下载安装设置

## 一、MySQL下载地址

[Mysql最新下载地址](https://dev.mysql.com/downloads/mysql/)

## 二、MySQL安装步骤

1. 下载Mysql安装包
2. 如若提示缺少VSCode安装包，在[VSCode下载地址](https://learn.microsoft.com/zh-cn/cpp/windows/latest-supported-vc-redist?view=msvc-170#visual-studio-2015-2017-2019-and-2022)下载安装VS即可
3. 傻瓜式安装即可，换一下安装路径

## 三、MySQL登录

1. mysql的启动与关闭命令

	```mysql
	net start mysql(数据库管理软件名称) // 开启数据库
	net stop mysql(数据库管理软件名称) // 关闭数据库
	```

2. mysql的登录

	```mysql
	mysql -u 用户名 =p直接写密码
	mysql -u 用户名 -P 端口号 -h url主机地址 -p // 端口号和url主机地址是3306和本地的数据库可以省略
	```

## 四、MySQL命令行使用

1. show databases;    查询所有的数据库
2. create database 新的数据库名称;    创建新的数据库
3. drop database 数据库名称;    删除数据库
4. use 数据库名;    使用指定的数据库，才能进行以下操作
5. create table 表名(字段名1 字段类型1,字段名2 字段类型2);    创建新的表
6. drop table 表名;    删除表
7. show create database 创建的数据库名称/创建的表名;    查询创建的数据库或表的创建信息
8. show varibles like 'character_%';    查询数据库中所使用的字符集

# 三、基本的SELECT语句

## 一、SQL分类

1. DDL（Data Definition Languages，数据定义语言），这些语言定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除和修改数据库和数据表的结构。主要语句关键字包含：CREAT、DROP、ALTER、RENAME、TRUNCATE等
2. DML（Data Manipulation Languages，数据操作语言），用于添加、删除、更新和查询数据库记录，并检查数据完整性。主要语句关键字包含：INSERT、DELETE、UPDATE、SELECT等
3. DCL（Data Control Languages，数据控制语言），用于定义数据库、表、字段、用户的访问权限和安全级别。主要语句关键字包含：GRANT、REVOKE、COMMIT、ROLLBACK、SAVEPOINT等

## 二、SQL语言规则与规范

### 一、基本规则

1. SQL可以写在一行或者多行。为了提高可读性，各子句分别写，必要时使用缩进
2. 每条命令以';'、'\g'、'\G'结束
3. 关键字不能被缩写也不能分行
4. 关于标点符号
	- 必须保证所有的()、单引号、双引号是成对结束的
	- 必须使用英文状态下的半角输入方式
	- 字符串型和日期时间类型的数据可以使用单引号（‘’）表示
	- 列的别名，尽量使用双引号（”“），而且不建议省略as

### 二、SQL大小写规范

1. MySQL在Windows环境下是大小写不敏感的
2. MySQL在Linux环境下是大小写敏感的
	- 数据库名、表名、表的别名、变量名严格区分大小写的
	- 关键字、函数名、列名（或字段名）、列的别名（字段的别名）是忽略大小写的
3. 推荐采用统一的书写规范
	- 数据库名、表名、表别名、字段名、字段别名等都小写
	- SQL关键字、函数名、绑定变量等都大写

### 三、注释

```mysql
单行注释：#注释文字（MySQL特有的方式）
单行注释：-- 注释文字（--后面必须包含一个空格）
多行注释：/* 注释文字 */
```

### 四、命名规则

1. 数据库、表名不得超过30个字符，变量名限制为29个
2. 必须只能包含A-Z、a-z、0-9、_共63个字符
3. 数据库名、表名、字段名等对象名中间不要包含空格
4. 同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名
5. 必须保证字段不能和保留字、数据库系统或常用方法冲突。如果坚持使用，在SQL语句中使用``（着重号）引起来
6. 保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性、假如数据类型在一个表里是整型，那在另一个表里就别变成字符型

## 三、导入SQL文件方式

1. source 文件的全路径名称
2. 基于图形化工具导入

## 四、最基本的SELECT语句

1. SELECT */字段名1，字段名2…… FROM 表名
	- *：表的全字段
	- 若只查询不用表名的数据，则FROM和表名可以省略
2. 列的别名
	- AS：全称alias（别名），可以省略
	- 列的别名可以使用一对”“引起来
3. 去除重复行
	- DISTINCT：去重关键字，去除重复数据
	- DISTINCT关键字要紧跟SELECT，如果后面有多个字段，则去重的规则是每一行所有的字段加起来去掉重复的数据，而不是单独字段去重
4. 空值参与运算
	- 空值：null
	- null不等同于0、''、’null‘
	- null值参与运算时，结果也是null
	- MySQL可以使用IFNULL将null值替换为指定的数据
5. 着重号
	- 字段、表名等自定义的和保留字、数据库系统或常用方法冲突。如果坚持使用，在SQL语句中使用``（着重号）引起来
6. 查询常数
	- 相当于写死数据
7. 显示表结构
	- 使用DESCRIBE或DESC命令+表名，表示表结构
	- 显示表中字段的详细信息
8. 过滤数据
	- 使用WHERE关键字
	- WHERE需要声明在FROM后，ORDER BY之前

# 四、运算符

## 一、算术运算符

1. 加法与减法运算符（+、-）
	- 一个整数类型的值对整数进行加法和减法操作，结果还是一个整数
	- 一个整数类型的值对浮点数进行加法和减法操作，结果是一个浮点数
	- 加法和减法的优先级相同，进行先加后减操作与进行先减后加操作的结果是一样的
	- 在Java中，+的左右两边如果有字符串，那么表示字符串的拼接。但是在MySQL中+只表示数值相加。如果遇到非数值类型，先尝试转成数值，如果转失败，就按0计算。（MySQL中字符串拼接要使用字符串函数CONCAT()实现）
2. 乘法与除法运算符（*、/或div）
	- 一个数乘以整数1和除以整数1后仍得原数
	- 一个数乘以浮点数1和除以浮点数1后变成浮点数，数值与原数相等
	- 一个数除以整数后，不管是否能除尽，结果都为一个浮点数
	- 一个数除以另一个数，除不尽时，结果为一个浮点数，并保留到小数点后4位
	- 乘法和除法的优先级相同，进行先乘后除与先除后乘操作，得出的结果相同
	- 在数学运算中，0不能用作除数，在MySQL中，一个数除以0为NULL
3. 取模运算（%或mode）
	- 取模的正负号取决于被模数的正负号
	- 被模数也就是%前后的数据

## 二、非算术运算符

1. =、<=>、<>或!=、<、<=、>、>=

	- 等于运算符（=）判断等号两边的值、字符串或表达式是否相等，如果相等则返回1，不相等则返回0
	- 如果等号两边的值、字符串或表达式都为字符串，则MySQL会按照字符串进行比较，其比较的是每个字符串中字符的ANSI编码是否相等
	- 如果等号两边的值都是整数，则MySQL会按照整数来比较两个值的大小
	- 如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较
	- 如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL
	- SQL中赋值符号使用:=
	- 安全等于运算符（<=>）与等于运算符（=）的作用是相似的，唯一的区别是<=>可以用来对NULL进行判断。在两个操作数均为NULL时，其返回值为1，而不为NULL；当一个操作数为NULL时，其返回值为0，而不为NULL。安全等于运算符（<=>）为NULL而生。若使用安全等于运算符查询不等于的数据规则为：NOT 字段名 <=> NULL

2. IS NULL、IS NOT NULL、LEAST、GREATEST、BETWEEN AND、ISNULL、IN、NOT IN、LIKE、REGEXP、RLIKE

	- IS NULL：查询某字段是NULL的数据

	- IS NOT NULL：查询某字段不是NULL的数据

	- ISNULL(字段名) 函数：查询某字段是NULL的数据

	- LEAST(多个字段名) 函数：查询多个字段中最小的数据。数值值则按照数值比较大小；如果对比字段的值都为字符串，则MySQL会按照字符串进行比较，其比较的是每个字符串中字符的ANSI编码的大小

	- GREATEST(多个字段名) 函数：查询某字段中最大的数据。数值值则按照数值比较大小；如果对比字段的值都为字符串，则MySQL会按照字符串进行比较，其比较的是每个字符串中字符的ANSI编码的大小

	- BETWEEN 条件1 AND 条件2：查询条件1和条件2范围内的数据，包含边界。条件1为下限；条件2为上限，且不能交换。不在条件1和条件2区间的写法为：字段名 NOT BETWEEN 条件1 AND 条件2，不包含边界

	- IN(set集合)：查询某字段在set集合中的数据

	- NOT IN(set集合)：查询某字段不在set集合中的数据

	- LIKE：模糊查询。%代表不确定个数（0-多个）的字符；_代表一个不确定的字符；\代表转义字符

	- REGEXP\RLIKE：REGEXP运算符用来匹配字符串，语法格式为：expr REGEXP 匹配条件、如果expr满足匹配条件，返回1；如果不满足，则返回0。若expr或匹配条件任意一个为NULL，则结果为NULL

		```mysql
		'^'匹配以该字符后面的字符开头的字符串
		'$'匹配以该字符前面的字符结尾的字符串
		'.'匹配任何一个单字符
		'[...]'匹配在方括号内的任何字符。例如，"[abc]"匹配"a"或"b"或"c"、为了命名字符的范围，使用一个'-'，"[a-z]"匹配任何字母，"[0-9]"匹配任何数字
		'*'匹配零个或多个在它前面的字符。例如，'x*'匹配任何数量的'x'字符，"[0-9]*"匹配任何数量的数字，而"*"匹配任何数量的任何字符
		```

3. 逻辑运算符

	- 逻辑与（AND或&&）：并且条件
	- 逻辑或（OR或||）：选择条件。逻辑与的优先级低于逻辑与
	- 逻辑非（NOT或!）：
	- 逻辑异或（XOR）： 给定的值中任意一个值为NULL时，则返回NULL；  如果两个非NULL的值都是0或者都不等于0时，则返回0；  如果一个值为0，另一个值不为0时，则返回1。相等于两个条件只需满足其中的一个条件即可，两个都满足也不行

4. 位运算符：在二进制数上进行计算的运算符。位运算符会先将操作数变成二进制，然后进行位运算符，最后将计算结果从二进制变成十进制

	- &：按位与（位AND），当给定值对应的二进制位的数值都为1时，则该位返回1，否则返回0 
	- |：按位或（位OR）， 当给定值对应的二进制位的数值有一个或两个为1时，则该位返回1，否则返回0 
	- ^：按位异或（位XOR），当给定值对应的二进制位的数值不同时，则该位返回1，否则返回0 
	- ~：按位取反（）， 给定的值的二进制数逐位进行取反操作，即将1变为0，将0变为1 
	- `>>`：按位右移，右移指定的位数后，右边低位的数值被移出并丢弃，左边高位空出的位置用0补齐，每向y右移动一位数据除以2
	- `<<`：按位左移， 左移指定的位数后，左边高位的数值被移出并丢弃，右边低位空出的位置用0补齐，每向左移动一位数据乘以2

# 五、排序与分页

## 一、排序

1. 如果没有使用排序操作，默认情况下查询语句返回的数据是按照添加数据的顺序显示的
2. 使用ORDER BY进行排序
3. 升序使用ASC，默认升序；降序使用DESC
4. 可以使用列的别名进行排序。列的别名只能在ORDER BY中使用，不能再WHERE中使用
5. WHERE需要声明在FROM后，ORDER BY之前
6. 可以使用不在SELECT列表中的列排序
7. 在对多列进行排序的时候，首先排序的的第一列必须有相同的列值，才会对第二列进行排序。如果第一列数据中所有值都是唯一的，将不再对第二列进行排序
8. SQL的执行顺序
   - 先执行FROM语句
   - 再执行WHERE语句
   - 然后执行SELECT语句
   - 最后执行ORDER BY语句

## 二、分页

1. 使用LIMIT实现数据的分页显示
2. LIMIT 偏移量,条数：偏移量表示从偏移量+1位数据开始查询，查指定条数的数据
3. MySQL8新特性：LIMIT 条数 OFFSET 偏移量
4. 分页公式：每页显示pageSize条记录，此时显示第pageNo页，则公式为LIMIT (pageNo-1)*pageSize,pageSize

# 六、多表查询

## 一、笛卡尔积

1. 笛卡尔积是一个数学运算。假设有两个集合X和Y，那么X和Y的笛卡尔积就是X和Y的所有可能组合，也就是第一个对象来自于X，第二个对象来自于Y的所有可能。组合的个数即为两个集合中元素个数的乘积数

   ```mysql
   -- 此时查询出来的数据条数为sys_user的个数乘以sys_dept的个数，前表每一条数据都与后表每一条数据关联
   SELECT user_id,dept_id
   FROM sys_user,sys_dept
   ```

2. 笛卡尔积称为交叉连接，英文为CROSS JOIN，在SQL中也使用CROSS JOIN进行连接，它的作用就是可以把任意表进行连接，即使这两张表不相关

3. SQL中出现笛卡尔积的情况

   - 省略多个表的连接条件（或关联条件）
   - 连接条件（或关联条件）无效
   - 所有表中的所有行互相连接

## 二、多表查询的建议和规范

1. 如果查询语句中出现了多个表中都存在的字段，则必须指明此字段所在的表
2. 从SQL优化的角度，建议多表查询时，每个字段前都指明其所在的表
3. 可以给表起别名，如果给表起了别名，在使用此表时必须使用别名，不能再使用原表名
4. 如果有n个表实现多表的查询，则需要至少n-1个连接条件

## 三、多表查询的分类

### 一、等值连接 VS 非等值连接

1. 等值连接：使用=连接查询条件
2. 非等值连接：使用=之外的运算符连接查询条件

### 二、自连接 VS 非自连接

1. 自连接：本表连接本表
2. 非自连接：本表连接外表

### 三、内连接 VS 外连接

1. 内连接：合并具有同一列的两个以上的表的行，结果集中不包含一个表与另一个表不匹配的行

   - 使用JOIN ON进行连接

2. 外连接：合并具有同一列的两个以上的表的行，结果集中除了包含一个表与另一个表匹配的行之外，还查询到了左表或右表中不匹配的行

   - 左外连接：两个表在连接过程中除了返回满足连接条件的行以外还返回左表中不满足条件的行。使用LEFT　JOIN ON进行连接

   - 右外连接：两个表在连接过程中除了返回满足连接条件的行以外还返回右表中不满足条件的行。使用RIGHT

     JOIN ON进行连接

   - 满外连接：两个表在连接过程中除了返回满足连接条件的行以外还返回左表和右表中不满足条件的行。使用FULL JOIN ON进行连接。但是在MySQL中不支持，可以使用UNION或UNION ALL操作进行数据拼合

## 四、实现七种JOIN操作

![查询分类](../../../TyporaImage/SQL JOINS.png)

## 五、UNION操作

1. 利用UNION关键字，可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并时，两个表对应的列数和数据类型必须相同，并且相互对应。各个SELECT语句之间使用UNION或UNION ALL关键字分割
2. UNION操作符：UNION操作符返回两个查询的结果集的并集，去除重复记录
3. UNION ALL操作符：UNION ALL操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重
4. UNION ALL操作语句所需的资源比UNION操作语句少。如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复数据，则尽量使用UNION ALL操作语句，以提高数据查询的效率

## 六、SQL99新特性

- NATURAL JOIN：会自动查询两张（只能用于两张表）连接表中所有相同的字段，然后进行等值连接

	```mysql
	SELECT * FROM sys_user_role
	NATURAL JOIN sys_role
	```

- JOIN...USING：USING指定了具体的相同的字段名称，需要在USING的括号()中填入要指定的同名字段，必须同名。同时使用JOIN...USING可以简化JOIN ON的等值连接

	```mysql
	SELECT * FROM sys_user_role
	LEFT JOIN sys_role USING(role_id)
	```

# 七、函数

## 一、单行函数

### 一、单行函数的含义

1. 操作数据对象
2. 接受参数返回一个结果
3. 只对一行进行变换
4. 每行返回一个结果
5. 可以嵌套
6. 参数可以是一列或一个值

### 二、数值函数

#### 一、基本函数

![MySQl基本数值函数](../../../TyporaImage/MySQL%E5%9F%BA%E6%9C%AC%E6%95%B0%E5%80%BC%E5%87%BD%E6%95%B0.png)

#### 二、角度与弧度互换函数

![角度与弧度互换函数](../../../TyporaImage/MySQL%E6%95%B0%E5%80%BC%E5%87%BD%E6%95%B0%E8%A7%92%E5%BA%A6%E4%B8%8E%E5%BC%A7%E5%BA%A6%E4%BA%92%E6%8D%A2%E5%87%BD%E6%95%B0.png)

#### 三、三角函数

![三角函数](../../../TyporaImage/MySQL%E6%95%B0%E5%80%BC%E5%87%BD%E6%95%B0%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0.png)

#### 四、指数与对数

![MySQL数值函数指数与对数](../../../TyporaImage/MySQL%E6%95%B0%E5%80%BC%E5%87%BD%E6%95%B0%E6%8C%87%E6%95%B0%E4%B8%8E%E5%AF%B9%E6%95%B0.png)

#### 五、进制间的转换

![MySQL数值函数进制间的转换](../../../TyporaImage/MySQL%E6%95%B0%E5%80%BC%E5%87%BD%E6%95%B0%E8%BF%9B%E5%88%B6%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.png)

### 三、字符串函数

![MySQL字符串函数1](../../../TyporaImage/MySQL%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B01.png)

![MySQl字符串函数2](../../../TyporaImage/MySQL%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B02.png)

![MySQL字符串函数3](../../../TyporaImage/MySQL%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B03.png)

### 四、日期和时间函数

1. 获取日期、时间

	![MySQL获取日期、时间](../../../TyporaImage/MySQL%E8%8E%B7%E5%8F%96%E6%97%A5%E6%9C%9F%E3%80%81%E6%97%B6%E9%97%B4.png)

2. 日期与时间戳的转换

	![MySQL日期与时间戳的转换](../../../TyporaImage/MySQL%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4%E6%88%B3%E7%9A%84%E8%BD%AC%E6%8D%A2.png)

3. 获取月份、星期、星期数、天数等函数

	![MySQL获取月份、星期、星期数、天数等函数](../../../TyporaImage/MySQL%E8%8E%B7%E5%8F%96%E6%9C%88%E4%BB%BD%E3%80%81%E6%98%9F%E6%9C%9F%E3%80%81%E6%98%9F%E6%9C%9F%E6%95%B0%E3%80%81%E5%A4%A9%E6%95%B0%E7%AD%89%E5%87%BD%E6%95%B0.png)

4. 日期的操作函数

	![MySQL日期的操作函数](../../../TyporaImage/MySQL%E6%97%A5%E6%9C%9F%E7%9A%84%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0.png)

5. 时间和秒钟转换的函数

	![MySQL时间和秒钟转换的函数](../../../TyporaImage/MySQL%E6%97%B6%E9%97%B4%E5%92%8C%E7%A7%92%E9%92%9F%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%87%BD%E6%95%B0.png)

6. 计算日期和时间的函数

	![MySQl计算日期和时间的函数](../../../TyporaImage/MySQL%E8%AE%A1%E7%AE%97%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E7%9A%84%E5%87%BD%E6%95%B01.png)

	![MySQL计算日期和时间的函数](../../../TyporaImage/MySQL%E8%AE%A1%E7%AE%97%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E7%9A%84%E5%87%BD%E6%95%B02.png)

7. 日期的格式化与解析

	![MySQL日期的格式化与解析](../../../TyporaImage/MySQL%E6%97%A5%E6%9C%9F%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8E%E8%A7%A3%E6%9E%901.png)

	​	 非GET_FORMAT()函数中frmt参数常用的格式符

	​	 ![MySQL日期的格式化与解析2](../../../TyporaImage/MySQL%E6%97%A5%E6%9C%9F%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8E%E8%A7%A3%E6%9E%902.png)

	​     GET_FORMAT()函数中frmt参数常用的格式符

	​	 ![MySQL日期的格式化与解析3](../../../TyporaImage/MySQl%E6%97%A5%E6%9C%9F%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8E%E8%A7%A3%E6%9E%903.png)

### 五、流程控制函数

![MySQL流程控制函数](../../../TyporaImage/MySQL%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0.png)

### 六、加密与解密函数

![MySQL加密解密函数](../../../TyporaImage/MySQL%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%87%BD%E6%95%B0.png)

### 七、MySQL信息函数

![MySQL信息函数](../../../TyporaImage/MySQL%E4%BF%A1%E6%81%AF%E5%87%BD%E6%95%B0.png)

### 八、其他函数

![MysQl其他函数](../../../TyporaImage/MySQL%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0.png)

## 二、聚合函数

### 一、聚合函数的含义

- 聚合函数作用于一组数据，并对一组数据返回一个值
- 聚合函数不能嵌套使用。比如不能出现类似“AVG(SUM(字段名称))”形式的调用

### 二、AGE和SUM函数

- 可以对数值型数据使用AGE和SUM函数

### 三、MIN和MAX函数

- 可以对任意数据类型的数据使用MIN和MAX函数

### 四、COUNT函数

1. COUNT(*)返回表中记录总数，适用于任意数据类型
2. COUNT(任一数字)返回表中记录总数，适用于任意数据类型，任何数字COUNT()后返回的结果都是一样
3. COUNT(expr)返回expr不为空的记录总数，其中expr为表中的任一字段
   - 如果使用的是MyISAM存储引擎，则COUNT(*)、COUNT(1)和COUNT(expr)的效率是相同的，都是O(1)
   - 如果使用的是InnoDB存储引擎，则COUNT(*)=COUNT(1)>COUNT(expr)

### 五、GROUP BY

1. GROUP BY的作用：可以使用GROUP BY子句将表中的数据分为若干组

2. GROUP BY使用注意点

   - GROUP BY中使用字段的先后顺序对结果并不会产生影响
   - GROUP BY不一定要和聚合函数一起配合使用
   - 在SELECT列表中所有未包含在组函数中的列都应该包含在GROUP BY子句中。人话为SELECT中出现的非组函数的字段必须声明在GROUP BY中，反之，GROUP BY中声明的字段可以不出现在SELECT中

3. MySQL使用GROUP BY中的WITH ROLLUP

   ```mysql
   SELECT dept_id,AVG(salary) avg_sal FROM employees GROUP BY dept_id WITH ROLLUP;
   ```

   - 使用WITH ROLLUP关键字之后，在所有查询到的分组记录之后增加一条记录，该记录计算查询出的所有记录的总和，即统计记录数量
   - 当使用WITH ROLLUP时，不能同时使用ORDER BY子句进行结果排序，即WITH ROLLUP和ORDER BY是互相排斥的

### 六、HAVING

1. HAVING用于过滤数据
2. 如果过滤条件中使用了聚合函数，则必须使用HAVING来替换WHERE，当然WHERE和HAVING可以配合使用，只是HWERE条件中不能出现聚合函数，而HAVING过滤条件可以出现非聚合函数。一般带有聚合函数的过滤条件放在HAVING里面，未有聚合函数的过滤条件放在WHERE里面，因为WHERE的执行效率高
3. HAVING必须声明在GROUP BY的后面。当前HAVING也可以单独使用在非HAVING的查询语句中，但是没有实际开发意义，因为聚合函数没有分组，只会出现一个结果再去过滤就意义不大了
4. WHERE和HAVING的对比
	- WHERE可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件；HAVING建议要与GROUP BY配合使用，可以把分组计算的函数和分组字段作为筛选条件
	- 如果需要通过连接从关联表中获取需要的数据，WHERE是先筛选后连接，而HAVING是先连接后筛选

### 七、SELECT执行过程

1. 查询语法结构

	```mysql
	SELECT ...,....,...------------------------------>
	FROM ... JOIN ...-------------------------------->FROM从哪些表中筛选
	ON 多表的连接条件--------------------------------->ON关联多表查询时，去除笛卡尔积
	JOIN ...
	ON ...
	WHERE 不包含组函数的过滤条件---------------------->WHERE从表中筛选的条件
	AND/OR 不包含组函数的过滤条件
	GROUP BY ...,...-------------------------------->GROUP BY分组依据
	HAVING 包含组函数的过滤条件----------------------->HAVING在统计结果中再次筛选
	ORDER BY ... ASC/DESC--------------------------->ORDER BY排序
	LIMIT ...,...----------------------------------->LIMIT分页
	```

2. 查询执行顺序

	```mysql
	FROM  -> JOIN -> ON -> 
	WHERE -> 
	GROUP BY -> HAVING -> 
	SELECT 的字段 -> DISTINCT ->
ORDER BY -> LIMIT
	```

	在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个 虚拟表 ，然后将这个虚拟表传入下一个步骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的
	
	```
	SELECT 是先执行 FROM 这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤：
		1. 首先先通过 CROSS JOIN 求笛卡尔积，相当于得到虚拟表 vt（virtual table）1-1；
		2. 通过 ON 进行筛选，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表 vt1-2；
		3. 添加外部行。如果我们使用的是左连接、右链接或者全连接，就会涉及到外部行，也就是在虚拟表 vt1-2 		的基础上增加外部行，得到虚拟表 vt1-3。
	当然如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得到是我们的原始数据。
	
	当我们拿到了查询数据表的原始数据，也就是最终的虚拟表 vt1 ，就可以在此基础上再进行 WHERE 阶段 。在这个阶段中，会根据 vt1 表的结果进行筛选过滤，得到虚拟表 vt2 。
	
	然后进入第三步和第四步，也就是 GROUP 和 HAVING 阶段 。在这个阶段中，实际上是在虚拟表 vt2 的
	基础上进行分组和分组过滤，得到中间的虚拟表 vt3 和 vt4 。
	
	当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到 SELECT 和 DISTINCT阶段 。
	
	首先在 SELECT 阶段会提取想要的字段，然后在 DISTINCT 阶段过滤掉重复的行，分别得到中间的虚拟表vt5-1 和 vt5-2 。
	
	当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是 ORDER BY 阶段 ，得到虚拟表 vt6 。
	
	最后在 vt6 的基础上，取出指定行的记录，也就是 LIMIT 阶段 ，得到最终的结果，对应的是虚拟表vt7 。
	```

# 八、子查询

## 一、子查询的含义

- 子查询指一个查询语句嵌套在另一个查询语句内部的查询
- SQL中子查询的使用大大增强了SELECT查询的能力，因为很多时候查询需要从结果集中获取数据，或者需要从同一个表中先计算出一个数据结果，然后与这个数据结果（可能是某个标量，也可能是某个集合）进行比较

## 二、子查询的基本使用

1. 子查询（内查询）在主查询之前一次执行完成
2. 子查询的结果被主查询（外查询）使用
3. 注意事项
   - 子查询要包含在括号内
   - 将子查询放在比较条件的右侧
   - 单行操作符对应单行子查询，多行操作符对应多行子查询

## 三、子查询的分类

### 一、分类方式一

- 按照内查询的结果返回一条还是多条记录，将子查询分为单行子查询、多行子查询

### 二、分类方式二

1. 按照内查询是否被执行多次，将子查询划分为相关（或关联）子查询和不相关（或非关联）子查询
2. 子查询从数据表中查询了数据结果，如果这个数据结果只执行了一次，然后这个数据结果作为主查询的条件进行执行，那么这样的子查询叫做不相关子查询
3. 如果子查询需要执行多次，即采用循环的方式，先从外部查询开始，每次都传入子查询进行查询，然后再将结果反馈给外部，这种嵌套的执行方式就称为相关子查询

## 四、单行子查询

### 一、单行比较操作符

![MySQL单行比较操作符](../../../TyporaImage/MySQL单行比较操作符.png)

### 二、WHERE中的子查询

```mysql
SELECT employee_id, manager_id, department_id
FROM employees
WHERE manager_id =
				(SELECT manager_id
				 FROM employees
				 WHERE employee_id = 174)
AND department_id =
				(SELECT department_id
				 FROM employees
				 WHERE employee_id = 174))
AND employee_id = 174;
```

### 三、HAVING中的子查询

1. 首先执行子查询
2. 向主查询中的HAVING子句返回结果

```mysql
SELECT department_id, MIN(salary)
FROM employees
GROUP BY department_id
HAVING MIN(salary) >
				(SELECT MIN(salary)
				 FROM employees
				 WHERE department_id = 50);
```

### 四、CASE中的子查询

```mysql
SELECT employee_id, last_name,
(CASE department_id
WHEN
(SELECT department_id FROM departments
WHERE location_id = 1800)
THEN 'Canada' ELSE 'USA' END) location
FROM employees;
```

## 五、多行子查询

### 一、多行比较操作符 

![MySQL多行比较操作符](../../../TyporaImage/MySQL多行比较操作符.png)

1. IN：等于列表中的任意一个

   ```mysql
   SELECT employee_id, manager_id, department_id
   FROM employees
   WHERE manager_id IN
   				(SELECT manager_id
   				 FROM employees
   				 WHERE employee_id IN (174,141))
   AND department_id IN
   				(SELECT department_id
   				 FROM employees
   				 WHERE employee_id IN (174,141))
   AND employee_id NOT IN(174,141);
   ```

2. ANY：需要和单行比较操作符一起使用，和子查询返回的某一个值比较

   ```mysql
   SELECT employee_id, manager_id, department_id
   FROM employees
   WHERE salary < ANY
   				(SELECT salary
   				 FROM employees
   				 WHERE employee_id IN (174,141))
   ```

3. ALL：需要和单行比较操作符一起使用，和子查询返回的所有值比较

   ```mysql
   SELECT employee_id, manager_id, department_id
   FROM employees
   WHERE salary < ALL
   				(SELECT salary
   				 FROM employees
   				 WHERE employee_id IN (174,141))
   ```

4. SOME：实际上是ANY的别名，作用相同，一般常使用ANY